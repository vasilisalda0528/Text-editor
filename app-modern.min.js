/* nbdesignerjs
 * @author  netbaseteam
 * @link http://netbaseteam.com
 * @version 2.7.5
 * @created Jun 2016
 * @modified 21, Dec 2020
 * */
var appConfig = {
    localMode: false,
    debugMode: false,
    isModern: true,
    isVisual: false,
    isCuz: false,
    ready: false,
    domainChanged: false,
    init: function(){
        this.mediaUrl = this.localMode ? 'http://localhost/nbmedia/v1' : 'https://studio.cmsmart.net/v1';
        this.domainChanged = NBDESIGNCONFIG.nbdesigner_fix_domain_changed == 'yes' ? true : false;
        this.isModern = NBDESIGNCONFIG.layout == 'modern' ? true : false;
        this.isVisual = NBDESIGNCONFIG.layout == 'visual' ? true : false;
    },
    autoSave: NBDESIGNCONFIG.nbdesigner_auto_save_draft == 'yes' ? true : false,
    loadAllDesign: NBDESIGNCONFIG.nbdesigner_enable_load_all_design == 'yes' ? true : false
};
function arrayMin(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p < v ? p : v);
    });
};
function arrayMax(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p > v ? p : v);
    });
};
/*fabric.Object.prototype._drawControl = function(control, ctx, methodName, left, top) {
    if (!this.isControlVisible(control)) {
        return;
    }
    var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
    switch (this.cornerStyle) {
        case 'circle':
            ctx.beginPath();
            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
            ctx[methodName]();
            if (stroke) {
                ctx.stroke();
            }
            break;
        default:
            this.transparentCorners || ctx.clearRect(left, top, size, size);
            ctx[methodName + 'Rect'](left, top, size, size);
            if (stroke) {
                ctx.strokeRect(left, top, size, size);
            }
    }
    if( control == 'mtr' ){
        var rotateControlIcon = new Image;
        rotateControlIcon.src = "data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3E%3Cpath%20fill='currentColor'%20d='M15.25%2018.48V15a.75.75%200%201%200-1.5%200v4c0%20.97.78%201.75%201.75%201.75h4a.75.75%200%201%200%200-1.5h-2.6a8.75%208.75%200%200%200-2.07-15.53.75.75%200%201%200-.49%201.42%207.25%207.25%200%200%201%20.91%2013.34zM8.75%205.52V9a.75.75%200%200%200%201.5%200V5c0-.97-.78-1.75-1.75-1.75h-4a.75.75%200%200%200%200%201.5h2.6a8.75%208.75%200%200%200%202.18%2015.57.75.75%200%200%200%20.47-1.43%207.25%207.25%200%200%201-1-13.37z'/%3E%3C/svg%3E";
        try {
            ctx.drawImage(rotateControlIcon, left+1, top+1, size-2, size-2);
        } catch (e) {
            //ctx[methodName](left, top, size, size);
        }
    }
};*/
qrcode.stringToBytes = qrcode.stringToBytesFuncs['UTF-8'];
var photoFrames = [{"areas":"\"a\"","rows":"","columns":""},{"areas":"\"a b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"2fr 1fr","columns":""},{"areas":"\"a\"","rows":"","columns":""},{"areas":"\"a b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"","columns":""},{"areas":"\"a\" \"b\"","rows":"2fr 1fr","columns":""},{"areas":"\"b\" \"a\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\"","rows":"","columns":"2fr 1fr"},{"areas":"\"b a\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b c\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\"","rows":"","columns":""},{"areas":"\"a b\" \"c c\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\"","rows":"","columns":""},{"areas":"\"a b\" \"a c\"","rows":"","columns":""},{"areas":"\"a c\" \"b c\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\"","rows":"2fr 1fr","columns":""},{"areas":"\"b c\" \"a a\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\"","rows":"","columns":"2fr 1fr"},{"areas":"\"b a\" \"c a\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a a\" \"b c\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"a c\"","rows":"1fr 2fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"c c\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a\" \"b c\"","rows":"1fr 2fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"a c\"","rows":"1fr 2fr","columns":"1fr 2fr"},{"areas":"\"a b\" \"c b\"","rows":"1fr 2fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"a c\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c b\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a a\" \"b c\"","rows":"","columns":"7fr 5fr"},{"areas":"\"a b\" \"c c\"","rows":"2fr 1fr","columns":"2fr 1fr"},{"areas":"\"a b\" \"a c\"","rows":"2fr 1fr","columns":"2fr 1fr"},{"areas":"\"a b c d\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\"","rows":"","columns":""},{"areas":"\"a a a\" \"b c d\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c\" \"d d d\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\" \"a d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a d\" \"b d\" \"c d\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c d\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b\" \"c d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a b\" \"c d\"","rows":"2fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a\" \"b d\" \"c d\"","rows":"2fr 1fr 1fr","columns":"1fr 2fr"},{"areas":"\"a a b\" \"c d d\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b b\" \"c c d\"","rows":"2fr 1fr","columns":"2fr 1fr 3fr"},{"areas":"\"a b c\" \"a d d\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b\" \"c b\" \"c d\"","rows":"2fr 1fr 3fr","columns":"2fr 1fr"},{"areas":"\"a a\" \"b c\" \"b d\"","rows":"3fr 2fr 2fr","columns":""},{"areas":"\"a b\" \"a d\" \"c d\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a b c d e\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\"","rows":"","columns":""},{"areas":"\"a a\" \"b c\" \"d e\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e e\"","rows":"","columns":""},{"areas":"\"a b d\" \"a c e\"","rows":"","columns":""},{"areas":"\"a b e\" \"c d e\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e e e\"","rows":"","columns":""},{"areas":"\"a b\" \"a c\" \"a d\" \"a e\"","rows":"","columns":""},{"areas":"\"a e\" \"b e\" \"c e\" \"d e\"","rows":"","columns":""},{"areas":"\"a c d\" \"b c e\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a a\" \"b c e\" \"d d e\"","rows":"2fr 1fr 2fr","columns":"1fr 1fr 3fr"},{"areas":"\"a a b\" \"c e e\" \"d e e\"","rows":"","columns":""},{"areas":"\"a a b\" \"a a c\" \"e d c\"","rows":"","columns":""},{"areas":"\"a c c\" \"b c c\" \"d d e\"","rows":"1fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a e e\" \"b e e\" \"c c d\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a a\" \"b c e\" \"b d e\"","rows":"3fr 1fr 1fr","columns":"2fr 1fr 2fr"},{"areas":"\"a a b\" \"d c b\" \"d e e\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d c\" \"e e e\"","rows":"","columns":"3fr 5fr 3fr"},{"areas":"\"a c c\" \"a d e\" \"b d e\"","rows":"","columns":""},{"areas":"\"a c d\" \"b c e\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d e\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b\" \"c c\" \"d e\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\"","rows":"3fr 1fr","columns":""},{"areas":"\"a b c d e f\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f f f f f\"","rows":"1fr 2fr","columns":""},{"areas":"\"a b\" \"a c\" \"a d\" \"a e\" \"a f\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a f\" \"b f\" \"c f\" \"d f\" \"e f\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a a b b\" \"c d e f\"","rows":"2fr 1fr","columns":""},{"areas":"\"a b c d\" \"e e f f\"","rows":"1fr 2fr","columns":""},{"areas":"\"a c\" \"a d\" \"b e\" \"b f\"","rows":"","columns":"2fr 1fr"},{"areas":"\"a e\" \"b e\" \"c f\" \"d f\"","rows":"","columns":"1fr 2fr"},{"areas":"\"a b b\" \"c b b\" \"d e f\"","rows":"","columns":""},{"areas":"\"a a e\" \"a a f\" \"b c d\"","rows":"","columns":""},{"areas":"\"a b c\" \"d d e\" \"d d f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d f f\" \"e f f\"","rows":"","columns":""},{"areas":"\"a b c\" \"d b f\" \"d e f\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d f\" \"c e e f\"","rows":"4fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a e\" \"b c e\" \"b c f\" \"d d f\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b\" \"c d b\" \"c d e\" \"f f e\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a c\" \"b b c\" \"d e f\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d e\" \"f f f\"","rows":"1fr 1fr 4fr","columns":"4fr 1fr 1fr"},{"areas":"\"a a b c\" \"a a d d\" \"f e d d\"","rows":"","columns":""},{"areas":"\"a b b\" \"c d e\" \"c f f\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a a a a\" \"b b c c\" \"d e e f\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b\" \"c d b\" \"e f b\"","rows":"2fr 1fr 1fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b\" \"a a c\" \"f e d\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b c d e\" \"f f d e\"","rows":"2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b\" \"a a c\" \"d e e\" \"f e e\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a b c d e f g\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"","rows":"","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c c d\" \"e e f f g g\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a a a a a\" \"b c d e f g\"","rows":"3fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g g g g g g\"","rows":"1fr 3fr","columns":""},{"areas":"\"a a a\" \"b c d\" \"e f g\"","rows":"3fr 1fr 1fr","columns":""},{"areas":"\"a b c\" \"d e f\" \"g g g\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"b a e\" \"c a f\" \"d a g\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"b c d\" \"a a a\" \"e f g\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b\" \"c d b\" \"e f g\"","rows":"","columns":""},{"areas":"\"a b f\" \"c c g\" \"d e g\"","rows":"2fr 1fr 2fr","columns":"1fr 1fr 2fr"},{"areas":"\"a a b c\" \"d e f c\" \"g g g g\"","rows":"1fr 1fr 3fr","columns":""},{"areas":"\"a c c\" \"b c c\" \"d d e\" \"d d f\" \"g g g\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b b\" \"c d e\" \"c f g\"","rows":"2fr 1fr 1fr","columns":""},{"areas":"\"a b b c\" \"d b b e\" \"f f g g\"","rows":"","columns":""},{"areas":"\"a b b\" \"a c d\" \"a e e\" \"a f g\"","rows":"","columns":"2fr 1fr 1fr"},{"areas":"\"a b b\" \"c d e\" \"c f g\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a b c d e f g h\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"1fr 3fr","columns":""},{"areas":"\"a b c d\" \"e f g h\"","rows":"3fr 1fr","columns":""},{"areas":"\"a e\" \"b f\" \"c g\" \"d h\"","rows":"","columns":"3fr 1fr"},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\"","rows":"","columns":"1fr 3fr"},{"areas":"\"a c e g\" \"a d e h\" \"b d f h\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\" \"g h h\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a b b\" \"c d e f\" \"g g h h\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b b\" \"c c d d\" \"e f g h\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h h h h h h\"","rows":"1fr 2fr 1fr","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"1fr 2fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a d d\" \"b c d d\" \"e e f g\" \"e e h h\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d e\" \"c d f\" \"g g h\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b b\" \"a a c c\" \"d e c c\" \"d e f f\" \"h h f f\" \"h h g g\"","rows":"3fr 1fr 2fr 2fr 1fr 3fr","columns":""},{"areas":"\"a a a a\" \"b c d d\" \"e e f g\" \"h h h h\"","rows":"3fr 2fr 2fr 3fr","columns":""},{"areas":"\"a a b b\" \"c c b b\" \"d e h i\" \"f g h i\"","rows":"2fr 2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b b\" \"c d d e\" \"f f g g\" \"h h h h\"","rows":"1fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d d d\" \"e f g\" \"h h h\"","rows":"","columns":""},{"areas":"\"a d f\" \"b d g\" \"b e g\" \"c e h\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 2fr 1fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a d d\" \"b d d\" \"c e f\" \"c g h\"","rows":"","columns":""},{"areas":"\"a a a a\" \"b b b b\" \"c d f g\" \"c e f h\"","rows":"2fr 2fr 1fr 1fr","columns":""},{"areas":"\"a d f\" \"b d g\" \"b e g\" \"c e h\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c d e f g h i\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"","columns":"2fr 3fr 2fr"},{"areas":"\"a a b b\" \"c d d e\" \"f g h i\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a a a a\" \"b c c d\" \"e e f f\" \"g h h i\"","rows":"2fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c c\" \"d d e f\" \"g h i i\"","rows":"","columns":""},{"areas":"\"a a b d\" \"a a c d\" \"e f g d\" \"h h h i\"","rows":"1fr 1fr 1fr 3fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a b b c\" \"d d e e\" \"f g g h\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d b e\" \"f g h\" \"f i h\"","rows":"2fr 2fr 1fr 1fr","columns":"2fr 3fr 2fr"},{"areas":"\"a b b\" \"c b b\" \"d d e\" \"d d f\" \"g h h\" \"i h h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e e e\" \"f g h i\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h f\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b c\" \"d b e\" \"f b g\" \"h b i\"","rows":"","columns":"1fr 2fr 1fr"},{"areas":"\"a a b b\" \"c c d d\" \"e f f g\" \"h f f i\"","rows":"","columns":""},{"areas":"\"a b c\" \"d d e\" \"d d f\" \"g h i\"","rows":"","columns":"1fr 1fr 2fr"},{"areas":"\"a a a b\" \"a a a c\" \"d e e c\" \"f g i i\" \"f h i i\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"e f g h\" \"i i i i\"","rows":"1fr 1fr 2fr","columns":""},{"areas":"\"a b c\" \"a d e\" \"a f g\" \"a h i\"","rows":"","columns":"2fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g h i\"","rows":"2fr 1fr 1fr","columns":"2fr 1fr 1fr"},{"areas":"\"a a b d d\" \"a a c d d\" \"e f f f g\" \"h f f f i\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c f f g\" \"d f f h\" \"e f f i\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a d g\" \"b d h\" \"c e i\" \"c f i\"","rows":"3fr 1fr 1fr 3fr","columns":""},{"areas":"\"a d g\" \"b d h\" \"b e h\" \"c f i\"","rows":"1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c d e f g h i j\"","rows":"","columns":""},{"areas":"\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\"","rows":"","columns":""},{"areas":"\"a a a\" \"b c d\" \"e f g\" \"h i j\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j j j\"","rows":"1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c j\" \"d e f j\" \"g h i j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e f f\" \"g h i j\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a b b c\" \"d e e f\" \"g h i j\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e g\" \"d f g\" \"h i j\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b e f\" \"c d e f\" \"g h i i\" \"g h j j\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a b c e\" \"a b c f\" \"g g g j\" \"h h h j\" \"i i i j\"","rows":"","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"","rows":"","columns":""},{"areas":"\"a a b c\" \"d e b j\" \"f g i j\" \"h h i j\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a b b b\" \"c d e h\" \"c f g h\" \"i i i j\"","rows":"2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a a j\" \"b b b j\" \"c c c j\" \"d e f j\" \"g h i j\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a a b b b\" \"c d e f g h\" \"i i i j j j\"","rows":"3fr 1fr 2fr","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"a a a a d\" \"a a a a e\" \"j i h g f\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d d e\" \"f f f f\" \"g h h i\" \"j j k k\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a c d e\" \"a f g h\" \"b f g h\" \"b i j k\"","rows":"2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c d\" \"e f g d\" \"e f g k\" \"h i j k\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b k\" \"c d k\" \"e f k\" \"g h k\" \"i j k\"","rows":"","columns":""},{"areas":"\"a b c\" \"a d e\" \"a f g\" \"a h i\" \"a j k\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k k k k k\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f f f f\" \"g h i j k\"","rows":"","columns":""},{"areas":"\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"","rows":"","columns":"4fr 7fr 4fr"},{"areas":"\"a a b b b\" \"c d e f g\" \"h h h i i\" \"j j k k k\"","rows":"4fr 3fr 4fr 4fr","columns":""},{"areas":"\"a b c d e\" \"f f f f e\" \"f f f f g\" \"h i j k g\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k k\"","rows":"","columns":""},{"areas":"\"a a a b\" \"a a a c\" \"d e f g\" \"h i j k\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c d e e e\" \"f f f g h\" \"f f f i j\" \"k k k k k\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a a a a\" \"b c d k\" \"e f g k\" \"h i j k\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"","rows":"","columns":"1fr 3fr 1fr"},{"areas":"\"a b c d e\" \"f f f f f\" \"g h i j k\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a b b d\" \"a c c d\" \"e f g k\" \"e h h k\" \"e i j k\"","rows":"3fr 3fr 2fr 2fr 2fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"e f f g\" \"h i j k\"","rows":"","columns":""},{"areas":"\"a a b\" \"a a c\" \"a a d\" \"e h h\" \"f h h\" \"g h h\"","rows":"","columns":"1fr 3fr 1fr"},{"areas":"\"a a g i\" \"b c g j\" \"d e h j\" \"f f h k\"","rows":"2fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr"},{"areas":"\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i j j k\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b c c\" \"d e e e f\" \"g e e e h\" \"i i j k k\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"a a e e e\" \"f g e e e\" \"h h i i j\" \"h h i i k\"","rows":"1fr 2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"a a e f\" \"g h l l\" \"i j l l\" \"k k l l\"","rows":"","columns":""},{"areas":"\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k l\"","rows":"","columns":""},{"areas":"\"a a b\" \"c d d\" \"e e f\" \"g h h\" \"i i j\" \"k l l\"","rows":"","columns":"2fr 1fr 2fr"},{"areas":"\"a b c c\" \"d d e f\" \"g h i i\" \"j j k l\"","rows":"","columns":""},{"areas":"\"a b c c\" \"d b e f\" \"g h i j\" \"k k l l\"","rows":"","columns":""},{"areas":"\"a a a b\" \"a a a c\" \"d e f g\" \"h i j j\" \"k l j j\"","rows":"","columns":""},{"areas":"\"a c d f\" \"b c e f\" \"g h j k\" \"g i j l\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b b\" \"c d d e\" \"f f g g\" \"h i i j\" \"k k l l\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a c c d\" \"b c c d\" \"e f g h\" \"i j j k\" \"i j j l\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a a a b\" \"c d e l\" \"f g h l\" \"i j k l\"","rows":"3fr 1fr 1fr 1fr","columns":"1fr 1fr 1fr 3fr"},{"areas":"\"a b c d\" \"a e e d\" \"f g g h\" \"f i j h\"","rows":"1fr 2fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a a a a a a\" \"b c c d d e\" \"f f g g h h\" \"i j j k k l\"","rows":"3fr 1fr 1fr 1fr","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b c d\" \"e f f g g\" \"h f f g g\" \"h i i g g\" \"j k k l l\"","rows":"","columns":""},{"areas":"\"a b b c\" \"d e f g\" \"h i j g\" \"h k k m\" \"l k k m\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b b c\" \"d e f g\" \"d h i g\" \"j k k l\"","rows":"","columns":""},{"areas":"\"a a b d\" \"a a c d\" \"e f h h\" \"e g h h\" \"i i j l\" \"i i k l\"","rows":"","columns":"2fr 1fr 1fr 2fr"},{"areas":"\"a b c d\" \"l l l e\" \"l l l f\" \"l l l g\" \"k j i h\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e c f\" \"e e c g\" \"h i l l\" \"h j l l\" \"h k l l\"","rows":"","columns":""},{"areas":"\"a a a b b\" \"a a a c d\" \"a a a e f\" \"g h i l l\" \"g j k l l\"","rows":"2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 1fr 1fr"},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g g g g g g\" \"h i j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m m m m m m\"","rows":"","columns":""},{"areas":"\"a b h\" \"a c i\" \"a d j\" \"a e k\" \"a f l\" \"a g m\"","rows":"","columns":""},{"areas":"\"a g h\" \"b g i\" \"c g j\" \"d g k\" \"e g l\" \"f g m\"","rows":"","columns":""},{"areas":"\"a b m\" \"c d m\" \"e f m\" \"g h m\" \"i j m\" \"k l m\"","rows":"","columns":""},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"","rows":"3fr 1fr 1fr","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a b c\" \"d e f\" \"g g g\" \"h i j\" \"k l m\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e e f f\" \"g g g g\" \"h h i i\" \"j k l m\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i j k l m\"","rows":"1fr 3fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f f g h h\" \"i j k l m\"","rows":"1fr 2fr 1fr","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i i j k\" \"i i i l m\"","rows":"","columns":""},{"areas":"\"a a a l\" \"b b b l\" \"c d e l\" \"f g h m\" \"i j k m\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a b c d d\" \"e f c d d\" \"g g h i j\" \"g g h k l\" \"m m m m m\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"","rows":"1fr 2fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"","rows":"","columns":""},{"areas":"\"a a b c\" \"d e f g\" \"h i j j\" \"k k l m\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f f g\" \"h f f g\" \"i j j j\" \"k l l m\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a d f i k\" \"b d g i l\" \"b e g j l\" \"c e h j m\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c d\" \"a a a b e f\" \"a a a m m m\" \"g h i m m m\" \"g j k m m m\" \"l l l m m m\"","rows":"1fr 1fr 2fr 1fr 1fr 2fr","columns":"2fr 1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d e f g\" \"h i j k l m n\"","rows":"","columns":""},{"areas":"\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\" \"m n\"","rows":"","columns":""},{"areas":"\"a a b c\" \"a a d e\" \"a a f g\" \"h i n n\" \"j k n n\" \"l m n n\"","rows":"","columns":""},{"areas":"\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"","rows":"3fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h h i i j j\" \"k l l m m n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b b c c\" \"d e e f f g\" \"h i i j j k\" \"l l m m n n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a a b c c d\" \"e e e f f f\" \"g h h i j j\" \"k k l m m n\"","rows":"","columns":"3fr 1fr 3fr 3fr 1fr 3fr"},{"areas":"\"a b c d\" \"e e f f\" \"g h i j\" \"k l m n\"","rows":"1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b c d\" \"a a e f g\" \"h i j k k\" \"l m n k k\"","rows":"","columns":""},{"areas":"\"a b g g\" \"c d g g\" \"e f h i\" \"j j k l\" \"j j m n\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e e c d d\" \"e e f f g\" \"h i k l l\" \"j j k l l\" \"j j k m n\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a c c d f f\" \"b c c e f f\" \"g g g g g g\" \"h h i k k l\" \"h h j k k m\" \"n n n n n n\"","rows":"1fr 1fr 2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c\" \"a a a d e\" \"a a a f g\" \"h i n n n\" \"j k n n n\" \"l m n n n\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c c d e\" \"f f f g g g\" \"h i j j k l\" \"m m m n n n\"","rows":"3fr 2fr 3fr 2fr","columns":"2fr 2fr 1fr 1fr 2fr 2fr"},{"areas":"\"a a b b c c\" \"d e b b j k\" \"f g i i l m\" \"h h i i n n\"","rows":"2fr 1fr 1fr 2fr","columns":""},{"areas":"\"a b c c d d\" \"e e f g d d\" \"h h h h h h\" \"i j k l m n\"","rows":"1fr 1fr 2fr 1fr","columns":""},{"areas":"\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g i\" \"h g g g i\" \"h g g g j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f g h h\" \"i i g j j\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i j k l\" \"i i m n o\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e c c\" \"f g h c c\" \"i j k k l\" \"m j n o o\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"a a a d d\" \"e f g g h\" \"i j j k l\" \"m j j n o\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f f f g\" \"h f f f i\" \"j k k l l\" \"m m n n o\"","rows":"","columns":""},{"areas":"\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n n o\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d d\" \"e f g d d\" \"h i j d d\" \"k l m n o\"","rows":"","columns":""},{"areas":"\"a b i i i\" \"c d i i i\" \"e f i i i\" \"g h j j k\" \"l l m n o\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"a e f g h\" \"i e f g j\" \"k e f g l\" \"m m n o l\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"d i i i h\" \"d j k l h\" \"m n n n o\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f g g d\" \"e f h i j\" \"k l l i j\" \"k m n n o\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o o\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f f f f g\" \"h f f f f i\" \"j f f f f k\" \"l m m n n o\"","rows":"1fr 1fr 1fr 2fr 1fr","columns":""},{"areas":"\"a b c d e\" \"n o o o f\" \"m o o o g\" \"l k j i h\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"a a a d e\" \"f g j j j\" \"h i j j j\" \"k k k l m\" \"k k k n o\"","rows":"","columns":"1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a b c d e f\" \"g m m m m j\" \"h m m m m k\" \"i m m m m l\" \"n n n o o o\"","rows":"1fr 1fr 1fr 1fr 2fr","columns":""},{"areas":"\"a a a b c c\" \"a a a d d d\" \"e f g d d d\" \"e h i d d d\" \"j k k k l m\" \"j k k k n o\"","rows":"2fr 2fr 1fr 1fr 1fr 1fr","columns":"2fr 1fr 1fr 2fr 1fr 1fr"},{"areas":"\"a a b b c\" \"a a d e h\" \"a a f g h\" \"i j m m h\" \"k l m m h\" \"n n m m o\"","rows":"2fr 1fr 1fr 1fr 1fr 2fr","columns":"1fr 1fr 1fr 1fr 4fr"},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\"","rows":"","columns":""},{"areas":"\"a i\" \"b j\" \"c k\" \"d l\" \"e m\" \"f n\" \"g o\" \"h p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"g h i j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k k l m m\" \"n n o p p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f f g i k\" \"f f h j k\" \"l m n o p\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c c d\" \"e f c c g\" \"h h i j k\" \"h h l m m\" \"n n o p p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\" \"a n o p\"","rows":"","columns":"2fr 1fr 1fr 1fr"},{"areas":"\"a a a b c\" \"d e f g h\" \"i j k k k\" \"l m n o p\"","rows":"","columns":""},{"areas":"\"a a b c d\" \"e f g h h\" \"i i j k l\" \"m n o p p\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g d\" \"h i j d\" \"k l m d\" \"n o p d\"","rows":"","columns":"1fr 1fr 1fr 2fr"},{"areas":"\"a a b b c d\" \"a a b b e f\" \"a a g h k k\" \"a a i j k k\" \"l m p p p p\" \"n o p p p p\"","rows":"1fr 1fr 1fr 1fr 2fr 2fr","columns":"2fr 2fr 1fr 1fr 1fr 1fr"},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o p\"","rows":"","columns":""},{"areas":"\"a a a a b c\" \"a a a a d e\" \"f j j m o o\" \"g j j n o o\" \"h j j p p p\" \"i k l p p p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k g g g l\" \"m n o p q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"j f g h k\" \"l f g h m\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f f f g\" \"h i i i j\" \"k l l l m\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q q\"","rows":"","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"e j g k i\" \"e l g m i\" \"n n o p q\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"a b f d e\" \"g h i j k\" \"l m n o p\" \"l m q o p\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"f g k i j\" \"l m n o p\" \"l m q o p\"","rows":"","columns":""},{"areas":"\"a a b b c\" \"d e f g c\" \"d h i j k\" \"l m n o k\" \"l p p q q\"","rows":"","columns":""},{"areas":"\"a b b c d\" \"e f g h d\" \"e f i j k\" \"l m n j k\" \"l o p p q\"","rows":"","columns":""},{"areas":"\"a b b c c\" \"d d e e f\" \"g h i j k\" \"l m m n n\" \"o o p p q\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i f g j\" \"k l l m\" \"n o p q\"","rows":"1fr 1fr 1fr 2fr 1fr","columns":"1fr 2fr 2fr 1fr"},{"areas":"\"a b c d e\" \"f g g h h\" \"i g g l l\" \"j k k l l\" \"m n o p q\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k l m n\" \"j o p q r\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i i j\" \"k l m n o\" \"p p q r r\"","rows":"","columns":""},{"areas":"\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q r\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"a g h i j f\" \"a k l m n f\" \"a o p q r f\"","rows":"","columns":""},{"areas":"\"a b c c c c\" \"d e c c c c\" \"f g c c c c\" \"h i c c c c\" \"j k l m n o\" \"p p q q r r\"","rows":"","columns":""},{"areas":"\"a a b b c c\" \"d d e e f f\" \"g h i j k l\" \"m n o p q r\"","rows":"2fr 2fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g g h h i i\" \"j k l m n o\" \"p p q q r r\"","rows":"","columns":""},{"areas":"\"a b c c d d\" \"e f c c d d\" \"g g h i j j\" \"g g k l j j\" \"m m n n o p\" \"m m n n q r\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f g g h h\" \"i i j k l l\" \"m m n o p p\" \"q q q r r r\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k g h i l\" \"m g h i n\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g g g j\" \"k h h h l\" \"m i i i n\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r r r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k k k e\" \"j l m n o\" \"j p q r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"f k k k j\" \"f l m n j\" \"o p q r s\"","rows":"","columns":""},{"areas":"\"a a a b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r s s s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i e\" \"j k h l e\" \"j m h n o\" \"j p q r s\"","rows":"","columns":""},{"areas":"\"a b b b c\" \"d e f g h\" \"i j f k l\" \"m n f o p\" \"q r r r s\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h d i\" \"j k h d l\" \"m k h n o\" \"p k q r s\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\"","rows":"","columns":""},{"areas":"\"a k\" \"b l\" \"c m\" \"d n\" \"e o\" \"f p\" \"g q\" \"h r\" \"i s\" \"j t\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j j j j j j j j j\" \"k l m n o p q r s\" \"t t t t t t t t t\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j j j j j j j j j\" \"k k k k k k k k k\" \"l m n o p q r s t\"","rows":"","columns":""},{"areas":"\"a b c d\" \"a e c d\" \"f g h i\" \"f g j i\" \"k l m n\" \"o l m n\" \"p q r s\" \"p q r t\"","rows":"","columns":""},{"areas":"\"a a a a a\" \"b c c c c\" \"b d e f g\" \"b h i j g\" \"k l m n g\" \"o o p q r\" \"o o s s s\" \"t t t t t\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"d e f g h\" \"i i i j k\" \"l m n n o\" \"p q r s t\"","rows":"1fr 3fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a a a a\" \"b c d e f\" \"b g g h i\" \"b g g j i\" \"k l m n i\" \"o o p p p\" \"o o q r s\" \"t t t t t\"","rows":"","columns":""},{"areas":"\"a b c j j j\" \"d e f j j j\" \"g h i j j j\" \"k k k l m n\" \"k k k o p q\" \"k k k r s t\"","rows":"","columns":""},{"areas":"\"a a a b c d\" \"a a a e f g\" \"a a a h i j\" \"k l m t t t\" \"n o p t t t\" \"q r s t t t\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"a a a a h\" \"d e f g h\" \"i i j k l\" \"m n o p q\" \"r s t t t\"","rows":"1fr 1fr 2fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e f f g g h\" \"i j j k k l\" \"m m n n o o\" \"p p q q r r\" \"s s t t u u\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b c d d\" \"e f g h h\" \"i j k l m\" \"n n o p q\" \"r r s t u\"","rows":"","columns":""},{"areas":"\"a b c c d d e f\" \"g g g h i j k k\" \"l l m n n o o o\" \"p q q r s t u u\"","rows":"","columns":""},{"areas":"\"a a b c d e e\" \"f f f g g g h\" \"i j k l m m n\" \"o o o p q q q\" \"r r s s t u u\"","rows":"","columns":""},{"areas":"\"a a a a b c c d\" \"a a a a e e f g\" \"h i j k l l l m\" \"n n n o l l l p\" \"q q r r s t t u\"","rows":"","columns":""},{"areas":"\"a a b b c c d d\" \"e e f f f f g h\" \"i j f f f f k l\" \"m m m n o o o p\" \"q q r r s t t u\"","rows":"","columns":""},{"areas":"\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\" \"o p p q q r\" \"s s t t u u\"","rows":"","columns":"3fr 1fr 2fr 2fr 1fr 3fr"},{"areas":"\"a b b c d\" \"e b b f g\" \"h i j j k\" \"l m j j n\" \"o p p q r\" \"s p p t u\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r u u u u i\" \"q u u u u j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a b c\" \"a a d e\" \"f g h h\" \"i i j k\" \"l m n o\" \"p p q r\" \"s s t t\" \"s s u u\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j k\" \"l m n o p q r s t u v\"","rows":"","columns":""},{"areas":"\"a l\" \"b m\" \"c n\" \"d o\" \"e p\" \"f q\" \"g r\" \"h s\" \"i t\" \"j u\" \"k v\"","rows":"","columns":""},{"areas":"\"a a a a a a a\" \"b c d e f g h\" \"i j k l m n o\" \"p q r s t u v\"","rows":"2fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d d\" \"e f g h i\" \"j j k l l\" \"m n o p q\" \"r r s t u\"","rows":"","columns":""},{"areas":"\"a a b c d e\" \"f g h i j k\" \"l m n o p q\" \"r s t u v v\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s p\" \"t r r u v\"","rows":"","columns":""},{"areas":"\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l m m n n\" \"o m m n n\" \"p q r r s\" \"t u r r v\"","rows":"","columns":""},{"areas":"\"a b c d e k k k k k\" \"f g h i j k k k k k\" \"l l l l l m n o p q\" \"l l l l l r s t u v\"","rows":"","columns":""},{"areas":"\"a b c d e k\" \"f g h i j k\" \"l m n o p v\" \"q r s t u v\"","rows":"","columns":"1fr 1fr 1fr 1fr 1fr 5fr"},{"areas":"\"a b c c d d e f\" \"g g g h i j k k\" \"l m n o o p p p\" \"q r r s t u v v\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r v v v v i\" \"q v v v v j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r u u v v i\" \"q u u v v j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n v v v v\" \"l l o p v v v v\" \"q r u u v v v v\" \"s t u u v v v v\"","rows":"","columns":""},{"areas":"\"a a a b b b\" \"a a a b b b\" \"c d g g h i\" \"e f g g j k\" \"l l l m m m\" \"n o r r s t\" \"p q r r u v\"","rows":"1fr 1fr 1fr 1fr 2fr 1fr 1fr","columns":"1fr 1fr 2fr 2fr 1fr 1fr"},{"areas":"\"a b e f g g\" \"a c e f g g\" \"d d e f h i\" \"d d e f h j\" \"k k k q q q\" \"l m o q q q\" \"l n o q q q\" \"p p o q q q\"","rows":"1fr 1fr 1fr 1fr 4fr 1fr 1fr 2fr","columns":"1fr 1fr 2fr 2fr 1fr 1fr"},{"areas":"\"a a a a b b b b\" \"c d e f f g h i\" \"j k l m m n o p\" \"q r s t t u v w\"","rows":"2fr 1fr 1fr 1fr","columns":"2fr 2fr 2fr 1fr 1fr 2fr 2fr 2fr"},{"areas":"\"a b c d e f g\" \"h h h h h h h\" \"i j k l m n o\" \"p p p p p p p\" \"q r s t u v w\"","rows":"","columns":""},{"areas":"\"a a a a b\" \"a a a a c\" \"d e f f c\" \"g h i j k\" \"l l l m n\" \"o p q q r\" \"s t u v w\"","rows":"1fr 2fr 1fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l l m n n\" \"o o p n n\" \"q r s s v\" \"t u s s w\"","rows":"","columns":""},{"areas":"\"a a a a b b b c c c c\" \"d d e e e f g g g h h\" \"i j j k k l m m n n o\" \"p p q q q r s s s t t\" \"u u u u v v v w w w w\"","rows":"","columns":"2fr 1fr 1fr 1fr 1fr 3fr 1fr 1fr 1fr 1fr 2fr"},{"areas":"\"a c c d d\" \"b c c d d\" \"e f g g h\" \"i j g g k\" \"i l l n o\" \"m l l p q\" \"r s t t u\" \"v v t t w\"","rows":"","columns":""},{"areas":"\"a b e e f h h\" \"c d e e g h h\" \"i k k l n h h\" \"j k k m o h h\" \"p p q s u u v\" \"p p r t u u w\"","rows":"","columns":""},{"areas":"\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s t\" \"u r r v w\"","rows":"","columns":""},{"areas":"\"a b b b c d\" \"e b b b f g\" \"h i j k k l\" \"m n n o p q\" \"r s t u v w\"","rows":"","columns":""},{"areas":"\"a b b b c d\" \"e b b b f g\" \"h h i j j g\" \"l m m j j k\" \"n n o p q r\" \"s t u v w w\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w w w i\" \"q w w w w j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i i j k\" \"l l l l l l\" \"m n o o p q\" \"r s t u v w\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\"","rows":"","columns":""},{"areas":"\"a a b c c c\" \"d e f c c c\" \"g g g h i j\" \"g g g k l m\" \"n o p q q r\" \"s u u v x x\" \"t u u w x x\"","rows":"","columns":""},{"areas":"\"a b c d d e\" \"f g h d d i\" \"j k k k k l\" \"m k k k k r\" \"m n o p q r\" \"s s t v v w\" \"s s u v v x\"","rows":"","columns":""},{"areas":"\"a b e e f\" \"c d e e g\" \"h h h h i\" \"h h h h j\" \"k l m n n\" \"o o p n n\" \"o o r s t\" \"u v w w x\"","rows":"","columns":""},{"areas":"\"a c c d d e\" \"b c c d d f\" \"g g h i j j\" \"g g k l j j\" \"m m n n o o\" \"p p n n q q\" \"p p r s q q\" \"t u v v w x\"","rows":"","columns":""},{"areas":"\"a b e e e e\" \"c b e e e e\" \"d d e e e e\" \"f g i i j k\" \"h h i i l k\" \"m n o p q q\" \"r t t u q q\" \"s t t v w x\"","rows":"","columns":""},{"areas":"\"a a a a b c\" \"a a a a d d\" \"e f g h i j\" \"k k k l m n\" \"o p q q r r\" \"s t u v w x\"","rows":"1fr 3fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w x x i\" \"q w w x x j\" \"p o n m l k\"","rows":"","columns":""},{"areas":"\"a a b d e f\" \"a a c g g h\" \"k l m g g i\" \"n o o t u j\" \"p o o v x x\" \"q r s w x x\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\"","rows":"","columns":""},{"areas":"\"a b c d y\" \"e f g h y\" \"i j k l y\" \"m n o p y\" \"q r s t y\" \"u v w x y\"","rows":"","columns":"1fr 1fr 1fr 1fr 4fr"},{"areas":"\"a a a a a a\" \"b c d e f g\" \"h i j k l m\" \"n o p q r s\" \"t u v w x y\"","rows":"4fr 1fr 1fr 1fr 1fr","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y y y y y y\"","rows":"1fr 1fr 1fr 1fr 4fr","columns":""},{"areas":"\"a b c d e\" \"a f g h i\" \"a j k l m\" \"a n o p q\" \"a r s t u\" \"a v w x y\"","rows":"","columns":"4fr 1fr 1fr 1fr 1fr"},{"areas":"\"a b c d e f g\" \"h h h i i i i\" \"j k l m n o p\" \"q q q q r r r\" \"s t u v w x y\"","rows":"","columns":""},{"areas":"\"a h j q s\" \"b h k q t\" \"c h l q u\" \"d i m q v\" \"e i n r w\" \"f i o r x\" \"g i p r y\"","rows":"","columns":""},{"areas":"\"a b c c d e\" \"f g c c h i\" \"j k k l l m\" \"o k k l l n\" \"o p q r s n\" \"t u u w w x\" \"v u u w w y\"","rows":"","columns":""},{"areas":"\"a b m n o\" \"c d m p q\" \"e f m r s\" \"g h m t u\" \"i j m v w\" \"k l m x y\"","rows":"","columns":"1fr 1fr 3fr 1fr 1fr"},{"areas":"\"a b c d d d\" \"e f g d d d\" \"h h h i j k\" \"h h h l m n\" \"o p q r r s\" \"t v v w y y\" \"u v v x y y\"","rows":"","columns":""},{"areas":"\"a a a a b b c c c d d\" \"e e f f g h h i i j j\" \"k l l m n n o o o o o\" \"p p q q q q r r s s t\" \"u v v w x x y y y y y\"","rows":"","columns":"2fr 1fr 1fr 2fr 2fr 1fr 1fr 1fr 1fr 1fr 2fr"},{"areas":"\"a b c d e f\" \"g h i i j k\" \"l l m m n n\" \"o p q q r s\" \"t u v w x y\"","rows":"1fr 1fr 2fr 1fr 1fr","columns":""},{"areas":"\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n q q r r\" \"l l o p q q r r\" \"s t w w x x y y\" \"u v w w x x y y\"","rows":"","columns":""},{"areas":"\"a a b d f f\" \"a a c e g g\" \"h i j j k l\" \"m n o p q r\" \"s s t u v v\" \"w w x y v v\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k k\" \"l m n o\" \"p q r s\" \"t t u v\" \"w w x x\" \"w w y y\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\" \"ab ac ad\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\" \"ak al am an\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\"","rows":"","columns":""},{"areas":"\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\" \"at au av aw ax\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\"","rows":"","columns":""},{"areas":"\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\" \"bc bd be bf bg bh\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\"","rows":"","columns":""},{"areas":"\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\" \"cd ce cf cg ch ci cj ck cl\"","rows":"","columns":""},{"areas":"\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\" \"cm cn co cp cq cr cs ct cu cv\"","rows":"","columns":""}];
var outlineFonts = {};
var nbdApp;
var dependModules = ["angularSpectrumColorpicker"];
if( !!NBDESIGNCONFIG['enable_live_chat'] && NBDESIGNCONFIG['ui_mode'] == 2 ){
    dependModules.push( "nbdChatApp" );
}
if( NBDESIGNCONFIG['ui_mode'] != 3 ){
    nbdApp = angular.module('nbd-app', dependModules);
}else{
    nbdApp = angular.module('nbdApp', dependModules);
};
nbdApp.constant("_", window._);
nbdApp.config(function( $controllerProvider, $compileProvider, $filterProvider ){
    nbdApp.controller = function( name, constructor ) {
        $controllerProvider.register( name, constructor );
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\//);
        return( this );
    };
    nbdApp.directive = function( name, factory ) {
        $compileProvider.directive( name, factory );
        return( this );
    };
    nbdApp.filter = function( name, filter ) {
        $filterProvider.register( name, filter );
        return( this );
    };
});
nbdApp.config([
    '$compileProvider', function( $compileProvider ){
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\/|data:img\//);
    }
]);
nbdApp.controller('designCtrl', ['$scope', 'FabricWindow', '$window', 'NBDDataFactory', 'filterFontFilter', 'filterArtFilter', '$timeout', '$http', '$document', '$interval',
    function($scope, FabricWindow, $window, NBDDataFactory, filterFontFilter, filterArtFilter, $timeout, $http, $document, $interval){
    $scope.stages = [];
    var d = new Date(),
    t = d.getTime();
    $scope.defaultStageStates = {
        isActiveLayer: false,
        isLayer: false,
        isGroup: false,
        isNativeGroup: false,
        isText: false,
        isImage: false,
        isPath: false,
        isShape: false,
        isEditing: false,
        isRedoable: false,
        isUndoable: false,
        elementUpload: false,
        isShowToolBox: false,
        enableRotate: true,
        enableOpacity: true,
        enableShadow: NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ? true :false,
        enableChangePathColor: true,
        oos: false,
        ilr: false,
        boundingObject: {},
        corners: [],
        boundingRealSize: {},
        coordinates: { lastCheck: t },
        rotate: {},
        uploadZone: {},
        opacity: 100,
        snaplines: {},
        itemId: null,
        tempParameters: null,
        usedFonts: [],
        type: null,
        text: {
            fontFamily: {
                alias: NBDESIGNCONFIG.default_font.alias,
                r: NBDESIGNCONFIG.default_font.file.r,
                b: NBDESIGNCONFIG.default_font.file.b,
                i: NBDESIGNCONFIG.default_font.file.i,
                bi: NBDESIGNCONFIG.default_font.file.bi
            },
            fontSize: 14,
            fontFamily: NBDESIGNCONFIG.default_font.alias,
            textAlign: 'left',
            fontWeight: false,
            textDecoration: false,
            fontStyle: '',
            spacing: 0,
            lineHeight: 1.16,
            is_uppercase: false,
            fill: '#06d79c'
        }, 
        svg: {groupPath: {}, currentPath: null},
        image: {},
        scaleRange: [],
        currentScaleIndex: 0,
        fitScaleIndex: 0,
        fillScaleIndex: 0,
        lostCharLayers: [],
        shadow: {
            color: NBDESIGNCONFIG.nbdesigner_default_color,
            offsetX: 0,
            offsetY: 0,
            blur: 10,
            opacity: 0.75
        }
    };
    $scope.defaultConfig = {
        name: 'Typography',
        width: 200,
        height: 200,
        cheight: 200,
        cwidth: 200,
        left: 0,
        top: 0,
        bleed_lr: 0,
        bleed_tb: 0,
        margin_lr: 0,
        margin_tb: 0,
        bgType: 'tran',
        bgColor: '#ffffff',
        bgImage: 0,
        showBleed: 0,
        showOverlay: 0,
        showSafeZone: 0
    };
    $scope.initSettings = function(){
        $scope.debugMode = appConfig.debugMode;
        $scope.the_first_time_load_page = true;
        $scope.printingOptionsAvailable = NBDESIGNCONFIG.show_nbo_option == '1' ? false : true;
        angular.copy(NBDESIGNCONFIG, $scope.settings);
        angular.extend($scope.settings, {
            showRuler: checkMobileDevice() ? false : (NBDESIGNCONFIG.nbdesigner_show_ruler == 'yes' ? true : false),
            showGrid: NBDESIGNCONFIG.nbdesigner_show_grid == 'yes' ? true : false,
            showDimensions: NBDESIGNCONFIG.nbdesigner_show_product_dimensions == 'yes' ? true : false,
            bleedLine: NBDESIGNCONFIG.nbdesigner_show_bleed == 'yes' ? true : false,
            snapMode: {status: false, type: 'layer'},
            showWarning: {
                oos: NBDESIGNCONFIG.nbdesigner_show_warning_oos == 'yes' ? true : false,
                ilr: NBDESIGNCONFIG.nbdesigner_show_warning_ilr == 'yes' ? true : false
            }
        });
        $scope.offsetDesignWrap = NBDESIGNCONFIG.nbdesigner_show_design_border == 'yes' ? -1 : 0;
        $scope.rateConvertCm2Px96dpi = 37.795275591;
        $scope.currentStage = 0;
        $scope.showTextColorPicker = false;
        $scope.showBgColorPicker = false;
        $scope.__colorPalette = __colorPalette;
        $scope.currentColor = NBDESIGNCONFIG.nbdesigner_default_color;
        $scope.listBackgroundColor = [];
        $scope.dataCopy = null;
        $scope.copyLayersSelect = function(){
            $scope.dataCopy = null;
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            $scope.dataCopy = _canvas.getActiveObject();
        };
        $scope.pasteDataCopy = function(){
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            var activeObject = $scope.dataCopy;
            activeObject.clone(function(cloned) {
                    var _clipboard = cloned;
                    function _clone(__clipboard, mask){
                        $timeout(function(){
                            __clipboard.clone(function(clonedObj) {
                                _canvas.discardActiveObject();
                                clonedObj.set({
                                    left: clonedObj.left + 10,
                                    top: clonedObj.top + 10,
                                    evented: true
                                });
                                if (clonedObj.type === 'activeSelection') {
                                    clonedObj.canvas = _canvas;
                                    clonedObj.forEachObject(function(obj) {
                                        $scope.contextAddLayers = 'copy';
                                        _canvas.add(obj);
                                    });
                                    clonedObj.setCoords();
                                } else {
                                    $scope.contextAddLayers = 'copy';
                                    _canvas.add(clonedObj);
                                    if( angular.isDefined( mask ) ){
                                        clonedObj.set({
                                            clipPath: mask, 
                                            maskId: mask.get('itemId'),
                                            centeredScaling: true
                                        });
                                        $scope.updateMaskLayer();
                                    }
                                }
                                _canvas.setActiveObject(clonedObj);
                                _canvas.requestRenderAll();            
                            });
                        }, 10);
                    }
                    if( cloned.type != 'activeSelection' && !!activeObject.get('maskId') ){
                        var maskLayer = $scope.getMaskLayer( activeObject.get('maskId') );
                        if( maskLayer ){
                            maskLayer.clone(function(cloned) {
                                var _maskClipboard = cloned;
                                $timeout(function(){
                                    _clone( _maskClipboard );
                                    $timeout(function(){
                                        var mask = _canvas.item( _canvas.getObjects().length - 1 );
                                        mask.set({
                                            isMask: 1,
                                            absolutePositioned: true,
                                            selectable: false
                                        });
                                        _clone( _clipboard, mask );
                                    }, 10);
                                }, 10);
                            });
                        }else{
                            _clone( _clipboard );
                        }
                    }else{
                        _clone( _clipboard );
                    }
            }); 
        };
        $scope.listAddedColor = [];
        $scope.tempStageDesign = null;
        $scope.areaDesignClipPaths = [];
        $scope.areaDesignZoomedClipPaths = [];
        $scope.areaDesignShapes = [];
        $scope.listFontSizeInPt = ['6','8','10','12','14','16','18','21','24','28','32','36','42','48','56','64','72','80','88','96','104','120','144','288','576','1152'];
        if( angular.isDefined( NBDESIGNCONFIG.nbdesigner_default_font_sizes ) && NBDESIGNCONFIG.nbdesigner_default_font_sizes != '' ){
            var fontSizes = NBDESIGNCONFIG.nbdesigner_default_font_sizes.replace(/ /g, '');
            $scope.listFontSizeInPt = fontSizes.split(',');
        }
        if( angular.isDefined( NBDESIGNCONFIG.nbdesigner_min_font_size ) && NBDESIGNCONFIG.nbdesigner_min_font_size != '' ){
            var min = NBDESIGNCONFIG.nbdesigner_min_font_size * 1;
            $scope.listFontSizeInPt = $scope.listFontSizeInPt.filter(function( size ){
                var size = size * 1;
                return size >= min;
            });
        }
        if( angular.isDefined( NBDESIGNCONFIG.nbdesigner_max_font_size ) && NBDESIGNCONFIG.nbdesigner_max_font_size != '' ){
            var max = NBDESIGNCONFIG.nbdesigner_max_font_size * 1;
            $scope.listFontSizeInPt = $scope.listFontSizeInPt.filter(function( size ){
                var size = size * 1;
                return size <= max;
            });
        }
        $scope.forceMinSize = ( NBDESIGNCONFIG.nbdesigner_force_min_font_size == 'yes' ) ? true : false;
        $scope.forceMaxSize = ( NBDESIGNCONFIG.nbdesigner_force_max_font_size == 'yes' ) ? true : false;
        $scope.customTemplate = {
            name: '',
            type: '1',
            selectedTags: [],
            selectedColors: [],
            newColor: '#ffffff',
            showPicker: false,
            tags: [],
            tag_ids: [],
            reload: 0,
            template_thumb: null
        };
        if( NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template' ){
            if( angular.isDefined( NBDESIGNCONFIG.product_data.template ) ){
                $scope.customTemplate.name = NBDESIGNCONFIG.product_data.template.name;
                $scope.customTemplate.selectedTags = NBDESIGNCONFIG.product_data.template.tags.split(",").map(function( tag ){
                    return parseInt( tag );
                });
                if( NBDESIGNCONFIG.product_data.template.colors != '' ){
                    $scope.customTemplate.selectedColors = NBDESIGNCONFIG.product_data.template.colors.split(",");
                }
            }
        }
        if( angular.isDefined(NBDESIGNCONFIG.product_data.option.listFontSizeInPt) ){
            if( NBDESIGNCONFIG.product_data.option.listFontSizeInPt != '' ){
                NBDESIGNCONFIG.product_data.option.listFontSizeInPt = NBDESIGNCONFIG.product_data.option.listFontSizeInPt.replace(/ /g, '');
                $scope.listFontSizeInPt = NBDESIGNCONFIG.product_data.option.listFontSizeInPt.split(',');
            }
        };
        if( angular.isDefined( NBDESIGNCONFIG.product_data.config ) && angular.isDefined( NBDESIGNCONFIG.product_data.config.dpi ) && angular.isDefined( NBDESIGNCONFIG.product_data.config.option_dpi ) ){
            $scope.settings.product_data.option.dpi = NBDESIGNCONFIG.product_data.config.dpi;
        }
        if( angular.isDefined(NBDESIGNCONFIG.product_data.config ) && angular.isDefined( NBDESIGNCONFIG.product_data.config.origin_product ) ){
            $scope.settings.product_data.origin_product = NBDESIGNCONFIG.product_data.config.origin_product;
        };
        if( angular.isDefined(NBDESIGNCONFIG.product_data.config ) && angular.isDefined(NBDESIGNCONFIG.product_data.config.areaDesignShapes) ){
            $scope.areaDesignShapes = NBDESIGNCONFIG.product_data.config.areaDesignShapes;
        }
        $scope.completedInsertTemplate = false;
        jQuery(document).triggerHandler( 'nbd_init_settings' );
        $scope.changePrintingOptions( true );
        $scope.processProductSettings();
        $scope.resource = {
            defaultPalette: [
                ['#ff5c5c', '#ffbd4a', '#fff952', '#99e265', '#35b729', '#44d9e6', '#2eb2ff', '#5271ff', '#b760e6', '#ff63b1'],
                ['#000000', '#666666', '#a8a8a8', '#d9d9d9', '#ffffff']
            ],
            social: {link: '', wa_link: '', type: '', images: [], design_link: ''},
            config: {},
            jsonDesign: {},
            usedFonts: [],
            imageFromUrl: '',
            svgCode: '',
            qrText: '',
            gapi: {},
            tempData: {template: []},
            templates: [],
            templateLimit: 24,
            myTemplates: [],
            myDesigns: [],
            cartTemplates: [],
            templateCats: [],
            templateSearch: {value: '', loading: false, focus: false},
            drawMode: {status: false, brushWidth: 1, brushType: 'Pencil', brushColor: NBDESIGNCONFIG.nbdesigner_default_color},
            personal: {status: false, type: ''},
            webcam: {status: false},
            typography: {filter: {perPage: 20, currentPage: 1, total: 0}, data: [], init: true, onload: false},
            photoFrame: {filter: {perPage: 20, currentPage: 0, total: 161}, data: [], init: true, onload: false},
            clipart: {filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}}, data: [], onload: false, init: true, filteredArts : []},
            font: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], filteredFonts : []},
            photo: {filter: {perPage: 20, currentPage: 1, total: 0, totalPage: 1}, data: [], init: true, onload: false, type: '', photoSearch: '', onclick: false},
            dropbox: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, filteredPhoto : []},
            facebook: {filter: {perPage: 20, currentPage: 1, total: 0}, data: [], onload: false, init: true, nextUrl: '', uid: '', accessToken: ''},
            instagram: {filter: {perPage: 24, currentPage: 1, total: 0}, data: [], onload: false, init: true, token : '', code: '', uid: ''},
            upload: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, ilr: false, progressBar: 0},
            element: {onclick: false, onload: false, contentSearch: ''},
            shape: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
            icon: {filter: {perPage: 20, currentPage: 1, totalPage: 0, currentCat: null}, data: [], cat: [], init: true, onload: false, first: true},
            flaticon: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false, token: '', expires: ''},
            storyset: {filter: {perPage: 30, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
            line: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
            globalTemplate: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
            templateType: 'custom',
            mockups: [],
            canAdd: true,
            frames: photoFrames.slice(0, 200),
            background: [],
            maps: { address: '', url: '', loading: false, zoom: '16', width: 500, height: 500, maptype: 'roadmap', format: 'jpg', markers: {size: 'normal', color: '#ff5c5c', label: ''}},
            shareDesign: false,
            products: []
        };

        /*NBDesigner Advanced*/
        $scope.resource.background = {filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}}, data: [], onload: false, init: true, filteredBackgrounds : []}
        $scope.listBackgroundColor = $scope.resource.defaultPalette[0];
        console.log($scope.settings.nbes_settings,1111);
        if(angular.isDefined( $scope.settings.nbes_settings)) {
            if(angular.isDefined( $scope.settings.nbes_settings.background_colors)){
                if($scope.settings.nbes_settings.background_colors.codes.length > 0){
                    $scope.listBackgroundColor = $scope.settings.nbes_settings.background_colors.codes;
                }
            }   
        }

        if( angular.isDefined( $scope.settings.template_tags ) && $scope.settings.template_tags.length > 0 ){
            $scope.resource.customTemplates = [];
            $scope.settings.template_tags.forEach(function( tag ){
                $scope.resource.customTemplates[tag.id] = {
                    limit: 0,
                    total: tag.templates.length
                }
            });
        }
        if( angular.isDefined(NBDESIGNCONFIG.product_data.config ) && angular.isDefined(NBDESIGNCONFIG.product_data.config.qty) ){
            $scope.resource.config.qty = parseInt(NBDESIGNCONFIG.product_data.config.qty);
        }
        if( angular.isDefined(NBDESIGNCONFIG.product_data.config ) && angular.isDefined(NBDESIGNCONFIG.product_data.config.fold) && NBDESIGNCONFIG.product_data.config.fold ){
            $scope.resource.config.fold = NBDESIGNCONFIG.product_data.config.fold;
            $scope.resource.config.foldClass = NBDESIGNCONFIG.product_data.config.foldClass;
            $scope.resource.config.numberPanel = NBDESIGNCONFIG.product_data.config.numberPanel;
        }
        $scope.cuzIncludeExport = ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'vcard', 'title', 'date', 'avatar'];
        $scope.includeExport = ['objectCaching', 'itemId', 'selectable', 'editable', 'lockMovementX', 'lockMovementY','lockScalingX', 'lockScalingY', 'lockRotation', 'rtl', 'elementUpload', 'forceLock', 'isBg', 'isBgImg','is_uppercase','available_color','available_color_list','color_link_group','isOverlay', 'isAlwaysOnTop', 'ilr', 'oos', 'evented', 'ptFontSize', 'origin_src', 'reverse', 'spacing', 'radius', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent', 'v_card', 'isMask', 'maskId', 'strokeWidth', 'absolutePositioned', 'perPixelTargetFind', 'centeredScaling', 'origin_url', 'origin_width', 'origin_height', 'cropped', 'layerName', 'origin_pdf', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask'];
        $scope.includeExport.push('strokeUniform');
        if( appConfig.isCuz ){
            $scope.includeExport = $scope.includeExport.concat( $scope.cuzIncludeExport );
        }
        if( angular.isDefined(NBDESIGNCONFIG.product_data.option.font_cats) ){
            $scope.settings.fonts = $scope.settings.fonts.filter(function(font){
                if (font.cat.length == 0) font.cat = ["0"];
                return !font.cat.some(function(val) { return NBDESIGNCONFIG.product_data.option.font_cats.indexOf(val) === -1 && val != "99" });
            });
        };
        if( angular.isDefined( $scope.settings.nbes_enable_settings ) && $scope.settings.nbes_enable_settings.font == 1 
                && angular.isDefined( $scope.settings.nbes_settings ) && angular.isDefined( $scope.settings.nbes_settings.font_cats ) ){
            $scope.settings.fonts = $scope.settings.fonts.filter(function(font){
                if (font.cat.length == 0) font.cat = ["0"];
                return !font.cat.some(function(val) { return $scope.settings.nbes_settings.font_cats.indexOf(val) === -1 && val != "99" });
            });
        }
        $scope.resource.font.data = $scope.settings.fonts;
        if(!_.filter($scope.resource.font.data, ['alias', $scope.settings.default_font.alias]).length){
            $scope.resource.font.data.push($scope.settings.default_font);
        };
        if (angular.isDefined($scope.settings.nbes_enable_settings) && angular.isDefined($scope.settings.nbes_settings)
            && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined($scope.settings.nbes_settings.combination_colors)) {
            if (angular.isDefined(NBDESIGNCONFIG.product_data.config) && angular.isDefined(NBDESIGNCONFIG.product_data.config.combinationColor)) {
                var colorIndex = NBDESIGNCONFIG.product_data.config.combinationColor;
                if (angular.isDefined($scope.settings.nbes_settings.combination_colors.bg_codes[colorIndex])) {
                    $scope.currentCombinationColor = colorIndex;
                }
            }
        }
        $scope.resource.templates = $scope.settings.templates;
        if( ($scope.resource.templates.length == 0 || NBDESIGNCONFIG.product_data.option.admindesign != "1" || ( !$scope.isTemplateMode && $scope.settings.nbdesigner_hide_template_tab == 'yes' ) ) &&  $scope.settings.nbdesigner_enable_text == 'yes' ){
            $scope.getResource('typography', '#tab-typography');
        }
        if( NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no' && $scope.settings.nbdesigner_enable_clipart == 'yes' ){
            $scope.getResource('clipart', '#tab-svg', true);
        };

        /*NBDesigner Advanced*/
        if( NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no' ){
            $scope.getResource('background', '#tab-background', true);
        };
        $scope.$watchCollection('resource.background.filter', function(newVal, oldVal){
            $scope.resource.background.filteredBackgrounds = filterArtFilter($scope.resource.background.data.backgrounds, $scope.resource.background.filter);
            if(newVal.search != oldVal.search){
                $timeout(function() {
                    jQuery("#tab-background .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);     
                });
            }
            $scope.onEndRepeat('background');
        }, true);
        
        if(NBDESIGNCONFIG.show_nbo_option){
            $timeout(function(){
                $scope.getPrintingOptions();
            }, 100);
        }
        if( $scope.settings.task != 'create_template' && NBDESIGNCONFIG.product_data.option.admindesign == "1" 
                && NBDESIGNCONFIG.product_data.option.global_template == "1"
                    && NBDESIGNCONFIG.product_data.option.global_template_cat != "" ){
            var cid = parseInt( NBDESIGNCONFIG.product_data.option.global_template_cat );
            $scope.templateCat = cid;
            $scope.loadGlobalTemplate(cid, true);
        }
        $scope.resource.font.filter.total = $scope.resource.font.data.length;
        $scope.$watchCollection('resource.font.filter', function(newVal, oldVal){
            if(newVal.search != oldVal.search){
                $timeout(function() {
                    jQuery("#toolbar-font-familly-dropdown").stop().animate({
                        scrollTop: 0
                    }, 100);
                });
            }
            $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
        }, true);
        $scope.$watchCollection('resource.clipart.filter', function(newVal, oldVal){
            $scope.resource.clipart.filteredArts = filterArtFilter($scope.resource.clipart.data.arts, $scope.resource.clipart.filter);
            if(newVal.search != oldVal.search){
                $timeout(function() {
                    jQuery("#tab-svg .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                });
            }
            $scope.onEndRepeat('clipart');
        }, true);
        if( ( NBDESIGNCONFIG.ui_mode == '2' && NBDESIGNCONFIG.task2 == 'update' && NBDESIGNCONFIG.nbdesigner_hide_print_option_in_editor == 'yes') || angular.isDefined( NBDESIGNCONFIG.force_hide_print_option ) ){
            $scope.autoApplyOptions = false;
            $scope.$watch('printingOptionsAvailable', function(newVal, oldVal){
                if(newVal === true && !$scope.autoApplyOptions){
                    $scope.autoApplyOptions = true;
                    $scope.applyOptions();
                }
            }, true);
        };
        if( appConfig.autoSave && NBDESIGNCONFIG.is_logged == 1){
            $timeout(function(){
                $interval(function(){
                    if(!$scope.onloadTemplate && !$scope.onLoadPrintingOptions) $scope.saveData('save_draft');
                }, 18E4);
            }, 6E4);
        }
        $scope.settings.dynamicStage = ( angular.isDefined( $scope.settings.product_data.option.dynamic_side ) && $scope.settings.product_data.option.dynamic_side == "1" && !$scope.isTemplateMode ) ? true : false;
        $scope.settings.maxNoOfStage = 999;
        $scope.settings.minNoOfStage = 1;
        $scope.settings.canSwapStage = true;
        $scope.settings.gridViewMode = false;
        $scope.settings.enableImageFilter = ( NBDESIGNCONFIG.nbdesigner_modern_layout_image_filter == 'yes' && NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ) ? true : false;
        $scope.availableFilters = ['blur', 'desaturate', 'contrast', 'sepiatone', 'hue', 'luminance', 'colorize', 'posterize', 'darken', 'lighten', 'invert'];
        $scope.initSearchTempalte();
    };
    $scope.loadMoreCustomTemplates = function(){
        if( $scope.resource.templateType == 'custom' && angular.isDefined( $scope.resource.currentTemTagId ) ){
            if( angular.isDefined( $scope.resource.customTemplates[$scope.resource.currentTemTagId] ) ){
                if( $scope.resource.customTemplates[$scope.resource.currentTemTagId].limit < $scope.resource.customTemplates[$scope.resource.currentTemTagId].total ){
                    $scope.resource.customTemplates[$scope.resource.currentTemTagId].limit += 24;
                }
            }
        }
    };
    $scope.searchTemplate = function(){
        if( $scope.resource.templateSearch.value == '' ){
            if( !( $scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length ) ){
                $scope.resource.templates = $scope.resource._templates || $scope.resource.templates;
                $timeout(function() {
                    jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                });
            }
            return;
        }
        $scope.resource.templateSearch.loading = true;
        NBDDataFactory.get('nbd_search_template', {
                product_id: NBDESIGNCONFIG['product_id'], 
                variation_id: NBDESIGNCONFIG['variation_id'], 
                search: $scope.resource.templateSearch.value
            }, function(data){
                var _data = JSON.parse(data);

                if( angular.isDefined( _data.tag ) ){
                    if( $scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length ){
                        if( _data.tag != '' ){
                            $scope.activeTemplateTag( _data.tag );
                        }else if( _data.templates.length ){
                            var issetUnTag = false, wait = 0;
                            $scope.settings.template_tags.forEach( function( tag ){
                                if( tag.id == 0 ) issetUnTag = true;
                            });

                            if( issetUnTag ){
                                $scope.resource._unTagTemplates = $scope.resource._unTagTemplates || $scope.settings.template_tags[0].templates;
                                $scope.settings.template_tags[0].templates = _data.templates;
                            }else{
                                $scope.settings.template_tags.unshift({ id: 0, templates: _data.templates, thumb: NBDESIGNCONFIG.assets_url + 'images/template.png', name: NBDESIGNCONFIG.nbdlangs.templates });
                                $scope.resource.customTemplates[0] = {
                                    limit: 24,
                                    total: _data.templates.length
                                };

                                if( jQuery('#tab-template .result-loaded').hasClass('loaded') ){
                                    wait = 100;
                                    jQuery('[data-type="tags-0"]').click();
                                }

                                $timeout(function() {
                                    var itemInRow = 3, itemDistance = 10,
                                    $items = jQuery('#tab-template').find('.items'),
                                    $item = jQuery('#tab-template').find('.item'),
                                    $resultLoaded = jQuery('#tab-template').find('.result-loaded'),
                                    $mainItems = jQuery('#tab-template').find('.main-items'),
                                    $contentItem = jQuery('#tab-template').find('.result-loaded .content-item'),
                                    $galleryItem = jQuery('#tab-template').find('.nbdesigner-gallery'),
                                    $contentItem = jQuery('#tab-template').find('.result-loaded .content-item'), 
                                    noItem = $item.length,
                                    noItemRow = parseInt(noItem / itemInRow),
                                    itemHeight = $item.outerHeight() + itemDistance;

                                    if( jQuery('#tab-template .result-loaded').hasClass('loaded') ){
                                        wait = 100;
                                        jQuery('[data-type="tags-0"]').click();
                                    }

                                    function initPositionItem(){
                                        var leftItem = $items.width() / itemInRow;
                                        var topItem = $item.height() + itemDistance;
                                        $item.show();

                                        $item.each(function () {
                                            var index = jQuery(this).index();
                                            var indexMod = index % itemInRow;
                                            var indexI = parseInt(index / itemInRow);
                                            jQuery(this).css({
                                                'left': leftItem * indexMod + 'px',
                                                'top' : topItem * indexI + 'px'
                                            });
                                        });
                                    }
                                    initPositionItem();

                                    jQuery($item[0]).on('click', function () {
                                        var indexItem = jQuery(this).index();
                                        var indexItemRow = parseInt(indexItem / itemInRow) + 1;
                                        var widthItem = jQuery(this).outerWidth();
                                        var dataType = jQuery(this).attr('data-type');

                                        $mainItems.css({
                                            'height': indexItemRow * (itemHeight - 15) + 'px'
                                        });
                                        $mainItems.find('.pointer').css({
                                            'left': ((widthItem) * (indexItem % itemInRow + 1) - widthItem / 2)  + 'px'
                                        });

                                        $resultLoaded.show().addClass('overflow-visible');
                                        $contentItem.filter(function (index) {
                                            return jQuery(this).attr('data-type') === dataType;
                                        }).show().find('input[type="text"]').first().focus();
                                        $galleryItem.hide();
                                        if (!$mainItems.hasClass('active-expanded')) {
                                            jQuery(this).siblings().css({
                                                'opacity': '0.5'
                                            });
                                            $mainItems.addClass('active-expanded');
                                            $resultLoaded.addClass('loaded');
                                            var nextAllItem = $items.find('.item:nth-child(' + indexItemRow * itemInRow + ')').nextAll();
                                            jQuery(nextAllItem).each(function () {
                                                jQuery(this).hide();
                                            });
                                        }else {
                                            jQuery(this).css({
                                                'opacity': '1'
                                            });
                                            jQuery(this).siblings().css({
                                                'opacity': '1'
                                            });
                                            $mainItems.removeClass('active-expanded');
                                            initPositionItem();
                                            $resultLoaded.hide();
                                            $contentItem.hide();
                                            $resultLoaded.removeClass('loaded');
                                        }
                                    });
                                });
                            }

                            $timeout(function() {
                                $scope.activeTemplateTag( 0 );
                            }, wait);
                        }else{
                            $scope.resource.templateSearch.loading = false;
                        }
                    }else{
                        $scope.resource._templates = $scope.resource._templates || $scope.resource.templates;
                        $scope.resource.templates = _data.templates;
                        $scope.resource.templateLimit = 24;
                        $timeout(function() {
                            jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                        });
                        $scope.resource.templateSearch.loading = false;
                    }
                }else{
                    $scope.resource.templateSearch.loading = false;
                }
        });
    };
    $scope.activeTemplateTag = function( tagId ){
        if( $scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length ){
            $timeout(function() {
                if( jQuery('#tab-template .result-loaded').hasClass('loaded') ){
                    jQuery('[data-type="tags-' + tagId + '"]').click();
                    $timeout(function(){
                        jQuery('[data-type="tags-' + tagId + '"]').click();
                        $scope.resource.templateSearch.loading = false;
                    }, 300);
                }else{
                    jQuery('[data-type="tags-' + tagId + '"]').click();
                    $scope.resource.templateSearch.loading = false;
                }
            });
        }else{
            $scope.searchTemplate();
        }
    };
    $scope.prepareSearchTemplate = function($event){
        if( $event.keyCode == 13 ){
            $scope.searchTemplate();
        }else{
            if( $scope.resource.templateSearch.value == '' ) {
                $timeout(function() {
                    $scope.resource.templateSearch.focus = true;
                    if( $scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length ){
                        $scope.settings.template_tags[0].templates = $scope.resource._unTagTemplates || $scope.settings.template_tags[0].templates;
                    }else{
                        $scope.resource.templates = $scope.resource._templates || $scope.resource.templates;
                        $scope.resource.templateLimit = 24;
                        $timeout(function() {
                            jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                        });
                    }
                });
            }else{
                $scope.resource.templateSearch.focus = false;
            }
        }
    };
    $scope.initSearchTempalte = function(){
        if( angular.isDefined( $scope.settings.template_tags ) && $scope.settings.template_tags.length ){
            source = $scope.settings.template_tags.map(function( tag ){
                return {
                    label: tag.name,
                    value: tag.id
                };
            });

            jQuery( "#nbd-search-template" ).autocomplete({
                source: source,
                select: function( event, ui ) {
                    event.preventDefault();
                    $scope.resource.templateSearch.value = ui.item.label;
                    $scope.activeTemplateTag( ui.item.value );
                },
                focus: function(event, ui) {
                    event.preventDefault();
                    $scope.resource.templateSearch.value = ui.item.label;
                }
            });
        }

        jQuery( document ).on("click", function(event){
            var suggetTagEl = jQuery( '.nbd-suggest-tag' );
            var searchTagEl = jQuery( '#nbd-search-template' );
            if( suggetTagEl.has(event.target).length == 0 && !suggetTagEl.is(event.target) && searchTagEl.has(event.target).length == 0 && !searchTagEl.is(event.target) ){
                if( $scope.resource.templateSearch.focus ) $scope.resource.templateSearch.focus = false;
            }
        });
    };
    $scope.updateQtys = function(){
        $scope.resource.config.qty = _.sumBy($scope.resource.config.qtys, function(qty) { return qty; });
        var hasVariation = false;
        if( !!$scope.resource.config.variations ){
            angular.forEach($scope.resource.config.variations, function(variation, key) {
                variation.qty = 0;
            });
            hasVariation = true;
        }
        angular.forEach($scope.resource.config.qtys, function(qty, key) {
            if( qty.variation > -1 ){
                $scope.resource.config.variations[qty.variation] += qty.value;
            }
        });
        if( NBDESIGNCONFIG.ui_mode == 1 ){
            if(hasVariation){
                nbd_window.NBDESIGNERPRODUCT.updateQty($scope.resource.config.qty, $scope.resource.config.variations);
            }else{
                nbd_window.NBDESIGNERPRODUCT.updateQty($scope.resource.config.qty);
            }
        }
    };

    $scope.addColorBackground = function(color){
        var _color = angular.isDefined(color) ? color : $scope.backgroundColor;
        $scope.listBackgroundColor.push(_color);
        $scope.listBackgroundColor = _.uniq($scope.listBackgroundColor);
    }

    $scope.addColor = function(color){
        var _color = angular.isDefined(color) ? color : $scope.currentColor;
        $scope.listAddedColor.push(_color);
        $scope.listAddedColor = _.uniq($scope.listAddedColor);
        jQuery('.nbd-perfect-scroll').perfectScrollbar('update');
    };
    $scope.showTextColorPalette = function(){
        $scope.showTextColorPicker = !$scope.showTextColorPicker;
    };
    $scope.showBgColorPalette = function(){
        $scope.showBgColorPicker = !$scope.showBgColorPicker;
    };
    $scope.hasGetUserMedia = function(){
        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia || navigator.msGetUserMedia);        
    };
    $scope.settings = {};
    $scope.init = function() {
        appConfig.init();
        $scope.localStore.init();
        if(typeof nbd_window.NBDESIGNERPRODUCT != 'undefined'){
            nbd_window.NBDESIGNERPRODUCT.hide_loading_iframe();
        };
        $scope.isTemplateMode = NBDESIGNCONFIG.task === 'create' || (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template' );
        $scope.initSettings();
        $scope.contextAddLayers = 'normal';
        $scope.workBenchHeight = $window.innerHeight;
        $scope.workBenchWidth = $window.innerWidth;
        $timeout(function(){
            jQuery('.nbd-load-page').hide();
            if( appConfig.isModern ){
                window.initModernLayout();
            }else if( appConfig.isVisual ){
                window.initVisualLayout();
            };
            $scope.initDropboxChooser();
        });
        var _window = angular.element($window);
        _window.bind('resize', function(){
            /* to do: resize design */
            $scope.reCalcViewPort();
        });
        $scope.fullScreenMode = false;
        var _document = angular.element($document);
        _document.bind('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', function(){
            $scope.fullScreenMode = !$scope.fullScreenMode;
            jQuery("body").toggleClass("fullScreenMode");
            $timeout(function(){
                $scope.toggleStageFullScreenMode();
            });
        }); 
        /* real time update printing option */
        var _intervalOptions = $interval(function() {
            if($scope.awaitInsertTemplate){
                $scope.changePrintingOptions();
            }
        }, 100);
        var log = "c"+"o"+"n"+"s"+"o"+"l"+"e.i"+"n"+"f"+"o('%cP"+"o"+"we"+"r"+"e"+"d b"+"y %cN"+"E"+"T%cB"+"A"+"S"+"E%cT"+"E"+"A"+"M', 'color: orange; font-size: 20px;', 'color: red; font-size: 40px;', 'color: green; font-size: 40px;', 'color: #F48024; font-size: 40px;')";
        []["filter"]["constructor"](log)(); 
        if( $scope.settings.valid_license == '0' ){
            (function (url) {
                var image = new Image();
                image.onload = function () {
                    var style = [
                        'font-size: 1px;',
                        'line-height: ' + this.height + 'px;',
                        'padding: ' + 0 * .5 + 'px ' + this.width * .5 + 'px;',
                        'background-size: ' + this.width + 'px ' + this.height + 'px;',
                        'background: url(' + url + ');'
                    ].join(' ');
                    console.group('%c'+'W'+'e'+'l'+'c'+'o'+'m'+'e'+'! \ud83d\ude4c', 'font-size: 20px;');
                    console.log('%c ', style);
                    console.log('%ch'+'t'+'t'+'p'+'s'+':'+'/'+'/'+'n'+'e'+'t'+'b'+'a'+'s'+'e'+'t'+'e'+'a'+'m'+'.'+'c'+'o'+'m/', 'font-size: 40px;');
                    console.groupEnd();
                };
                image.src = url;
            })('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAIAAAABc2X6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAD+dJREFUeNrsW2lwHMd1fq+759rZA1jiBgECBHgIJACBoiiIokydNC1FR2RHsXW4XElVYvlHKlYqqcpRSaVUqfxwDpedQy7LOSzKki0rqti0RIoSSYs3JYiEQAIkQeKicB+LxV5zdufHgjCI3QV3yYUDi+raH1sz0zPz9et3fe8NPvP3hy2Hw80xZEaY5XD7pgEMAARusvEZ4M8Afwb4M8C/UYNlOsGFECLjNEQgiKnHBQDn6aeRKxMEABcCRC5iSfuw/AKWCMHk26VBi5bjchTJS+YPCigRTDvFEcmVQIpAOSeEZvmKiBiKW47LEYEQwihKlDCK+QQsBNzfWNbaWJT+DQAtx/3+2xdHpo35D7YdvrbM9zvbV6kKTZ3y4tvdgxNxx7VrgvTpB9bpHjVbwIChuOVwjoBjU/FPRqI9o/G+ybgiXY/gM0q4ulS/dW1wkZm9Q7FdB3uv1gLweaQtDUUk3fLrB2gsEQkb02uKi1o3lFCJXZ+ITNOJJJz27tBrB/uGphOKRPNjtK4Zbz60tbK8UHWv1ljORcJ0014/FZ2Yik/Y3OICM12TzVAUVlSg3n97+d9+rbFlld+wHEQCgDcK+JrD62FP3Vvr2NnG4bZrCRAI+bI+UFHsff7JhlVBEY7NgOCIZGkBA0DrxqLmmgLDduH/aQQLPH/wWw2uOTURGUuYkaTCLyFgRaaPb6tWKXV5Dk4GESVG84W5ZV3F/S01k7FwKDY5OTNqWLEk7EzI2Q0+79Y1wZa64NFz45pCs0MLpu0MjoV1j5yLJ4aArmqalNaI37lx5etHz7sgDCdhxQzJVHTFr0gqJQzEQo9/o4BlmTy+deXZgem47WSXgrPzI1Pf/Ld3CYLIGrEAUVsefHTbuu3NVZQt3JXFPrXUp02atkSJALAcw7QNRVJ1xatKOiWUC543wADQuKZwU13wUOcYZBE9IUDCEVE7IXJ8yrkz/WcHJqqLPl+/asVC4XvUgK6OG9Y8pQHDTpiOobCoJusexUcAk6LOTyz97IOrA5okstVhYIRIOf78mhyJm6OhWOoNp2NGKJog5CosBAkCGnYiHJ+amBmOmZGkj2B5AVxerN3XXLbrl73X2plgOW72shVCzJlDw3TurCurryxMvSycsGYSFk0XgRAkAGA5puWYMTMS9BayfFnLh7eufO/0iJ0ZjhAgEawu8FJKstJeIVRFCvhUIUAIUehVf/vO+tJiX+oqfnhhJOpwv8wW8QvJQGAqNp43wKVB9fG7qk6cHc+UB7mcF2jqn3+ptaTIm525EqoiBbwqCAAEzSOlvejspbHdJy95NSlLj5g3wABwd2PJTNgybe7NIGHGsGZlsLhIz9cTB4bDL/zoyFTC1CSapabkbLSGxyOHP+pPe6qsSNu5tVKV6SK72spfWCYE/Oidjo7+CVki2duFnAGPRxI/eb/LMOy0ZytLPLqWz12zuLX/6s7mr9y9jlucLx1gWaYHOj5pOze8HPiailLfXzx795N3rbNNe6m2NEWS4O7L+zoiETNnmQBQgvnFTCg+99htzTWlCcu+IQJgkaHJ7Oil0X0f9Dxx3y058VIJy9174lJBQMsp2Uju3prKwvJCvawojUH0+ZTHtqw+PzjpCnFNDuQ69U2R6a79Z7a31Kwo1LLdGgSnE+a395wSQuSaFAsBtuPWBv1//Njme7fUsJRka3tL7Q8PdfWNzSjXysOuM7SkiL1T0Zf3tOcqKEWiqsxUKbefJjO/RxmMxv/qlUOjoXiaxLhQqwjo2aQj1x9LE4K723raf43WS2M04jgfnR9Jb8B8Gs2C9Lh+wIyS0Ujif492c/fXVG21OecO92QIIXl24dv1+0wEUGT6zum+Hbevbm1cmc0ULkTMtDnPWYdBgO24KzzqM9vWb2moSHtJ33TMFYItHWAAkAgJGfbL+zoa60t0Tb4GWi58iryzqUbXFc55rspfWRqoKfJlWtnJUHwyamAWNPUNARYAPlU6cmHoYFv/w9vWLH6xy4VXlX5/Z3NFuT8HsmNeprfIyeMdl8emYtmUI/JAAEgye+ntU5FoVnEIEgQEIJjzb5GldPne9oEZ086mEJEHwARxYDr+X7vbs1TjvBuzNw+cO9Z12aNklSHmAXByVd861XOxb+LXH04fbuv/973tnJAsY1ZyDRzp5JlmVzNyORT94f7ObLZDvqBalvv6O2f+5tUjobgh02wll8loCde2QMBC64KYyesqCjvY3n/848utjVVpbNIVnIKLNLfNsORCiLhhz69TI0LMsBOWc/rC6BuHznWNhDiAzGj2esIySBePnhvpnxzn/CrChlEyEUnI6egyiZAZ237xF6ePdQ5xWFhMlymdmkmYtvuDPe1ZuiVEtB13ZCLquO6cvyEIQ5PR4XBsxnEVRikluZYw8MkX3k8tFCJg3DKHQ0O2a1+1twVQgrqSnpFFBNN2zSSngQs9mK5KCBi3sg48BCAipcmiiZhzhIwQSvD6VEOWaIaCOAhdUcsLi0OxibTuN1NOIzMqL5qv6NnZ0qUbZBH/ocm6Jmnz6xSfgrGIcROI6NUCEpFuEsAghJCZ5pF1sQTRwnIEDABCcK8WkJkMIG4KwABAkPrVgk8L3iwACwBF8nhk76fDemUTkQkkRNf8EmGfAmXOKgQVgitM1RU/4G+8hFlaDzwnSIKzUZ3DXVXxRc2Y7ZqAmClYzrQDCMJ8Kpqka9XkYrY5MfWsALBdnnwtgsiu0Plu5myTZojFWKrGMiSUoBCCIBqOKwhSBJkQBCzWg6HYGAhBEBeURQVi2uMIIAAFChSzIWIywIwJ4VGkuXdyhZAEKJQIISwuOM5fCLBMuzKge1QJAMJxczSSkGTGCGoE53oZFgwHIW2teiHguOF8eXvNpvqgEAIRT3aO7f5wmEr0S1ur1lYHOOe7f9lZWaI1ry1foM9tXcOUYsu6hccRIRK1jndc3ryhstCvCgGIGDftA6cH9p7qdQkigCuEDPiHO5s31BQJIfad7t/1fpdPk5MLoQj8xmOb71hbPgs4Znb0je967+xAOPp3T21bWeRLtSyci++8+cGFyQhNEfNCwLbD61f6mtfMdhZsqPG3dQ9PRPj6Kn/T2kIA+PBjT0Nt6eYNlQsmmglXkknqcQAQrhidiN7VXO3x/Iro29pY5VPlVw51MpmZtruhuviJ7eu9XgUAmMTeOnkpwTlBBMf9+iObn/lC0/wbNq0rK/Frf/afB1saKlYV+9Nu6YI9HwsRSTU6LFUVrXndhEyiD91W/vKBQcPmAOC43HbcuRLv2FRsOm4mtfziSIgxEizSEbGuvCB5cGBsJmE5sbjVPRR67d2zlcX+2upCClhd6pckunPL6r2nescTJnKxeW1ZEi0A1FcGG2tLDp0flCipCfrubqwCgKlw4nDHJwU+ZVtTFUF8sLV+y7HuqZlEEvBoKBaKGvRKX4vLecS0MUujtWDs2Fp3smviV+UvnG2ZAAHfee34fxw+J0sEAXwehSLab57UZHb4n59NNrk+/713D3ZcViUmMcqFEFzEbbulbMUrf/14yQqvKjOPzOxIvDSg39e0au6JXq+8qa7k2PlB23HLi/wlQS8A9I+Ed+0/Mzgcfu6RltvWV/hUWVPZ3F7+h9dP/OvuU0HvbEsyY6S4wJO2UnltwKrCntqxbjpqp7IE92yq9QU8jCAXcOjMwEg0ITOizqsM+DzKd7/xoK7K88haXlmgBwMeAOgeCfVOzDBKmqqCDWtKAKDz4lhddVCR2ecaq9841j0wGZmOGpGYqXmklnVlP/jmFy4NhqbCib2Hu09cHL40FXnu0duSt33mgY2tDZVzHY39g9OvHupyuUDMBXA0ZiGC7pEb6osS6Ur+D7SufqB1NQAAh55vTQxFEguIYUbJV+5pSHtz23Y/6Bq2BPcxdn/TqqRLe3XfmS3rKx65d/3a2qK1ZQXD0/Fzg5O/OH7x6Z2NskR9PvXW9eUA0HJLefCw/q03Ts5F+M2rS5pXl8zdvKdv6rVDXTkT8Yfa+zkXD29bCwCamiZJNC3HdXiSGXbScV2cQ/flSd/VRQmKuKJQlxh99oGNp3vHwhHjc7fVAIBhOsWFHsuZtRA7N9Ue7R6mSP57/5nuvvEH76hfV7OiQFc9ulzo1776UHNbz1jMmO13XKDDnQPjIkcSDwBg2rbfOzm08841NAOj/9N9nQfODEiUCCF6piKULMypbMf5+j+9pc5rfhcACPCXT2/b2ly1qrLg1rpSYnOfVwEATWV/9OXWuStvb6qq3+9/aNPq2ooCQshLb53qGQs3VBc/uf2WezbXAMCGyqDnSt/lv/ys7ft7Pi68YvYIIbrC0oYeiwHWJNp2KXSsY2LbrcVpA87JsNE/GiXoIgBFhHnkU5ajWFe23FKZ9lTQpz64cdXWpuq6VUEAkGX2wq7DZ/vHB8fSlJdKveqGYr/Po8zZl6jlRBwXczVahMIr+3ub1wR8upwaTH7t0ebf3bFBAEeAPcd7vv12m0zp1Xw1e/H5h1K3dFFQB4CJ6QQTpKo8AACXBqb+8acnQpZtO+6m2tI/eWKLorFNGyvfa7uUBLx5Q8VLf/qw4/LSFbNdD51Doc1XamvPfr7pi3evxzmzLOB7b7b9rL1PSmm9ZalE3FyjlaYwAjg0bfz8yOBTO2qTRkhhVLtih/1exX9lF5Wv8HEOQAEB5j68YIysqVqRXl9mEm8e7FxVGSgq8ADAiQvDe9r7/B7FdFwjav3e/RvLNH9jXcmP93S8c+zijjvqgUBxcLajLRG39rf1ftA19PyTW5JHAl414L3qM5lCr8qz0WFFIqcuhqaiYZc7H10cUWSKAHtODfu84ILpcnFmcCIOdDg643J3joxFhFPnxxglAOBw8T9HLiT/T4TjP3m/S5UXGrzR8ejxM5cvj8988Z5bfn78om27ez/oCXhVhVFZYqG48ePD52pXBgnANPAXXj3a0TfRUFdc6lUTljMyYxxtHzhyfjDh8nc+7C0p1NMm8edGQmn98EJeGhHjpjsdDbvckSVa5PNTKnEuQtF43IwBgq4qBFjcNFzuztUTuGtbPJbkqwXAdNRIhgR+jxxNWKktO5SiKjNGScywHYcjgq5KikSTswRANGEl30pXJYmRqGGjECW6atjOtOFIMtVkRhDDMSNTd66uSWpKRUKWaHoinsw2S6CA2aQMAefo/5SPU1AIPhUZjTtxXLKMWQC4nCMivYHqVEYiPpXNEXDVt4gpOSB6tQIzariCLxFmBGAkH8XdPC2/kJmiK/7lzwHl7XNagairPoWpy5zry9/3w4JTIvkUH0FycwAGEIKrsleTPGIZs9j5lgaiXwssZyHn/c0EY4pPCYjlqsn5F4UQoKs+manL02Ivxd4ThFCfWpBK2X5aAYMQ4JE9y7POukTWRQgEXQ1IVFpWQhYCmMyWyqJKTOPcP2POLB/ACqP/NwDoKvSxYaDXdQAAAABJRU5ErkJggg==');        
        }
        jQuery(document).triggerHandler( 'nbd_app_loaded' );
    };
    /* Util */
    $scope.initDropboxChooser = function(){
        var options = {
            success: function(files) {
                $scope.getPersonalPhoto('dropbox', files);
                $scope.updateApp();
            },
            linkType: "direct",
            multiselect: true,
            extensions: ['.jpg', '.jpeg', '.png']
        };
        if( NBDESIGNCONFIG['enable_dropbox'] && $scope.settings.nbdesigner_enable_image == 'yes'  ){
            var button = Dropbox.createChooseButton(options);
            document.getElementById("nbdesigner_dropbox").appendChild(button); 
        };
    };
    $scope.localStore = {
        db: null,
        ready: false,
        existed: true,
        numberOfRecords: 0,
        init: function(){
            var self = this;
            var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
            if(indexedDB){
                var open = indexedDB.open("NBDesigner", 1);
                if( open == null ) return;
                open.onsuccess = function (e) {
                    self.db = e.target.result;
                    self.ready = true;
                };
                open.onupgradeneeded = function(event){
                    var db =  event.target.result;
                    var objectStore = db.createObjectStore("designs", { keyPath: "id" });
                    self.existed = false;
                };
                open.onerror  = function(event){
                    console.log(event);
                };
            }
        },
        add: function( pid, data, callback ){
            if( this.ready ){
                var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").add({ id: pid, data: data });
                request.onsuccess = function(event) {
                    if(typeof callback == 'function') callback();
                };
            }
        },
        update: function( pid, data, callback ){
            if( this.ready ){
                var objectStore = this.db.transaction(["designs"], "readwrite").objectStore("designs");
                var request = objectStore.get(pid);
                request.onsuccess = function(event) {
                    var _data = event.target.result;
                    if( _data ){
                        _data.data = data;  
                    }else{
                        _data = { id: pid, data: data };
                    }
                    var requestUpdate = objectStore.put(_data);
                    requestUpdate.onsuccess = function(event) {
                        if(typeof callback == 'function') callback();
                    };
                };
                request.onerror = function(event) {
                    console.log(event);
                };
            }
        },
        count: function(){
            var self = this;
            if( this.ready ){
                var transaction = this.db.transaction(["designs"]);
                var objectStore = transaction.objectStore("designs");
                var countRequest  = objectStore.count();
                countRequest.onsuccess = function() {
                    self.numberOfRecords = countRequest.result;
                };
            }
        },
        get: function( pid, callback ){
            if( this.ready ){
                var transaction = this.db.transaction(["designs"]);
                var objectStore = transaction.objectStore("designs");
                var request = objectStore.get(pid);
                request.onsuccess = function(event) {
                    if(typeof callback == 'function'){
                        callback(event.target.result);
                    }
                };
                request.onerror = function(event) {
                    console.log(event);
                };
            }
        },
        delete: function( pid, callback ){
            if( this.ready ){
                var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").delete(pid);
                request.onsuccess = function(event) {
                   callback();
                };
            }
        }
    };
    $scope._localStorage = {
        save: function(type, value){
            if( type == 'nbduploaded') {
                if( $scope.resource.upload.data.length > 20 ) $scope.resource.upload.data.shift();
                value = JSON.stringify($scope.resource.upload.data);
            }
            localStorage.setItem(type, value);
        },
        get: function(type){
            var data = localStorage.getItem(type);
            if( data ){
                return JSON.parse(data);
            }else{
                return [];
            }
        },
        delete: function(type){
            if( type == 'nbduploaded') {
                $scope.resource.upload.data = [];
                $scope.updateApp();
            }
            localStorage.setItem(type, JSON.stringify([]));
        }
    };
    $scope.generateUniqueId = function(){
        return '_' + Math.random().toString(36).substr(2, 9);
    };
    /* Get Data */
    $scope.getResource = function(type, container, callback){
        if( type == 'typography' && $scope.settings.nbdesigner_hide_typo_section == 'yes' ) return;
        if( $scope.resource[type].data.length || angular.isUndefined($scope.resource[type].data.length) ) return;
        jQuery(container + ' .loading-photo').show();
        NBDDataFactory.get('nbd_get_resource', {type: type, task: $scope.settings.task}, function(data){
            jQuery(container + ' .loading-photo').hide();
            var _data = JSON.parse(data);
            $scope.resource[type].data = _data.data; 
            $scope.resource[type].filter.total = $scope.resource[type].data.length;
            if( callback ) $scope.afterGetResource(type);
        });
    };
    $scope.onClickTab = function(type, tab){
        $scope.resource[tab].onclick = !$scope.resource[tab].onclick;
        if(!$scope.resource.photo.onclick) jQuery('#tab-'+tab+' .loading-photo').hide();
        $scope.disableDrawMode();
        switch(type){
            case 'dropbox':
            case 'facebook':
            case 'instagram':
            case 'upload':
            case 'url':
                if( type == 'upload' ){
                    if( $scope.settings.nbdesigner_cache_uploaded_image == 'yes' && $scope.resource.upload.data.length == 0){
                        $scope.resource.upload.data = $scope._localStorage.get('nbduploaded');
                    };
                };
                $timeout(function(){
                    if(type != 'url' && $scope.resource[tab].onclick){
                        $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                    }
                });
                $scope.resource.personal = {status: true, type: type};
                break; 
            case 'Pixabay':
            case 'Unsplash':
            case 'Pexels':
            case 'Freepik':
                $scope.resource.personal.status = false;
                if($scope.resource[tab].onclick && $scope.resource[tab].type != type){
                    $scope.getPhoto(type);
                }
                break;
            case 'shape':
            case 'icon':
            case 'line':
            case 'flaticon':
            case 'storyset':
                if($scope.resource[tab].onclick){
                    $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                }
                if( $scope.resource[tab].onclick && $scope.resource[tab].type != type ) $scope.getMedia(type);
                break;
            case 'draw':
                if($scope.resource[tab].onclick){
                    $scope.enableDrawMode();
                }
                $scope.resource.element.type = type;
                break;
            case 'qrcode':
                $scope.resource.element.type = type;
                break;
            case 'vcard':
                $scope.resource.element.type = type;
                break;
            case 'photoFrame':
                $scope.resource.element.type = type;
                if( !$scope.resource[type].filter.currentPage ){
                    $scope.resource[type].filter.currentPage = 1;
                }
                break;
            default:
                $scope.resource.element.type = type;
                break;
        };
    };
    $scope.uploadSvgFile = function(){
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/svg+xml|application/svg+xml';
        input.style.display = 'none';
        input.addEventListener('change', onChange.bind(input), false);
        document.body.appendChild(input);
        input.click();
        function onChange(){
            if (this.files.length > 0) {
                var file = this.files[0],
                reader = new FileReader();
                reader.onload = function(event){
                    if (event.target.readyState === 2) {
                        var result = reader.result;
                        $scope.addSvgFromString(result);
                        destroy();
                    }
                };
                reader.readAsText(file);
            }
        }
        function destroy() {
            input.removeEventListener('change', onChange.bind(input), false);
            document.body.removeChild(input);
        }
    };
    $scope.templateName = '';
    $scope.loadTemplateCat = function( callback ){
        var dataObj = {
            source: 'media',
            type: 'get_template_cat'
        };
        NBDDataFactory.get('nbd_get_resource', dataObj, function(data){
            data = JSON.parse(data);
            if(data.flag == 1){
                $scope.templateCats = data.data;
                $scope.templateCat = parseInt($scope.templateCats[0].id); 
            };
            jQuery('.nbd-popup.popup-template').find('.overlay-main').removeClass('active');
            if( typeof callback == 'function' ) callback();
        });        
    };
    $scope._loadTemplateCat = function(){
        $scope.toggleStageLoading();
        $scope.resource.globalTemplate = {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: false, onload: false};
        $scope.loadTemplateCat(function(){
            $scope.loadGlobalTemplate($scope.templateCat);
        });
    };
    $scope.changeGlobalTemplate = function(){
        $scope.toggleStageLoading();
        $scope.resource.globalTemplate = {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: false, onload: false} 
        $scope.loadGlobalTemplate($scope.templateCat);
    };
    $scope.templateSize = {
        width: 200,
        height: 200
    };
    $scope.changeTemplateDimension = function(){
        var width = 200, height = 200;
        $scope.templateSize.width = $scope.templateSize.width != '' ? $scope.templateSize.width : 200;
        $scope.templateSize.height = $scope.templateSize.height != '' ? $scope.templateSize.height : 200;
        if( $scope.templateSize.width > $scope.templateSize.height ){
            height = Math.round( $scope.templateSize.height / $scope.templateSize.width * 200 );
        }else{
            width = Math.round( $scope.templateSize.width / $scope.templateSize.height * 200 );
        }
        $scope.templateSize.width = width;
        $scope.templateSize.height = height;
        _.each($scope.stages, function(stage, index){
            stage.config.width = width;
            stage.config.cwidth = width;
            stage.config.height = height;
            stage.config.cheight = height;
            $scope.setStageDimension(index);
        });
    };
    $scope.globalTemplateLoaded = false;
    $scope.loadGlobalTemplate = function(cid, withoutLoading){
        var search = '';
        $http({
            method: 'GET',
            url: appConfig.mediaUrl + '/template?limit='+ $scope.resource.globalTemplate.filter.perPage +'&category=' + cid + '&search=' + search + '&start=' + ($scope.resource.globalTemplate.filter.currentPage-1) * $scope.resource.globalTemplate.filter.perPage
        }).then(function successCallback(response){
            var data = response.data.templates;
            $scope.globalTemplateLoaded = true;
            _.each(data.items, function(item, key) {
                $scope.resource.globalTemplate.data.push({
                    thumbnail: item.thumbnail,
                    name: item.name,
                    id: item.id
                });
            });
            if( angular.isUndefined(withoutLoading) ) $scope.toggleStageLoading();
            $scope.resource.globalTemplate.filter.totalPage = data.pagesTotal > 10 ? 10 : data.pagesTotal;
            $scope.resource.globalTemplate.onload = false;
            $timeout(function(){
                jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
            }, 1000);
        }, function errorCallback(response) {
            console.log('Fail to load: globalTemplate');
        });
    };
    $scope.getGlobalTemplate = function(id, callback){
        var dataObj = {
            source: 'media',
            type: 'get_template',
            id: id
        };
        NBDDataFactory.get('nbd_get_resource', dataObj, function(data){
            data = JSON.parse(data);
            if(data.flag == 1 && data.data.design){
                if( typeof callback == 'function' ) callback(data.data);
            }else{
                $scope.toggleStageLoading();
                console.log('Error load global template!');
            };
        });
    };
    $scope.insertGlobalTemplate = function(id, $index){
        if( angular.isDefined($index) && $scope.settings.valid_license == '0' && $index > 4 ){
            alert($scope.settings.nbdlangs.pro_license_alert);
            return;
        }
        $scope.showDesignTab();
        $scope.clearHistory();
        $scope.toggleStageLoading();
        $scope.getGlobalTemplate(id, function(data){
            var fonts = JSON.parse(data.used_font);
            var design = JSON.parse(data.design);
            if( angular.isUndefined(design.canvas) ) design.canvas = {width: 200, height: 200};
            if(fonts.length){
                _.each(fonts, function(font, index){
                    if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                        $scope.resource.font.data.push(font);
                    };   
                    var font_id = font.name.replace(/\s/gi, '').toLowerCase();
                    if( !jQuery('#' + font_id).length ){
                        jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ font.name.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                    }
                });
            }
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            var stageIndex = 0;
            function afterLoadStage(){
                $scope.onloadTemplate = false;
                $scope.contextAddLayers = 'normal';
                $scope.toggleStageLoading();
                $scope.afterInsertTemplate();
            }
            function loadStage(stageIndex){
                if( angular.isUndefined($scope.stages[stageIndex]) || stageIndex >= $scope.stages.length ){
                    if( stageIndex >= $scope.stages.length ) afterLoadStage();
                    return;
                }
                var _index = 'frame_' + stageIndex,
                stage = $scope.stages[stageIndex],
                _canvas = stage['canvas'],
                layerIndex = 0;
                if( angular.isUndefined(design[_index]) ){
                    stageIndex++;
                    loadStage(stageIndex);
                    return;
                }
                stage.states.usedFonts = [];
                _canvas.clear();
                var objects = design[_index].objects;
                if( objects.length == 0 ) {
                    stageIndex++;
                    loadStage(stageIndex);  
                    return;
                }
                var stageLayers = [];
                function loadLayer(layerIndex){
                    function continueLoadLayer(){
                        layerIndex++;
                        if( layerIndex < objects.length ){
                            loadLayer(layerIndex);
                        }else{
                            fitTemplateWithStage();
                            stageIndex++;
                            if( stageIndex < $scope.stages.length ){
                                loadStage(stageIndex);
                            }else{
                                afterLoadStage();
                            }
                        }
                    }
                    function fitTemplateWithStage(){
                        var rec = $scope.fitRectangle(stage.config.width, stage.config.height, design.canvas.width, design.canvas.height, true),
                        factor = rec.width / design.canvas.width;
                        _.each(stageLayers, function(obj){
                            var scaleX = obj.get('scaleX'),
                            scaleY = obj.get('scaleY'),
                            top = obj.get('top'),
                            left = obj.get('left');
                            obj.set({
                                scaleX: scaleX * factor,
                                scaleY: scaleY * factor,
                                left: left * factor + rec.left,
                                top: top * factor + rec.top
                            });
                            obj.setCoords();
                        });
                        $scope.deactiveAllLayer(stageIndex);
                        $scope.renderStage(stageIndex);
                    }
                    function addLayer(_item, callback){
                        _canvas.add(_item);
                        var __item = _canvas.item(_canvas.getObjects().length - 1);
                        if(typeof callback === 'function') callback(__item);
                        stageLayers.push(__item);
                        continueLoadLayer();
                    }
                    var item = objects[layerIndex],
                    type = item.type;
                    if( type === 'image' || type === 'custom-image' ){
                        fabric.Image.fromObject(item, function(_image){
                            addLayer(_image);
                        });
                    }else{
                        var klass = fabric.util.getKlass(type);
                        var is_text = false;
                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                            if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                var layerFont = $scope.getFontInfo(item.fontFamily);
                                stage.states.usedFonts.push(layerFont);
                            };
                            is_text = true;
                        };
                        klass.fromObject(item, function(item){
                            if(is_text){
                                var fontFamily = item.fontFamily,
                                fontWeight = angular.isDefined(item.fontWeight) ? item.fontWeight : '',
                                fontStyle = angular.isDefined(item.fontStyle) ? item.fontStyle : '',
                                _font = $scope.getFontInfo(fontFamily); 
                                item.set({objectCaching: false});
                                var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                                font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                                    fabric.util.clearFabricFontCache();
                                    addLayer(item, function(__item){
                                        __item.initDimensions();
                                        __item.setCoords();
                                    });
                                }, function () {
                                    console.log('Error load font: '+fontFamily);
                                    addLayer(item);
                                });
                            }else{
                                addLayer(item);
                            }
                        });
                    }
                }
                loadLayer(layerIndex);
            }
            loadStage(stageIndex);
        });
    };
    $scope.getMedia = function(type, context){
        jQuery('#tab-element .loading-photo').show();
        $scope.resource.element.type = type;
        if( $scope.resource.element.type != type || context == 'search' ){
            $scope.resource[type].data = [];
            $scope.resource[type].filter.total = 0;
            $scope.resource[type].filter.currentPage = 1;
        };
        $scope.resource.element.type = type;
        var category = type == 'shape' ? 66 : (type == 'line' ? 78 : 73);
        var search = ( type == 'icon' || type == 'flaticon' || type == 'storyset' ) ? $scope.resource.element.contentSearch : '';
        if( type == 'icon' ){
            if( $scope.resource.icon.filter.currentCat != null ){
                category = $scope.resource.icon.filter.currentCat.id;
            }
            if( search != '' ){
                category = '';
            }
        }
        switch( type ){
            case 'flaticon':
                function getFlaticon(){
                    $http({
                        method: "GET",
                        url: 'https://api.flaticon.com/v3/search/icons/id??q=' + encodeURIComponent( search ) + '&page=' + $scope.resource.flaticon.filter.currentPage + '&limit=' + $scope.resource.flaticon.filter.perPage,
                        headers: {
                            'Authorization': 'Bearer ' + $scope.resource.flaticon.token,
                            'Accept': 'application/json'
                        }
                    }).then(function successCallback(response){
                        var data = response.data;
                        _.each(data.data, function(item, key) {
                            $scope.resource[type].data.push({
                                url: item.images['512'],
                                preview: item.images['128'],
                                name: item.description
                            });
                        });
                        $scope.resource.flaticon.filter.totalPage = Math.ceil( data.metadata.total / $scope.resource.flaticon.filter.perPage );
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                }
                if( $scope.resource.flaticon.token == '' ){
                    NBDDataFactory.get('nbd_get_resource', {type: 'get_flaticon_token'}, function(data){
                        data = JSON.parse(data);
                        if( data.flag == 1 ){
                            $scope.resource.flaticon.token = data.data.token;
                            $scope.resource.flaticon.expires = data.data.expires;
                            getFlaticon();
                        }else{
                            console.log('Fail to load: ' + type);
                        }
                    });
                } else {
                    getFlaticon();
                }
                break;
            case 'storyset':
                $http({
                    method: "GET",
                    url: 'https://stories.freepiklabs.com/api/vectors?order=recent&page=' + $scope.resource[type].filter.currentPage + '&query=' + encodeURIComponent( search ),
                }).then(function successCallback(response){
                    var data = response.data;
                    _.each(data.data, function(item, key) {
                        $scope.resource[type].data.push({
                            url: item.src,
                            preview: item.preview,
                            name: item.illustration.name
                        });
                    });
                    $scope.resource.storyset.filter.totalPage = data.meta.last_page;
                }, function errorCallback(response) {
                    console.log('Fail to load: ' + type);
                });
                break;
            default:
                $http({
                    method: 'GET',
                    url: appConfig.mediaUrl + '/clipart?limit=20&category=' + category + '&search=' + search + '&start=' + ($scope.resource[type].filter.currentPage-1) * 20
                }).then(function successCallback(response){
                    if( angular.isDefined( response.data.cliparts ) ){
                        var data = response.data.cliparts;
                        _.each(data.items, function(item, key) {
                            $scope.resource[type].data.push({
                                url: item.file,
                                name: item.name
                            });
                        });
                        $scope.resource[type].filter.totalPage = data.pagesTotal;
                        if( type == 'icon' && $scope.resource[type].first ){
                            $scope.resource[type].cat = data.categories;
                            $scope.resource[type].first = false;
                            $scope.resource.icon.filter.currentCat = _.filter($scope.resource.icon.cat, { id: '' +category })[0];
                        }
                    }
                }, function errorCallback(response) {
                    console.log('Fail to load: ' + type);
                });
                break;
        }
    };
    $scope.getPhoto = function(type, context){ 
        if( $scope.resource.photo.type != type || context == 'search' ){
            $scope.resource.photo.data = [];
            $scope.resource.photo.filter.total = 0;
            $scope.resource.photo.filter.currentPage = 1;
            jQuery("#tab-photo .tab-scroll").stop().animate({
                scrollTop: jQuery('#tab-photo .main-items').height()
            }, 100);
            jQuery('#nbdesigner-gallery').css('height', 0);
        };
        $scope.resource.photo.type = type;
        if( $scope.resource.photo.type == '' ) return;
        jQuery('#tab-photo .loading-photo').show();
        if( $scope.resource.photo.filter.totalPage == 0 || $scope.resource.photo.filter.currentPage <= $scope.resource.photo.filter.totalPage ){
            switch(type){
                case 'Pixabay':
                    $http({
                        method: 'GET',
                        url: 'https://pixabay.com/api/?safesearch=true&key='+ NBDESIGNCONFIG['nbdesigner_pixabay_api_key'] +'&response_group=high_resolution&image_type=photo&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&q='+encodeURIComponent($scope.resource.photo.photoSearch)
                    }).then(function successCallback(response) {
                        var data = response.data,
                        totalPage = Math.ceil(data.totalHits/$scope.resource.photo.filter.perPage);
                        $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                        _.each(data.hits, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                url: angular.isDefined(val.fullHDURL) ? val.fullHDURL : ( angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL ),
                                preview: val.previewURL,
                                des: '@ ' +val.user
                            });
                        });
                        $scope.afterGetResource('photo');
                    }, function errorCallback(response) {
                        console.log('Pixabay');
                        jQuery('#tab-photo .loading-photo').hide();
                    });
                    break;
                case 'Unsplash':
                    var url = $scope.resource.photo.photoSearch != '' ? 'https://api.unsplash.com/search/photos/?client_id='+ NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] +'&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&query='+encodeURIComponent($scope.resource.photo.photoSearch) : 'https://api.unsplash.com/photos/?client_id='+ NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] +'&per_page=20&page='+$scope.resource.photo.filter.currentPage+'&order_by=latest';
                    $http({
                        method: 'GET',
                        url: url
                    }).then(function successCallback(response) {
                        var data = response.data;
                        if( $scope.resource.photo.photoSearch != '' ){
                            $scope.resource.photo.filter.totalPage = data.total_pages > 10 ? 10 : data.total_pages;
                            var results = data.results;
                        }else{
                            $scope.resource.photo.filter.totalPage = 10;
                            var results = data;
                        }
                        _.each(results, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                url: val.urls.regular,
                                preview: val.urls.thumb,
                                des: '@ '+val.user.name
                            });
                        });
                        $scope.afterGetResource('photo');
                    }, function errorCallback(response) {
                        console.log('Unsplash');
                        jQuery('#tab-photo .loading-photo').hide();
                    }); 
                    break;
                case 'Pexels':
                    var url = $scope.resource.photo.photoSearch != '' ? 'https://api.pexels.com/v1/search?query=' + encodeURIComponent( $scope.resource.photo.photoSearch ) + '&per_page='+$scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage : 'https://api.pexels.com/v1/curated?' + 'per_page=' + $scope.resource.photo.filter.perPage + '&page='+$scope.resource.photo.filter.currentPage;
                    $http({
                        method: 'GET',
                        url: url,
                        headers: {
                            'Authorization': NBDESIGNCONFIG['nbdesigner_pexels_api_key']
                        }
                    }).then(function successCallback(response) {
                        var data = response.data,
                        totalPage = angular.isDefined(data.total_results) ? Math.ceil(data.total_results/$scope.resource.photo.filter.perPage) : 1;
                        $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                        _.each(data.photos, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                url: val.src.large,
                                preview: val.src.tiny,
                                des: '@ ' +val.photographer
                            });
                        });
                        $scope.afterGetResource('photo');
                    }, function errorCallback(response) {
                        console.log('Pexels');
                        jQuery('#tab-photo .loading-photo').hide();
                    }); 
                    break;
                case 'Freepik':
                    var src = 'https://wepik.com/api/images/freepik?query=' + encodeURIComponent( $scope.resource.photo.photoSearch ) + '&page=' + $scope.resource.photo.filter.currentPage;
                    
                    NBDDataFactory.get('test_free_pick', {'src': src}, function(data){
                        var data = JSON.parse(data);
                        totalPage = data.data.length;
                        $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                        _.each(data.data, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                url: val.url,
                                preview: val.preview,
                                des: 'Freepik'
                            });
                        });
                        $scope.afterGetResource('photo');
                    });
                    break;
            }
        };
        $scope.updateApp();
    };
    $scope.getPersonalPhoto = function(type, dataObj){
        jQuery('#tab-photo .loading-photo').show();
        switch(type){
            case 'dropbox':
                _.each(dataObj, function(file, index){
                    $scope.resource.dropbox.data.push({
                        extenal: 1,
                        id : file.id,
                        preview : file.link,
                        url : file.link,
                        des: file.name
                    });
                });
                $scope.resource.dropbox.data = _.uniqBy($scope.resource.dropbox.data, 'id');
                $scope.resource.dropbox.filter.total = $scope.resource.dropbox.data.length;
                jQuery('#tab-photo .loading-photo').hide();
                break;
            case 'instagram':
                var endpointUrl = 'https://graph.instagram.com/me/media/?fields=id,media_type,media_url' + '&access_token=' + $scope.resource.instagram.token;
                $http({method: 'GET', url: endpointUrl}).then(function successCallback(response) {
                    _.each(response.data.data, function(file, index){
                        if( file.media_type == 'IMAGE' ){
                            $scope.resource.instagram.data.push({
                                extenal: 1,
                                id : file.id,
                                preview : file.media_url,
                                url : file.media_url,
                                des: ''
                            });
                        }
                    });
                    $scope.resource.instagram.filter.total = $scope.resource.instagram.data.length;
                    jQuery('#tab-photo .loading-photo').hide();
                }, function errorCallback(response) {
                    jQuery('#tab-photo .loading-photo').hide();
                });
                break;
            case 'facebook':
                $scope.resource.facebook.uid = angular.isDefined(dataObj) ? dataObj[0] : $scope.resource.facebook.uid;
                $scope.resource.facebook.accessToken = angular.isDefined(dataObj) ? dataObj[1] : $scope.resource.facebook.accessToken;
                $scope.resource.facebook.nextUrl = $scope.resource.facebook.nextUrl == '' ? "https://graph.facebook.com/v5.0/" + $scope.resource.facebook.uid + "/photos/uploaded/?limit="+$scope.resource.facebook.filter.perPage+"&fields=source,images,link&access_token=" + $scope.resource.facebook.accessToken : $scope.resource.facebook.nextUrl;
                $http({method: 'GET', url: $scope.resource.facebook.nextUrl}).then(function successCallback(response) {
                    var data = response.data;
                    _.each(data.data, function(file, index){
                        $scope.resource.facebook.data.push({
                            extenal: 1,
                            id :  file.id,
                            preview :  file.images[file.images.length - 1].source,
                            url : file.source,
                            des: '@ Facebook'
                        });
                    });
                    $scope.resource.facebook.data = _.uniqBy($scope.resource.facebook.data, 'id');
                    $scope.resource.facebook.filter.total = $scope.resource.facebook.data.length;  
                    if (data.paging && data.paging.next) {
                        $scope.resource.facebook.nextUrl = data.paging.next;
                        $scope.resource.facebook.filter.total += 1;
                    };
                    jQuery('#tab-photo .loading-photo').hide();
                }, function errorCallback(response) {
                    console.log('loadFacebookPhotos');
                    jQuery('#tab-photo .loading-photo').hide();
                });
                break;
        }
    };
    $scope.getInstagramAccessToken = function(){
        $scope.toggleStageLoading();
        NBDDataFactory.get('nbd_get_instagram_token', {code: $scope.resource.instagram.code}, function(data){
            var data = JSON.parse(data);
            if( data.flag == 1 ){
                $scope.resource.instagram.token = data.access_token;
                $scope.resource.instagram.uid = data.user_id;
                $scope.getPersonalPhoto( 'instagram' );
                setCookie( 'nbd_instagram_token', $scope.resource.instagram.token, 1/25 );
            }
            $scope.toggleStageLoading();
        });
    };
    $scope.authenticateInstagram = function(){
        $scope.resource.instagram.token = getCookie( 'nbd_instagram_token' ); 
        if( $scope.resource.instagram.token != '' ){
            $scope.getPersonalPhoto( 'instagram' );
        }else{
            var popupLeft = (window.screen.width - 700) / 2,
                popupTop = (window.screen.height - 500) / 2;
            var url = 'https://api.instagram.com/oauth/authorize?client_id='+NBDESIGNCONFIG['nbdesigner_instagram_app_id']+'&scope=user_profile,user_media&redirect_uri='+NBDESIGNCONFIG['instagram_redirect_uri']+'&response_type=code';
            var popup = window.open(url, '_blank', 'width=700,height=500,left='+popupLeft+',top='+popupTop+'');
            popup.onload = new function() {
                if(window.location.hash.length == 0) {
                    popup.open(url, '_self');
                };
                var interval = setInterval(function () {
                    try {
                        var url = new URL( popup.location.href ),
                        code = url.searchParams.get("code");
                        if ( code ) {
                            clearInterval( interval );
                            $scope.resource.instagram.code = code;
                            popup.close();
                            $scope.getInstagramAccessToken();
                        }
                    } catch (evt) {}
                }, 100);
            }
        }
    };
    $scope.logoutInstagram = function(){
        setCookie( 'nbd_instagram_token', '', -1/25 );
        $scope.resource.instagram.token = '';
        $scope.resource.instagram.data = [];
        $scope.resource.instagram.filter.currentPage = 1;
        $scope.resource.instagram.filter.total = 0;
        jQuery("#tab-photo .tab-scroll").stop().animate({
            scrollTop: jQuery('.main-items').height()
        }, 100);
    };
    $scope.afterGetResource = function(type){
        switch(type){
            case 'clipart':
                if( $scope.resource.clipart.data.cat.length == 0 ) $scope.resource.clipart.data.cat = [{id: "0", name: NBDESIGNCONFIG.nbdlangs.cliparts}];
                if( angular.isDefined(NBDESIGNCONFIG.product_data.option.art_cats) ){
                    $scope.resource.clipart.data.cat = $scope.resource.clipart.data.cat.filter(function(cat){
                        var cid = cat.id;
                        return NBDESIGNCONFIG.product_data.option.art_cats.indexOf(cid) > -1 || NBDESIGNCONFIG.product_data.option.art_cats.indexOf("" + cid) > -1;
                    });
                };
                if( angular.isDefined( $scope.settings.nbes_enable_settings ) && $scope.settings.nbes_enable_settings.clipart == 1 
                        && angular.isDefined( $scope.settings.nbes_settings ) && angular.isDefined( $scope.settings.nbes_settings.clipart_cats ) ){
                    $scope.resource.clipart.data.cat = $scope.resource.clipart.data.cat.filter(function(cat){
                        var cid = cat.id;
                        return $scope.settings.nbes_settings.clipart_cats.indexOf(cid) > -1 || $scope.settings.nbes_settings.clipart_cats.indexOf("" + cid) > -1;
                    });
                }
                _.each($scope.resource.clipart.data.cat, function(cat, key) {
                    cat.amount = 0;
                    _.each($scope.resource.clipart.data.arts, function(art, k) {
                        art.url = art.url.indexOf("http") > -1 ? art.url : NBDESIGNCONFIG['art_url'] + art.url;
                        if (art.cat.length == 0) art.cat = ["0"];
                        if ( _.includes(art.cat, cat.id) || _.includes(art.cat, "" + cat.id) ) cat.amount++
                    });
                });
                $scope.resource.clipart.data.cat = _.sortBy($scope.resource.clipart.data.cat, 'name');
                if( $scope.resource.clipart.data.cat.length ){
                    $scope.resource.clipart.filter.currentCat = $scope.resource.clipart.data.cat[0];
                    $scope.resource[type].filter.total = $scope.resource.clipart.filter.currentCat.amount;
                }else{
                    $scope.resource.clipart.filter.currentCat = -1;
                    $scope.resource.clipart.filter.currentPage = 0;
                    $scope.resource[type].filter.total = 0;
                }
                jQuery('#tab-svg').removeClass('nbd-onload');
                break;
            case 'photo':
                if( $scope.resource.photo.data.length == 0 ) jQuery('#tab-photo .loading-photo').hide();
                $scope.resource.photo.filter.total = $scope.resource.photo.filter.totalPage * $scope.resource.photo.filter.perPage;
                break;
        }


        /*NBDesigner Advanced*/
        if (type == 'background'){
            if( $scope.resource.background.data.cat.length == 0 ) $scope.resource.background.data.cat = [{id: "0", name: NBDESIGNCONFIG.nbdlangs.backgrounds}];
            _.each($scope.resource.background.data.cat, function(cat, key) {
                cat.amount = 0;
                _.each($scope.resource.background.data.backgrounds, function(background, k) {
                    background.url = background.url.indexOf("http") > -1 ? background.url : NBDESIGNCONFIG['background_url'] + background.url;
                    if (background.cat.length == 0) background.cat = ["0"];
                    if ( _.includes(background.cat, cat.id) ) cat.amount++
                });
            });
            $scope.resource.background.data.cat = _.sortBy($scope.resource.background.data.cat, 'name');
            if( $scope.resource.background.data.cat.length ){
                $scope.resource.background.filter.currentCat = $scope.resource.background.data.cat[0];
                $scope.resource[type].filter.total = $scope.resource.background.filter.currentCat.amount;
            }else{
                $scope.resource.background.filter.currentCat = -1;
                $scope.resource.background.filter.currentPage = 0;
                $scope.resource[type].filter.total = 0;
            }
            jQuery('#tab-background').removeClass('nbd-onload');
        }
        

    };
    $scope.changeCat = function(type, cat){
        $scope.resource[type].filter.search = '';
        $scope.resource[type].filter.currentPage = 1;
        $scope.resource[type].filter.currentCat = cat;
        $scope.resource[type].filter.total = cat.amount ? cat.amount : cat.total;
        $scope.updateApp();
        switch(type){
            case 'clipart':
                jQuery("#tab-svg .tab-scroll").stop().animate({
                    scrollTop: 0
                }, 100);
                break;
            case 'icon':
                $scope.resource.element.contentSearch = '';
                jQuery("#tab-element .tab-scroll").stop().animate({
                    scrollTop: 0
                }, 100);
                jQuery("#tab-element .tab-scroll").perfectScrollbar('update');
                jQuery("#tab-element .tab-scroll .result-loaded .type-icons .mansory-wrap").css('height', 0);
                $scope.getMedia('icon', 'search');
                break;
        };

        /*NBDesigner Advanced*/
        if (type == 'background'){
            jQuery("#tab-background .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);
        }

    };
    /* Change printing options */
    $scope.onLoadPrintingOptions = false;
    $scope.firstTimeLoadPrintingOptions = true;
    $scope.awaitInsertTemplate = false;
    $scope.awaitSubmitForm = false;
    $scope.lastPrintingOptions = {};
    $scope.onChangePrintingOptions = false;
    $scope.applyOptions = function(){
        jQuery('.nbd-popup.popup-nbo-options .close-popup').triggerHandler('click');
        if( angular.isDefined( NBDESIGNCONFIG.force_hide_option ) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1' ) {
            $scope.awaitSubmitForm = true;
            if( angular.isDefined( nbd_window.nbOption ) ){
                var hasOdOption = false;
                angular.forEach(nbd_window.nbOption.odOption, function(option){
                    hasOdOption = true;
                });
                if( !hasOdOption ){
                    $scope.saveData();
                }
            }else{
                $scope.saveData();
            }
        };
        $scope.changePrintingOptions();
    };
    $scope.changePrintingOptions = function( first, initVariationSetting ){
        if( $scope.onloadVariation ) return;
        jQuery('.cannot-start-design-notice').removeClass('nbd-show');
        if( angular.isDefined( nbd_window.nbOption ) ){
            if($scope.firstTimeLoadPrintingOptions){
                //if( NBDESIGNCONFIG['ui_mode'] == 1 || $scope.settings.nbdesigner_display_product_option == '2' ){
                    if( $scope.completedInsertTemplate ){
                        $scope.firstTimeLoadPrintingOptions = false;
                        $scope.awaitInsertTemplate = false;
                    }else{
                        $scope.awaitInsertTemplate = true;
                        return;
                    }
                //} else {
                //    $scope.firstTimeLoadPrintingOptions = false;
                //}
            }
            if( angular.equals( nbd_window.nbOption.odOption, $scope.lastPrintingOptions ) ){
                if( !initVariationSetting ){
                    if( angular.isUndefined(first) && angular.isDefined( nbd_window.nbOption.extraOdOption ) ){
                        $scope.changeExtraOdOptions();
                        $scope.updateApp();
                    }
                    return;
                }
            }else{
                angular.copy( nbd_window.nbOption.odOption, $scope.lastPrintingOptions );
            }
            var data = nbd_window.nbOption.odOption;
            if( angular.isUndefined( $scope.stored_product ) || initVariationSetting ){
                $scope.stored_product = [];
                angular.copy($scope.settings.product_data.product, $scope.stored_product);
            }else{
                $scope.settings.product_data.product = [];
                angular.copy($scope.stored_product, $scope.settings.product_data.product);
            };
            $scope.settings.product_data.option.option_dpi = false;
            if( angular.isDefined( data.dpi ) ){
                $scope.settings.product_data.option.dpi = data.dpi;
                $scope.settings.product_data.option.option_dpi = true;
            }
            if( angular.isDefined( data.page ) ){
                $scope.currentStage = 0;
                var number_side = $scope.settings.product_data.product.length;
                if( angular.isDefined( data.page.list_page ) ){
                    if( data.page.list_page.length > 0 ){
                        $scope.settings.product_data.product = [];
                        angular.forEach(data.page.list_page, function(side, key){
                            if( angular.isDefined( $scope.stored_product[side] ) ){
                                $scope.settings.product_data.product.push( $scope.stored_product[side] )
                            }else if( angular.isDefined( $scope.settings.product_data.product[number_side - 1] ) ){
                                var temp = angular.copy($scope.settings.product_data.product[number_side - 1], temp);
                                $scope.settings.product_data.product.push(temp);
                            }
                        });
                        if( $scope.settings.product_data.product.length == 0 ){
                            angular.copy($scope.stored_product, $scope.settings.product_data.product);
                        }
                    }else{
                        jQuery('.cannot-start-design-notice').addClass('nbd-show');
                        return;
                    }
                }else{
                    var number_side = $scope.settings.product_data.product.length;
                    var src_side_index = number_side - 1,
                        insert_side_index = number_side - 1,
                        dst_number_side = data.page.number,
                        lastJsonDesign = {},
                        _canvas = $scope.stages[src_side_index]['canvas'];
                    _canvas.requestRenderAll();
                    lastJsonDesign = _canvas.toJSON($scope.includeExport);
                    angular.copy($scope.stored_product, $scope.settings.product_data.product);
                    if( data.page.page_display == '1' ){
                        if( data.page.exclude_page == '2' ){
                            if( number_side > 2 ){
                                src_side_index = number_side - 2;
                                insert_side_index = number_side - 2;
                            }
                            dst_number_side += 2;
                        }
                    } else {
                        if( data.page.exclude_page == '2' ){
                            dst_number_side = Math.ceil( dst_number_side / 2 ) + 1;
                        } else {
                            dst_number_side = Math.ceil( dst_number_side / 2 );
                        }
                    }
                    if( dst_number_side < number_side ){
                        $scope.settings.product_data.product.splice(dst_number_side - 1, number_side - dst_number_side);
                        for(i = dst_number_side; i < number_side; i++){
                            delete $scope.resource.jsonDesign['frame_' + dst_number_side];
                        }
                    }else if( dst_number_side > number_side ){
                        var i;
                        for(i = 0; i < dst_number_side - number_side; i++){
                            var temp = {};
                            angular.copy($scope.settings.product_data.product[src_side_index], temp);
                            if( data.page.page_display == '1' && data.page.exclude_page == '2' ) temp.orientation_name = NBDESIGNCONFIG.nbdlangs.page + ' ' + insert_side_index;
                            $scope.settings.product_data.product.splice(insert_side_index, 0, temp);
                            insert_side_index++;
                        }
                    }
                    $scope.stored_product = [];
                    angular.copy($scope.settings.product_data.product, $scope.stored_product);
                }
            }
            if( angular.isDefined( data.color ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    delete side.pattern;
                    if(data.color.bg_type == 'c'){
                        side.bg_type = 'color';
                        side.bg_color_value = data.color.bg_color;
                    }else{
                        side.bg_type = 'image';
                        if( angular.isDefined(data.page) && angular.isDefined( data.page.list_page ) ){
                            if( angular.isDefined( data.page.list_page[key] ) ){
                                var _key = data.page.list_page[key];
                                if( angular.isDefined(data.color.bg_image[_key]) ) side.img_src = data.color.bg_image[_key];
                            }
                        }else{
                            if( angular.isDefined(data.color.bg_image[key]) ) side.img_src = data.color.bg_image[key];
                        }
                    }
                });
            }
            if( angular.isDefined( data.size ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.product_height = data.size.product_height;
                    side.product_width = data.size.product_width;
                    side.real_width = data.size.real_width;
                    side.real_height = data.size.real_height;
                    side.real_left = data.size.real_left;
                    side.real_top = data.size.real_top;
                    ['bleed_top_bottom', 'bleed_left_right', 'margin_top_bottom', 'margin_left_right'].map(function (att) {
                        if (angular.isDefined(data.size[att])) {
                            side[att] = data.size[att];
                        }
                    });
                    var ratio = side.product_width / side.product_height;
                    side.img_src_top = side.img_src_left = 0;
                    if(ratio > 1){
                        side.img_src_width = 500;
                        side.area_design_width = side.real_width / side.product_width * 500;
                        side.area_design_height = side.real_height / side.product_width * 500;
                        side.img_src_height = 500 / ratio;
                        side.img_src_top = (500 - side.img_src_height) / 2;
                        side.area_design_left = side.real_left / side.product_width * 500;
                        side.area_design_top = side.real_top / side.product_width * 500 + side.img_src_top;
                    }else{
                        side.img_src_height = 500;
                        side.area_design_height = side.real_height / side.product_height * 500;
                        side.area_design_width = side.real_width / side.product_height * 500;
                        side.img_src_width = 500 * ratio;
                        side.img_src_left = (500 - side.img_src_width) / 2;
                        side.area_design_left = side.real_left / side.product_height * 500 + side.img_src_left;
                        side.area_design_top = side.real_top / side.product_height * 500;
                    }
                });
            }
            if( angular.isDefined( data.dimension ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.product_height = data.dimension.height;
                    side.product_width = data.dimension.width;
                    side.real_width = data.dimension.width;
                    side.real_height = data.dimension.height;
                    side.real_left = side.real_top = side.img_src_top = side.img_src_left = side.area_design_left = side.area_design_top = 0;
                    var ratio = side.product_width / side.product_height;
                    if(ratio > 1){
                        side.img_src_width = 500;
                        side.area_design_width = 500;
                        side.img_src_height = 500 / ratio;
                        side.area_design_height = 500 / ratio;
                        side.img_src_top = (500 - side.img_src_height) / 2;
                        side.area_design_top = side.img_src_top;
                    }else{
                        side.img_src_height = 500;
                        side.area_design_height = 500;
                        side.img_src_width = 500 * ratio;
                        side.area_design_width = 500 * ratio;
                        side.img_src_left = (500 - side.img_src_width) / 2;
                        side.area_design_left = side.img_src_left;
                    }
                });
            }
            if( angular.isDefined( data.orientation ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    var productWidth = parseFloat(side.product_width), productHeight = parseFloat(side.product_height);
                    if( ( data.orientation == 1 && productWidth < productHeight ) || ( data.orientation == 0 && productHeight < productWidth ) ){
                        var tem = 1 * side.product_width;
                        side.product_width = 1 * side.product_height;
                        side.product_height = tem;
                        tem = 1 * side.img_src_width;
                        side.img_src_width = 1 * side.img_src_height;
                        side.img_src_height = tem;
                        tem = 1 * side.real_width;
                        side.real_width = 1 * side.real_height;
                        side.real_height = tem;
                        tem = 1 * side.img_src_top;
                        side.img_src_top = 1 * side.img_src_left;
                        side.img_src_left = tem;
                        tem = 1 * side.area_design_width;
                        side.area_design_width = 1 * side.area_design_height;
                        side.area_design_height = tem;
                        tem = 1 * side.bleed_top_bottom;
                        side.bleed_top_bottom = 1 * side.bleed_left_right;
                        side.bleed_left_right = tem;
                        tem = 1 * side.margin_top_bottom;
                        side.margin_top_bottom = 1 * side.margin_left_right;
                        side.margin_left_right = tem;
                        if( data.orientation == 1 ){
                            tem = side.real_left;
                            side.real_left = side.real_top;
                            side.real_top = side.product_height - side.real_height - tem;
                        }else{
                            tem = side.real_top;
                            side.real_top = side.real_left;
                            side.real_left = side.product_width - side.real_width - tem;
                        }
                        side.area_design_top = side.img_src_top + side.real_top / side.product_width * side.img_src_width;
                        side.area_design_left = side.img_src_left + side.real_left / side.product_width * side.img_src_width;
                    }
                });
            }
            if( angular.isDefined( data.area ) ){
/*                 angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.area_design_type = data.area;
                }); */
                $timeout(function(){
                    var _canvas = $scope.stages[0].canvas,
                    width = _canvas.width,
                    height = _canvas.height;
                    if( data.area == 2 ){
                        nbd_window.nbOption.extraOdOption.shape = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 ' + width + ' ' + height + '" ><path fill="rgba(0,0,0,0.001)" d="M0 ' + height/2 + 'A ' + width/2 + ' ' + height/2 + ' 0 0 0 ' + width + ' ' + height/2 + ' A ' + width/2 + ' ' + height/2 + ' 0 0 0 0 ' + height/2 + 'z"/></svg>';
                    }else{
                        nbd_window.nbOption.extraOdOption.shape = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 ' + width + ' ' + height + '" ><path fill="rgba(0,0,0,0.001)" d="M0 0 H'+width+' V'+height+' H0 V0z"/></svg>';
                    }
                    $scope.changeExtraOdOptions();
                }, 1000);
            }
            if( angular.isDefined( data.padding ) ){
                var padding = parseFloat(data.padding);
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.product_height = 2 * padding + parseFloat(side.product_height);
                    side.product_width = 2 * padding + parseFloat(side.product_width);
                    side.real_left = padding + parseFloat(side.real_left);
                    side.real_top = padding + parseFloat(side.real_top);
                    var ratio = side.product_width / side.product_height;
                    if(ratio > 1){
                        side.img_src_width = 500;
                        side.area_design_width = side.real_width / side.product_width * 500;
                        side.area_design_height = side.real_height / side.product_width * 500;
                        side.img_src_height = 500 / ratio;
                        side.img_src_left = 0;
                        side.img_src_top = (500 - side.img_src_height) / 2;
                        side.area_design_left = side.real_left / side.product_width * 500;
                        side.area_design_top = side.real_top / side.product_width * 500 + side.img_src_top;
                    }else{
                        side.img_src_height = 500;
                        side.area_design_height = side.real_height / side.product_height * 500;
                        side.area_design_width = side.real_width / side.product_height * 500;
                        side.img_src_width = 500 * ratio;
                        side.img_src_top = 0;
                        side.img_src_left = (500 - side.img_src_width) / 2;
                        side.area_design_left = side.real_left / side.product_height * 500 + side.img_src_left;
                        side.area_design_top = side.real_top / side.product_height * 500;
                    }
                });
            }
            if( angular.isUndefined(first) ){
                $scope.saveDesign();
                if( angular.isDefined( data.page ) && angular.isUndefined( data.page.list_page ) && data.page.page_display == '1' && data.page.exclude_page == '2' ){
                    if( angular.isDefined( $scope.resource.jsonDesign['frame_' + ( number_side - 1 )] ) ){
                        $scope.resource.jsonDesign['frame_' + ( number_side - 1 )] = {
                            objects: [],
                            version: lastJsonDesign.version
                        };
                    }
                    $scope.resource.jsonDesign['frame_' + ( dst_number_side - 1 )] = {};
                    angular.copy( lastJsonDesign, $scope.resource.jsonDesign['frame_' + ( dst_number_side - 1 )] );
                }
                appConfig.ready = false;
/*                 if( angular.isDefined( data.area ) ){
                    $scope.forceInitStage = true;
                }else{ */
                    $scope.settings.product_data.config = {};
                    $scope.settings.product_data.config.viewport = $scope.viewPort;
                    $scope.settings.product_data.fonts = $scope.resource.usedFonts;
                    $scope.preventChangeCurrentDesign = true;
                    $scope.needLoadVariationDesign();
                    if( !$scope.forceLoadVariationDesign ) $scope.settings.product_data.design = $scope.resource.jsonDesign;
                //};
                $scope.currentStage = 0;
                $scope.onChangePrintingOptions = true;
                $scope.processProductSettings();
                $scope.changeExtraOdOptions();
                $scope.updateApp();
            }
        }
    };
    $scope.changeExtraOdOptions = function(){
        if( $scope.onloadVariation ) return;
        if( angular.isDefined( nbd_window.nbOption ) && angular.isDefined( nbd_window.nbOption.extraOdOption ) ){
            var data = nbd_window.nbOption.extraOdOption;
            if( angular.isDefined( data.rounded_corner ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.bleed_radius = parseFloat( data.rounded_corner );
                    side.safezone_radius = parseFloat( data.rounded_corner ) - side.margin_left_right;
                    if( side.safezone_radius < 0 ) side.safezone_radius = 0;
                    if( side.bleed_radius != 0 ){
                        $scope.stages[key].config.bleed_radius = $scope.stages[key].config.cwidth * side.bleed_radius / side.product_width;
                        $scope.stages[key].config.safezone_radius = $scope.stages[key].config.cwidth * side.safezone_radius / side.product_width;
                    }else{
                        delete $scope.stages[key].config.bleed_radius;
                        delete $scope.stages[key].config.safezone_radius;
                    }
                });
            }
            if( angular.isDefined( data.overlay ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    if( angular.isDefined( data.overlay[key] ) && data.overlay[key] != '' ){
                        side.img_overlay = data.overlay[key];
                        $scope.stages[key].config.img_overlay = data.overlay[key];
                    }
                });
            }
            if( angular.isDefined( data.fold ) ){
                var foldClass = '',
                    fold      = false,
                    numberPanel = 1;
                switch( data.fold ){
                    case 'n':
                        fold = false;
                        break;
                    case 'h':
                        foldClass = 'single f2';
                        numberPanel = 2;
                        fold = true;
                        break;
                    case 't':
                        foldClass = 'single f3';
                        numberPanel = 3;
                        fold = true;
                        break;
                    case 'z':
                        foldClass = 'single f3';
                        numberPanel = 3;
                        fold = true;
                        break;
                    case 's':
                        foldClass = 'single f3_2';
                        numberPanel = 3;
                        fold = true;
                        break;
                    case 'd':
                        foldClass = 'single f4';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'dp':
                        foldClass = 'single f4';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'dr':
                        foldClass = 'single f4';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'r':
                        foldClass = 'single f4';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'a':
                        foldClass = 'single f4';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'hh':
                        foldClass = 'double f2';
                        numberPanel = 4;
                        fold = true;
                        break;
                    case 'ht':
                        foldClass = 'double f3';
                        numberPanel = 6;
                        fold = true;
                        break;
                }
                $scope.resource.config.fold = fold;
                $scope.resource.config.foldClass = foldClass;
                $scope.resource.config.numberPanel = numberPanel;
            }
            if( angular.isDefined( data.pattern ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    if(data.pattern.type == 'c'){
                        side.pattern = {
                            type: 'color',
                            color: data.pattern.color
                        };
                    }else{
                        side.pattern = {
                            type: 'image',
                            src: data.pattern.bg_image[key]
                        };
                        jQuery('.sticker-contour-pattern-wrap svg pattern image').attr('xlink:href', data.pattern.bg_image[key]);
                    }
                });
            }
            if( angular.isDefined( data.shape ) ){
                angular.forEach($scope.settings.product_data.product, function(side, key){
                    $scope.changeAreaDesignShape( key, data.shape );
                });
            }
            $scope.afterChangeExtraOdOptions();
        }
    };
    $scope.afterChangeExtraOdOptions = function(){};
    $scope.needLoadVariationDesign = function(){
        $scope.forceLoadVariationDesign = false;
        if( NBDESIGNCONFIG.product_type == 'variable' && NBDESIGNCONFIG['variation_id'] != 0 && NBDESIGNCONFIG['ui_mode'] == 2 && NBDESIGNCONFIG['task'] == 'new' ){
            var hasDesign = false;
            _.each($scope.stages, function(stage, index){
                var _canvas = stage.canvas;
                if( _canvas && _canvas.getObjects().length > 0 ) hasDesign = true;
            });
            if( !hasDesign ) {
                $scope.forceLoadVariationDesign = true;
                $scope.preventChangeCurrentDesign = false;
                return true;
            }
        }
        return false;
    };
    $scope.onloadVariation = false;
    $scope.initVariationSetting = false;
    $scope.preventChangeCurrentDesign = false;
    $scope.forceLoadVariationDesign = false;
    $scope.changeVariation = function(){
        if( $scope.onloadVariation ) return;
        if( angular.isDefined( NBDESIGNCONFIG.force_hide_option ) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1' ) {
            return;
        }
        $scope.onloadVariation = true;
        $scope.toggleStageLoading();
        $scope.saveDesign();
        appConfig.ready = false;
        $scope.preventChangeCurrentDesign = true;
        $scope.needLoadVariationDesign();
        NBDDataFactory.get('nbdesigner_get_product_info', {product_id: NBDESIGNCONFIG['product_id'], variation_id: NBDESIGNCONFIG['variation_id'], need_templates: 1}, function(data){
            $scope.toggleStageLoading();
            $scope.onloadVariation = false;
            $scope.initVariationSetting = true;
            if( NBDESIGNCONFIG['ui_mode'] == 1 ) nbd_window.NBDESIGNERPRODUCT.nbdesigner_ready();
            $scope.settings.product_data = JSON.parse(data);
            if( angular.isDefined($scope.settings.product_data.templates) ){
                $scope.resource.templates = $scope.settings.product_data.templates;
                if( angular.isDefined($scope.settings.product_data.templates) ){
                    $scope.resource.templates = $scope.settings.product_data.templates;
                    if( angular.isDefined( $scope.settings.product_data.templates.template_tags ) ){
                        $scope.settings.template_tags = $scope.settings.product_data.templates.template_tags;
                        if( $scope.settings.template_tags.length > 0 ){
                            $scope.resource.customTemplates = [];
                            $scope.settings.template_tags.forEach(function( tag ){
                                $scope.resource.customTemplates[tag.id] = {
                                    limit: 0,
                                    total: tag.templates.length
                                }
                            });
                        }
                    }
                    $scope.updateApp();
                    $timeout(function(){
                        window.modern.sideBar.tabProductTemplate();
                    });
                }
            }
            if( !$scope.forceLoadVariationDesign ) $scope.settings.product_data.design = $scope.resource.jsonDesign;
            $scope.settings.product_data.config = {};
            $scope.settings.product_data.config.viewport = $scope.viewPort;
            $scope.settings.product_data.fonts = $scope.resource.usedFonts;
            if( angular.isDefined( nbd_window.nbOption ) ){
                var und;
                $scope.changePrintingOptions( und, true );
            } else {
                $scope.processProductSettings();
            }
        });
    };
    $scope.loadedPrintingOptions = false;
    $scope.widthoutPrintingOptions = false;
    $scope.getPrintingOptions = function(){
        if( $scope.settings.nbdesigner_display_product_option == '1' ){
            jQuery('.nbd-popup.popup-nbo-options').nbShowPopup();
        }
        if(!$scope.loadedPrintingOptions){
            if( angular.isDefined( NBDESIGNCONFIG.force_hide_option ) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1' ) {
                jQuery('.nbd-popup.popup-nbo-options .close-popup').triggerHandler('click');
            }
            $http({
                method: 'GET',
                url: $scope.settings.link_get_options
            }).then(function(response){
                $scope.loadedPrintingOptions = true;
                var container = jQuery('#nbo-options-wrap');
                container.append(response.data);
                jQuery(document).trigger('nbo_get_option_success');
                /* Compare with other color swatches plugins */
                jQuery('.variation-selector').removeClass('hidden').show();
                jQuery('.nbtcs-swatches').addClass('hidden');
                if( jQuery('.nbo-wrapper').length == 0 ){
                    $scope.widthoutPrintingOptions = true;
                    if( jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0 ){
                        $scope.printingOptionsAvailable = true;
                    }
                    jQuery('.variations_form').on('woocommerce_variation_has_changed wc_variation_form', function(){
                        if( jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0 ){
                            NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
                            $scope.printingOptionsAvailable = true;
                            var _interval = $interval(function(){
                                if( $scope.completedInsertTemplate == true ){
                                    $scope.changeVariation();
                                    $interval.cancel( _interval );
                                }
                            }, 100);
                        }else{
                            $scope.printingOptionsAvailable = false;
                        }
                    });
                    jQuery('.variations_form').on('found_variation found_variation.wc-variation-form', function(){
                        setTimeout(function(){
                            if( jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0 ){
                                NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
                                $scope.printingOptionsAvailable = true;
                                var _interval = $interval(function(){
                                    if( $scope.completedInsertTemplate == true ){
                                        $scope.changeVariation();
                                        $interval.cancel( _interval );
                                    }
                                }, 100);
                            }else{
                                $scope.printingOptionsAvailable = false;
                            }
                        }, 100);
                    });
                }
                if(NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new'){
                    container.find('form.variations_form').append('<input name="submit_form_mode2" type="hidden" value="1" />');
                    container.find('form.cart').append('<input name="submit_form_mode2" type="hidden" value="1" />');
                    container.find('form.cart').append('<input name="add-to-cart" type="hidden" value="'+NBDESIGNCONFIG.product_id+'" />');
                }
                if( NBDESIGNCONFIG.task2 != '' && NBDESIGNCONFIG.task2 != 'update' ){
                    jQuery('.variations_form').addClass('nbd-disabled');
                    jQuery('form.cart').addClass('nbd-disabled');
                }
                jQuery('.nbd-popup.popup-nbo-options .overlay-popup').addClass('nbo-disable');
                jQuery('.single_add_to_cart_button').addClass('nbd-disabled');
                jQuery('.nbd-popup.popup-nbo-options').find('.overlay-main').removeClass('active');
                jQuery('.tab-product .loaded').hide();
                jQuery('.single_add_to_cart_button').hide();
                var newScope = angular.element(container).scope();
                var compile = angular.element(container).injector().get('$compile');
                compile(jQuery(container).contents())(newScope);
                $timeout(function(){
                    container.perfectScrollbar();
                    if(jQuery('#nbo-options-wrap .variations_form').length){
                        jQuery('#nbo-options-wrap .variations_form').wc_variation_form();
                        jQuery('#nbo-options-wrap .variations_form').trigger( 'wc_variation_form' );
                        jQuery('#nbo-options-wrap .variations_form .variations select').change();
                    }
                });
            });
        }
    };
    $scope.searchProductName = '';
    $scope.showProducts = function(){
        jQuery('.nbd-popup.popup-nbd-products').nbShowPopup();
        if( $scope.resource.products.length ) return;
        jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').addClass('active');
        NBDDataFactory.get('nbd_get_nbd_products', {}, function(data){
            jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').removeClass('active');
            var _data = JSON.parse( data );
            if( _data.length && angular.isDefined( _data[0].product_id ) ){
                $scope.resource.products = _data;
            }else{
                jQuery('.nbd-popup.popup-nbd-products .close-popup').triggerHandler('click');
            }
        });
    };
    $scope.getProductInfo = function(){
        jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').addClass('active');
        NBDDataFactory.get('nbd_get_product_description', {product_id: NBDESIGNCONFIG.product_id}, function(data){
            var _data = JSON.parse( data );
            jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').removeClass('active');
        });
    };
    $scope.changeProduct = function( product_id ){
        $scope.switchedProduct = product_id;
        jQuery('.nbd-popup.popup-nbd-products .close-popup').triggerHandler('click');
        $scope.saveData('change-product');
    };
    /* Upload Image */
    $scope.uploadFile = function(files, indexFile){
        indexFile = angular.isDefined(indexFile) ? indexFile : 0;
        if( files.length <= 0 || indexFile > (files.length - 1) || indexFile > (parseInt($scope.settings.nbdesigner_max_upload_files_at_once) - 1) ) return;
        var file = files[indexFile],
        max_size = parseInt($scope.settings.nbdesigner_maxsize_upload),
        min_size = parseInt($scope.settings.nbdesigner_minsize_upload);
        if( ( file.type.indexOf("image") === -1 && file.type.indexOf("pdf") === -1 ) || ( file.type.indexOf("pdf") != -1 && !$scope.settings.is_available_imagick ) ){
            alert( $scope.settings.is_available_imagick ? $scope.settings.nbdlangs.supported_extensions2 : $scope.settings.nbdlangs.supported_extensions );
            return;
        }
        if ( file.size > max_size * 1024 * 1024 ) {
            alert( $scope.settings.nbdlangs.max_file_size + max_size + " MB" );
            return;
        }else if( file.size < min_size * 1024 * 1024 ){
            alert( $scope.settings.nbdlangs.min_file_size + min_size + " MB" );
            return;
        };
        if( file.type.indexOf("svg") > -1 ){
            var reader = new FileReader();
            reader.onload = function(event){
                if (event.target.readyState === 2) {
                    var result = reader.result;
                    $scope.addSvgFromString(result);
                    $scope.uploadFile(files, indexFile + 1);
                }
            };
            reader.readAsText(file);
        }else{
            $scope.toggleStageLoading();
            $scope.resource.upload.progressBar = 0;
            jQuery('.nbd-progress-bar').addClass('active');
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                object = _canvas.getActiveObject();
            if( !!object && !!object.get('maskId') && files.length == 1 ){
                var maskId = object.get('maskId');
            }
            NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function(data){
                var data = JSON.parse(data);
                if( data.flag == 1 ){
                    if( angular.isDefined(data.ilr) ) $scope.resource.upload.ilr = true;
                    if( $scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no' ){
                        $scope.toggleStageLoading();
                        alert(data.mes);
                        $scope.uploadFile(files, indexFile + 1);
                        return;
                    };
                    $scope.storeUploadFile(data, data.name);
                    if( maskId ){
                        $scope.addImage(data, false, true, false, false, maskId);
                    }else{
                        $scope.addImage(data, false, true );
                    }
                    jQuery("#tab-photo .tab-scroll").stop().animate({
                        scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                    }, 100);
                    localStorage.setItem('uploaded', $scope.resource.upload.data);
                    $scope.onEndRepeat('upload');
                    $scope.uploadFile(files, indexFile + 1);
                }else{
                    $scope.toggleStageLoading();
                    alert(data.mes);
                }
                jQuery('.nbd-progress-bar').removeClass('active');
            }, function( progress ){
                $scope.resource.upload.progressBar = progress.toFixed(0);
            });
        }
    };
    $scope.storeUploadFile = function(data, name){
        var src = typeof data == 'object' ? data.src : data;
        var ojb = {
            url: src,
            src: src,
            des: name,
            ilr: $scope.resource.upload.ilr
        };
        if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
            ojb.origin_url      = data.origin_url;
            ojb.src             = src;
            ojb.width           = data.width;
            ojb.height          = data.height;

            if( angular.isDefined( data.origin_pdf ) ){
                ojb.origin_pdf  = data.origin_pdf;
            }
        }

        $scope.resource.upload.data.push( ojb );

        if( $scope.settings.nbdesigner_cache_uploaded_image == 'yes' ){
            $scope._localStorage.save('nbduploaded');
        }
    };
    /* Login */
    $scope.login = function(callback){
        if( $scope.settings.is_logged ){
            if(typeof callback == 'function') callback();
            return;
        }else{
            $scope.toggleStageLoading();
            NBDDataFactory.get('nbd_check_use_logged_in', {type: 'check_login'}, function(data){
                data = JSON.parse(data);
                $scope.toggleStageLoading();
                if( data.is_login == 1 ){
                    NBDESIGNCONFIG['nonce_get'] = data.nonce_get;
                    NBDESIGNCONFIG['nonce'] = data.nonce;
                    if(typeof callback == 'function') callback();
                    return;
                }else{
                    if( checkMobileDevice() ){
                        iframe_src = NBDESIGNCONFIG['login_url'];
                        if( jQuery('.popup-login .main-body iframe').length == 0 ){
                            jQuery('.popup-login .main-body').prepend('<iframe id="nbd-login-frame"  width="100%" height="100%" scrolling="yes" frameborder="0" noresize="noresize" allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" src="'+iframe_src+'"></iframe>');
                            jQuery(document).on('nbd_redirect_login', function( e ){
                                jQuery('.popup-login .overlay-main' ).show();
                            });
                            setTimeout(function(){
                                var interval;
                                jQuery('.popup-login .main-body iframe').on("load", function() {
                                    jQuery('.popup-login .overlay-main' ).hide();
                                    jQuery('.popup-login .main-body iframe').contents().find("head").append("<style>header, footer{display:none;}</style>");
                                    if( interval ) clearInterval(interval);
                                    interval = setInterval(function () {
                                        try {
                                            var location = jQuery('.popup-login .main-body iframe').contents().get(0).location;
                                            if (location.hash.length) {
                                                var hash = location.hash;
                                                var res = hash.split("___");
                                                if(res.length){
                                                    NBDESIGNCONFIG['nonce_get'] = res[0].substr(1);
                                                    NBDESIGNCONFIG['nonce'] = res[1];
                                                }
                                                clearInterval(interval);
                                                $scope.settings['is_logged'] = 1;
                                                jQuery('.popup-login .main-popup .close-popup').triggerHandler('click');
                                                $scope.updateApp();
                                                if(typeof callback == 'function') callback();
                                            }
                                        } catch (evt) {
                                            
                                        }
                                    }, 100);
                                });
                            });
                        };
                        jQuery('.popup-login').nbShowPopup();
                    } else {
                        var popupLeft = (window.screen.width - 700) / 2,
                            popupTop = (window.screen.height - 500) / 2,
                            popup = window.open(NBDESIGNCONFIG['login_url'], '', 'width=700,height=500,left='+popupLeft+',top='+popupTop+'');
                        popup.onload = new function() {
                            if(window.location.hash.length == 0) {
                                popup.open(NBDESIGNCONFIG['login_url'], '_self');
                            }; 
                            var interval = setInterval(function () {
                                try {
                                    if (popup.location.hash.length) {
                                        var hash = popup.location.hash;
                                        var res = hash.split("___");
                                        if(res.length){
                                            NBDESIGNCONFIG['nonce_get'] = res[0].substr(1);
                                            NBDESIGNCONFIG['nonce'] = res[1];
                                        }
                                        clearInterval(interval);
                                        $scope.settings['is_logged'] = 1;
                                        popup.close();
                                        $scope.updateApp();
                                        if(typeof callback == 'function') callback();
                                    }
                                } catch (evt) {
                                    
                                }
                            }, 100);
                        }
                    }
                }
            });
        }
    };
    $scope.stageOnload = false;
    $scope.toggleStageLoading = function( timeout ){
        jQuery('.loading-workflow').toggleClass('nbd-show');
        var container = appConfig.isVisual ? '.nbd-mode-vista' : 'body';
        jQuery(container).toggleClass('nbd-onloading');
        var _timeout = timeout ? timeout : 2E4;
        if( jQuery('.loading-workflow').hasClass('nbd-show') ){
            $scope.stageOnload = true;
            $scope._promise = $timeout(function(){
                if( $scope.stageOnload ){
                    jQuery('.loading-workflow').removeClass('nbd-show');
                    jQuery(container).removeClass('nbd-onloading');
                }
            }, _timeout);
        }else{
            $timeout.cancel($scope._promise);
            $scope.stageOnload = false;
        }
        $scope.updateApp();
    };
    /* Webcam */
    $scope.initWebcam = function(){
        $scope.resource.webcam.status = true;
        var params;
        if( $scope.settings.is_mobile ){
            params = {
                width: 250,
                height: 250,
                dest_width: 1000,
                dest_height: 1000,
                image_format: 'jpeg',
                jpeg_quality: 100,
                constraints: {
                    video: { facingMode: "user" },
                    audio: false,
                    width: { exact: 250 },
                    height: { exact: 250 }
                },
                iosPlaceholderText: $scope.settings.nbdlangs.iosPlaceholderText
            };
        }else{
            params = {
                width: 400,
                height: 300,
                dest_width: 1280,
                dest_height: 960,
                image_format: 'jpeg',
                jpeg_quality: 100,
                constraints: { optional: [{ minWidth: 600 }] }
            };
        }
        Webcam.set(params);
        Webcam.attach( '#my_camera' );
        Webcam.setSWFLocation(NBDESIGNCONFIG['assets_url'] + 'webcam.swf');
    };
    $scope.pauseWebcam = function(status){
        status == true  && Webcam.freeze() || Webcam.unfreeze();
    };
    $scope.resetWebcam = function(){
        if($scope.resource.webcam.status){
            Webcam.reset();
            $scope.resource.webcam.status = false;
        }else{
            $scope.initWebcam();
        }
    };
    $scope.takeSnapshot = function(){
        Webcam.snap( function(data_uri) {
            $scope.resetWebcam();
            var raw_image_data = data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
            NBDDataFactory.get('nbdesigner_save_webcam_image', {image: raw_image_data}, function(data){
                data = JSON.parse(data);
                if(data.flag == 'success'){
                    jQuery('.popup-webcam .close-popup').triggerHandler('click');
                    $scope.toggleStageLoading();
                    $scope.addImage(data.url, false, true);
                }else{
                    alert('Oops! Try again!');
                    $scope.initWebcam();
                }
            });
        });
    };
    $scope.onEndRepeat = function(type){
        switch(type){
            case 'typography':
                $scope.renderMasonryList(type, '.nbd-sidebar .typography-items', '.typography-item', '#tab-typography', $scope.resource[type].init);
                break;
            case 'font':
                jQuery('#toolbar-font-familly-dropdown').perfectScrollbar('update');
                break;
            case 'clipart':
                $scope.renderMasonryList(type, '#tab-svg .clipart-wrap', '.clipart-item', '#tab-svg', $scope.resource[type].init);
                break; 
            case 'photo':
                $scope.renderMasonryList(type, '#tab-photo .nbdesigner-gallery', '.nbdesigner-item', '#tab-photo', $scope.resource[type].init);
                break;
            case 'dropbox':
            case 'instagram':
            case 'facebook':
            case 'upload':
            case 'shape':
            case 'icon':
            case 'line':
            case 'flaticon':
            case 'storyset':
            case 'photoFrame':
                $scope.renderMasonryList(type, '#nbd-'+type+'-wrap .mansory-wrap', '.mansory-item', '#nbd-'+type+'-wrap', $scope.resource[type].init);
                break;
        }

        /*NBDesigner Advanced*/
        if (type == 'background'){
            $scope.renderMasonryList(type, '#tab-background .background-wrap', '.background-item', '#tab-background', $scope.resource[type].init);
        }

    };
    $scope.updateScrollBar = function( jSelector ){
        $timeout(function(){
            jQuery(jSelector).perfectScrollbar('update');
        });
    };
    $scope.renderMasonryList = function(type, container, item, scrollContainer, init){  
        imagesLoaded( jQuery(container), function() {
            if( !init ) jQuery(container).masonry('destroy');
            var $grid = jQuery(container).masonry({
                itemSelector: item
            }); 

            jQuery.each(jQuery(container + ' ' +item), function(e) {
                var animate = Math.floor(Math.random() * 10);
                animate = (animate + 1) * 100;
                if( checkMobileDevice() ){
                    jQuery(this).addClass("in-view");
                }else{
                    jQuery(this).addClass("in-view slideInDown animated animate"+animate);
                }
            }); 
            jQuery(scrollContainer+' .tab-scroll').perfectScrollbar('update');
            $timeout(function(){
                jQuery(scrollContainer + ' .loading-photo').hide();
                jQuery(scrollContainer + ' .tab-load-more').show();
            }, 100);
            $scope.resource[type].onload = false;
            $scope.resource[type].init = false;

        });
    };
    /* Infinite scroll */
    $scope.scrollLoadMore = function(container, type){
        if( $scope.resource[type].onload ) return;
        if( type == 'photo' && $scope.resource.personal.status ){
            var photoType = $scope.resource.personal.type;
            if( photoType == 'url' || photoType == 'upload' ) return;
            if( $scope.resource[photoType].filter.currentPage * $scope.resource[photoType].filter.perPage < $scope.resource[photoType].filter.total ){
                $scope.resource[photoType].filter.currentPage += 1;
            }else{
                jQuery(container + ' .loading-photo').hide();
                return;
            }
            jQuery(container + ' .loading-photo').show();
            $scope.resource[photoType].onload = true;
            if( photoType == 'facebook' ) $scope.getPersonalPhoto('facebook');
            $scope.updateApp();
            return;
        };
        if( type == 'element' ){
            var elementType = $scope.resource.element.type;
            if( ['icon', 'shape', 'line', 'flaticon', 'storyset'].indexOf(elementType) > -1 ){
                if( $scope.resource[elementType].filter.currentPage < $scope.resource[elementType].filter.totalPage ){
                    $scope.resource[elementType].filter.currentPage += 1;
                    $scope.getMedia(elementType, 'more');
                }else{
                    jQuery(container + ' .loading-photo').hide();
                    return;
                }
            };
            if( elementType == 'photoFrame' ){
                if( $scope.resource[elementType].filter.currentPage * $scope.resource[elementType].filter.perPage < $scope.resource[elementType].filter.total ){
                    $scope.resource[elementType].filter.currentPage += 1;
                }else{
                    jQuery(container + ' .loading-photo').hide();
                    return;
                }
            }
            return;
        };
        if( type == 'globalTemplate' ){
            if( $scope.resource.templateLimit < $scope.resource.templates.length ){
                $scope.resource.templateLimit += 24;
            }else{
                if( $scope.resource[type].filter.currentPage < $scope.resource[type].filter.totalPage ){
                    $scope.resource[type].filter.currentPage += 1;
                    $scope.toggleStageLoading();
                    $scope.resource[type].onload = true;
                    $scope.loadGlobalTemplate($scope.templateCat);
                }else{
                    jQuery(container + ' .loading-photo').hide();
                    return;
                }
            }
            return;
        }
        if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].filter.total){
            jQuery(container + ' .loading-photo').hide();
            return;
        }
        jQuery(container + ' .loading-photo').show();
        if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].filter.total ){
            $scope.resource[type].filter.currentPage += 1;
        }
        switch(type){
            case 'typography':
            case 'clipart':
                $scope.resource[type].onload = true;
                break;
            case 'font':
                
                break;  
            case 'photo':
                $scope.resource[type].onload = true;
                !$scope.resource.personal.status && $scope.getPhoto($scope.resource.photo.type, 'more');
                break;
        }

        /*NBDesigner Advanced*/
        if(type =='background'){
            $scope.resource[type].onload = true;
        }            

        $scope.updateApp();
    };
    $scope.generateTypoLink = function(typo){
        if( $scope.settings.task == 'typography' ){
            return NBDESIGNCONFIG['plg_url'] + '/data/typography/img/' + typo.id + '.png';
        }else{
            return '//dpeuzbvf3y4lr.cloudfront.net/typography/' + typo.folder + '/preview.png';
        }
    };
    /* Fonts */
    $scope.loadFontFailAction = function( font ){
        _.remove($scope.settings.gg_fonts, {
            id: font.id
        });
        $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
        $scope.updateApp();
    };
    /* Save Data */
    $scope.prepareBeforeSaveForLater = function(){
        $scope.selectedMyDesign = '';
        $scope.login(function(){
            var dataObj = {
                product_id: NBDESIGNCONFIG['product_id'],
                variation_id: NBDESIGNCONFIG['variation_id']
            };
            var action = 'nbd_get_user_designs';
            $scope.toggleStageLoading();
            NBDDataFactory.get(action, dataObj, function(data){
                data = JSON.parse(data);
                if(data.flag == 1){
                    $scope.resource.myTemplates = data.designs;
                    $scope.toggleStageLoading();
                    jQuery('.popup-nbd-my-templates2').nbShowPopup();
                }else{
                    $scope.toggleStageLoading();
                }
            });
        });
    };
    $scope.selectMyDesign = function( id ){
        $scope.selectedMyDesign = id;
        jQuery('.popup-nbd-my-templates2 .close-popup').triggerHandler('click');
        $scope.saveData('saveforlater');
    };
    $scope.saveForLater = function(){
        $scope.login(function(){
            $scope.saveData('saveforlater');
        });
    };
    $scope.downloadMockupPreview = function(){
        jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').addClass('active');
        var mockups = '';
        angular.forEach($scope.resource.mockups, function(mockup, key) {
            if(mockup.select){
                mockups += mockup.path + '|';
            }
        });
        if(mockups.length > 0){ 
            var dataObj = {};
            dataObj.type = 'get_mockup';
            dataObj.folder = $scope.resource.social.folder;
            dataObj.mockups = mockups.slice(0, mockups.length - 1);
            NBDDataFactory.get('nbd_get_resource', dataObj, function(data){
                data = JSON.parse(data);
                if( data.flag == 1 ){
                    var filename = 'designs.zip',
                    a = document.createElement('a');
                    a.setAttribute('href', data.data.url);
                    a.setAttribute('download', filename);
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }else{
                    alert('try again!');
                    console.log(data);
                }
                jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
            });
        }else{
            jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
            alert('Please choose mockup!');
        }
    };
    $scope.cancelMockupPreview = function(){
        jQuery('.nbd-popup.popup-nbd-mockup-preview .close-popup').triggerHandler('click');
    };
    $scope.prepareSaveTemplate = function(){
        jQuery('.nbd-popup.popup-template-tags').nbShowPopup();
    };
    /* Template tags */
    $scope.reloadTemplateTags = function(){
        $http({
            method: 'GET',
            url: NBDESIGNCONFIG['ajax_url'] + '?action=nbd_get_template_tags&nonce=' + NBDESIGNCONFIG['nonce']
        }).then(function successCallback( response ){
            if( angular.isDefined( response.data.flag ) && response.data.flag == 1 ){
                $scope.customTemplate.reload = 1;
                $scope.customTemplate.tags = response.data.tags;
                $scope.customTemplate.tag_ids = [];
                angular.forEach($scope.customTemplate.tags, function(tag, key) {
                    $scope.customTemplate.tag_ids.push( tag.term_id );
                });
            }
        }, function errorCallback(response) {
            console.log('Fail to load: template tags');
        });
    };
    $scope.addTemplateTag = function( tagId ){
        var _index = _.findIndex($scope.customTemplate.selectedTags, function(tag) { return tag == tagId; });
        if( _index == -1 ){
            $scope.customTemplate.selectedTags.push( tagId );
        }else{
            $scope.customTemplate.selectedTags.splice(_index, 1);
        }
    };
    $scope.isSelectedTags = function( tagId ){
        $scope.customTemplate.tag_ids.push( tagId );
        $scope.customTemplate.tag_ids = _.uniq( $scope.customTemplate.tag_ids );
        return _.includes( $scope.customTemplate.selectedTags, tagId );
    };
    $scope.validateTemplateTags = function(){
        var newSelectedTags = [];
        angular.forEach($scope.customTemplate.selectedTags, function(tag, key) {
            if( _.includes( $scope.customTemplate.tag_ids, tag ) ){
                newSelectedTags.push( tag );
            }
        });
        return newSelectedTags;
    };
    $scope.addTemplateColor = function( color ){
        color = color.substr(1);
        $scope.customTemplate.selectedColors.push(color);
        $scope.customTemplate.selectedColors = _.uniq( $scope.customTemplate.selectedColors );
        $scope.customTemplate.showPicker = false;
    };
    $scope.removeTemplateColor = function( colorIndex ){
        $scope.customTemplate.selectedColors.splice(colorIndex, 1);
    };
    $scope.selectCustomTemplatePreview = function( files ){
        $scope.customTemplate.template_thumb = files[0];
    };
    $scope.onSaveData = false;
    $scope.saveData = function(type){
        $scope.onSaveData = true;
        jQuery('.variations_form, form.cart').find('[name="nbo-ignore-design"]').remove();
        if( angular.isUndefined( type ) && angular.isDefined( nbd_window.nbOption ) && angular.isDefined( nbd_window.nbOption.odOption ) 
                && angular.isDefined( nbd_window.nbOption.odOption.page ) && angular.isDefined( nbd_window.nbOption.odOption.page.list_page ) && nbd_window.nbOption.odOption.page.list_page.length == 0 ){
            if(NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.task2 == '' ){
                nbd_window.jQuery('.variations_form, form.cart').append('<input name="nbo-ignore-design" type="hidden" value="1" />');
                jQuery('.variations_form, form.cart').submit();
                return;
            }
            return;
        }
        if( angular.isUndefined(type) ) type = $scope.settings.task;
        if(type != 'share' && type != 'save_draft' ) $scope.toggleStageLoading( 6E4 );
        if(type == 'typography') $scope.resource.usedFonts = [];
        var excludeType = ['saveforlater', 'share', 'download-pdf', 'preview_mockup', 'save_draft', 'download-jpg', 'change-product'];
        if( !_.includes(excludeType, type) ) $scope.maybeZoomStage = true;
        if( _.includes(['saveforlater', 'share', 'preview_mockup', 'save_draft', 'change-product'], type) ) $scope.onSaveData = false;
        if( $scope.settings.nbdesigner_dimensions_unit == 'px' && type == 'share' ) $scope.maybeZoomStage = true;

        function _saveData(){
            $scope.resource.config.viewport = $scope.viewPort; 
            /* Backward compatible version 1.x */
            $scope.resource.config.scale =  ($window.innerWidth > ($window.innerHeight - 120) ? $window.innerHeight - 120 : $window.innerWidth) / 500;  
            $scope.resource.config.product = $scope.settings.product_data.product;
            if( angular.isDefined($scope.settings.product_data.origin_product) ){
                $scope.resource.config.origin_product = $scope.settings.product_data.origin_product;
            }
            $scope.resource.config.dpi = $scope.settings.product_data.option.dpi;
            if( $scope.settings.product_data.option.option_dpi ){
                $scope.resource.config.option_dpi = true;
            }
            if( angular.isDefined( NBDESIGNCONFIG['design_id'] ) ){
                $scope.resource.config.design_id = NBDESIGNCONFIG['design_id'];
            }
            if( angular.isDefined( $scope.areaDesignShapes ) && $scope.areaDesignShapes.length ){
                $scope.resource.config.areaDesignShapes = $scope.areaDesignShapes;
            }
            $scope.resource.config.originPDFs = $scope.originPDFs;
            $scope.resource.config.pdfStacks = $scope.pdfStacks;
            if ( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) 
                  && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) ) {
                $scope.resource.config.combinationColor = $scope.currentCombinationColor;
            }
            var dataObj = {};
            dataObj.used_font = new Blob([JSON.stringify($scope.resource.usedFonts)], {type: "application/json"});
            if( type == 'template' ) $scope.resource.jsonDesign.canvas = {width: $scope.templateSize.width, height: $scope.templateSize.height};
            dataObj.design = new Blob([JSON.stringify($scope.resource.jsonDesign)], {type: "application/json"});
            _.each($scope.stages, function(stage, index){
                var key = 'frame_' + index,
                    svg_key = 'frame_' + index + '_svg'; 
                dataObj[key] = $scope.makeblob(stage.design);
                if(type != 'typography' && type != 'template' ){
                    dataObj[svg_key] = new Blob([stage.svg], {type: "image/svg"});
                }
                if( angular.isDefined( $scope.partialSvgs[index] ) && $scope.partialSvgs[index].length ){
                    $scope.partialSvgs[index].forEach(function(partialSvg, partialIndex){
                        var partial_svg_key = 'frame_' + index + '_svg_part_' + partialIndex;
                        dataObj[partial_svg_key] = new Blob([partialSvg], {type: "image/svg"});
                    });
                }
            });
            switch(type){
                case 'typography':
                    dataObj.type = 'save_typography';
                    dataObj.id = $scope.resource.currentTypo;
                    _.each($scope.stages, function(stage, index){
                        var key = 'frame_' + index;
                        dataObj[key] = $scope.makeblob(stage.design);
                    });
                    NBDDataFactory.get('nbd_get_resource', dataObj, function(data){
                        $scope.stages[0].states.usedFonts = [];
                        alert('Success!');
                    });
                    break;
                case 'template':
                    dataObj.type = 'save_template';
                    dataObj.source = 'media';
                    dataObj.tem_name = $scope.templateName;
                    dataObj.cid = $scope.templateCat;
                    jQuery('.popup-template .close-popup').triggerHandler('click');
                    NBDDataFactory.get('nbd_get_resource', dataObj, function(data){
                        data = JSON.parse(data);
                        if( data.flag == 1 ){
                            _.each($scope.stages, function(stage, index){
                                stage.states.usedFonts = [];
                            });
                            $scope.resource.usedFonts = [];
                            $scope.listAddedColor = [];
                            $scope.resetStage();
                            $scope.toggleStageLoading();
                            alert('Success!');
                        }else{
                            alert('Try again!');
                        }
                    });
                    break;
                case 'saveforlater':
                default:
                    ['product_id', 'variation_id', 'task', 'task2', 'design_type', 'nbd_item_key', 'cart_item_key', 'order_id', 'enable_upload_without_design', 'auto_add_to_cart', 'ui_mode'].forEach(function(key){
                        dataObj[key] = NBDESIGNCONFIG[key];
                    });
                    if( angular.isDefined( NBDESIGNCONFIG['design_id'] ) ){
                        dataObj['design_id'] = NBDESIGNCONFIG['design_id'];
                    }
                    if( type == 'share' ) dataObj['share'] = 1;
                    if( type == 'change-product' ) dataObj['switched_product'] = $scope.switchedProduct;
                    dataObj['nbd_file'] = '';
                    dataObj.config = new Blob([JSON.stringify($scope.resource.config)], {type: "application/json"}); 
                    if( $scope.resource.config.qty != null ){
                        dataObj.qty = $scope.resource.config.qty;
                    }else{
                        delete $scope.resource.config.qty;
                    }
                    $timeout(function(){
                        var action = ( !_.includes(excludeType, type) && NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 2 ) ?  'nbd_save_cart_design' : 'nbd_save_customer_design';
                        if(NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new'){
                            action = 'nbd_save_customer_design';
                        }
                        if(type == 'save_draft'){
                            action = 'nbd_save_draft_design';
                            dataObj.save_draft = 1;
                            if( angular.isDefined($scope.resource.draft_folder) && $scope.resource.draft_folder != '' ) dataObj.draft_folder = $scope.resource.draft_folder;
                        }
                        if(type == 'preview_mockup') {
                            dataObj.generate_mockup = 1;
                            jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').addClass('active');
                        }
                        if( NBDESIGNCONFIG.task == 'create' || ( NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template' )  ){
                            if( $scope.customTemplate.type == 2 ){
                                dataObj['template_thumb'] = $scope.customTemplate.template_thumb;
                            }
                            dataObj['template_name'] = $scope.customTemplate.name;
                            dataObj['template_type'] = $scope.customTemplate.type;
                            var selectedTags = $scope.validateTemplateTags();
                            dataObj['template_tags'] = selectedTags.join(',');
                            dataObj['template_colors'] = $scope.customTemplate.selectedColors.join(',');
                            $scope.closePopup( '.popup-template-tags' );
                        }
                        NBDDataFactory.get(action, dataObj, function(data){
                            data = JSON.parse(data);
                            if(data.flag == 'success'){
                                if( type == 'save_draft' ){
                                    $scope.resource.draft_folder = data.draft_folder;
                                    return;
                                }
                                if( type == 'preview_mockup' ){
                                    if( data.mockups ){
                                        $scope.resource.mockups = data.mockups;
                                        $scope.resource.social.folder = data.folder;
                                        var origin_url = 'whatsapp://send?text=';
                                        var d = new Date();
                                        var share_url = NBDESIGNCONFIG.nbd_create_own_page + '?product_id=' + NBDESIGNCONFIG.product_id + '&variation_id=' + NBDESIGNCONFIG.variation_id + '&reference=' + $scope.resource.social.folder + '&nbd_share_id=' + $scope.resource.social.folder + '&t=' + d.getTime();
                                        $scope.resource.social.wa_link = origin_url + encodeURIComponent(share_url);
                                        jQuery('.whatsapp_share').attr('href', $scope.resource.social.wa_link);
                                    }
                                    $timeout(function(){
                                        jQuery('.nbd-simple-slider').nbSimpleSlider();
                                    });
                                    jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
                                    $scope.toggleStageLoading();
                                    return;
                                }
                                if( type == 'download-pdf' || type == 'download-jpg' ){
                                    var _dataObj = {nbd_item_key: data.folder};
                                    var action2 = type == 'download-pdf' ? 'nbd_frontend_download_pdf' : 'nbd_frontend_download_jpeg';
                                    NBDDataFactory.get(action2, _dataObj, function(_data){
                                        _data = JSON.parse(_data);
                                        if(_data[0].flag == 1){
                                            var filename = type == 'download-pdf' ? 'design.pdf' : 'designs.zip',
                                            t = new Date().getTime(),
                                            a = document.createElement('a');
                                            a.setAttribute('href', _data[0].link + '?t=' + t);
                                            a.setAttribute('download', filename);
                                            a.style.display = 'none';
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            $scope.toggleStageLoading();
                                        }
                                    });
                                    return;
                                }
                                if( type == 'change-product' ){
                                    window.location = data['redirect_url'];
                                    return;
                                }
                                if( NBDESIGNCONFIG.ui_mode == 3 ){
                                    if( NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.task2 == '' ){
                                        $scope.toggleStageLoading();
                                        jQuery(document).triggerHandler( 'nbd_design_stored', {_type: type} );
                                        return;
                                    }else{
                                        if(NBDESIGNCONFIG['redirect_url'] != ""){
                                            window.location = NBDESIGNCONFIG['redirect_url'];
                                            return;
                                        };
                                    }
                                }
                                if( type == 'saveforlater' ){
                                    var _dataObj = {product_id: NBDESIGNCONFIG.product_id, variation_id: NBDESIGNCONFIG.variation_id, folder: data.folder};
                                    if( angular.isDefined( $scope.selectedMyDesign ) && $scope.selectedMyDesign != '' ){
                                        _dataObj.pre_folder = $scope.selectedMyDesign;
                                    }
                                    NBDDataFactory.get('nbd_save_for_later', _dataObj, function(_data){
                                        _data = JSON.parse(_data);
                                        if( angular.isDefined( $scope.selectedMyDesign ) && $scope.selectedMyDesign != '' ){
                                            if( _data.src ){
                                                _.each($scope.resource.myTemplates, function(template, index){
                                                    if( template.id == _data.folder ){
                                                        template.src = _data.src;
                                                    }
                                                });
                                            }
                                        };
                                        $scope.toggleStageLoading();
                                    }); 
                                    return;
                                } if( type == 'share' ) {
                                    $scope.resource.social.folder = data.sfolder;
                                    $scope.resource.social.images = data.image;
                                    jQuery('.nbd-popup.popup-share').find('.overlay-main').removeClass('active');
                                    return;
                                }else{
                                    if(NBDESIGNCONFIG.show_nbo_option == "1" && ( NBDESIGNCONFIG.task == 'new' || NBDESIGNCONFIG.task2 == 'update' ) ){
                                        if(NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new'){
                                            
                                        };
                                        jQuery('.variations_form, form.cart').submit();
                                        return;
                                    }
                                    if(NBDESIGNCONFIG['redirect_url'] != ""){
                                        window.location = NBDESIGNCONFIG['redirect_url'];
                                        return;
                                    };
                                    if( NBDESIGNCONFIG['nbdesigner_auto_add_cart_in_detail_page'] == "yes" &&  NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 1 && !( angular.isDefined( NBDESIGNCONFIG.edit_option_mode ) && NBDESIGNCONFIG.edit_option_mode == '1' ) ){
                                        nbd_window.jQuery('.variations_form, form.cart').append('<input name="add-to-cart" type="hidden" value="'+NBDESIGNCONFIG.product_id+'" />');
                                        nbd_window.jQuery('.variations_form, form.cart').append('<input name="nbd-auto-add-to-cart-in-detail-page" type="hidden" value="1" />');
                                        nbd_window.jQuery(nbd_window.document).triggerHandler( 'nbd_design_stored', {_type: type, prevent_ajax: 1} );
                                    }else{
                                        nbd_window.NBDESIGNERPRODUCT.product_id = NBDESIGNCONFIG['product_id'];
                                        nbd_window.NBDESIGNERPRODUCT.variation_id = NBDESIGNCONFIG['variation_id'];
                                        nbd_window.NBDESIGNERPRODUCT.folder = data.folder;
                                        nbd_window.NBDESIGNERPRODUCT.show_design_thumbnail(data.image, NBDESIGNCONFIG['task'], $scope.resource.config);
                                        nbd_window.NBDESIGNERPRODUCT.get_sugget_design(NBDESIGNCONFIG['product_id'], NBDESIGNCONFIG['variation_id']);   
                                        if( NBDESIGNCONFIG.ui_mode == 1 && $scope.resource.config.qty != null ){
                                            
                                        }
                                        if( NBDESIGNCONFIG.ui_mode == 1 && angular.isDefined( data.gallery ) ){
                                            nbd_window.jQuery(nbd_window.document).triggerHandler( 'nbd_update_gallery', {gallery: data.gallery, folder: data.folder} );
                                        }
                                        $scope.toggleStageLoading();
                                        $timeout(function(){
                                            _.each($scope.stages, function(stage, index){
                                                //$scope.zoomStage(stage.states.fitScaleIndex, index);
                                            });
                                        });
                                    }
                                }
                            }else{
                                console.log('Oops! Design has not been saved!');
                                if(type != 'save_draft'){ $scope.toggleStageLoading() };
                            }
                            $scope.onSaveData = false;
                        }); 
                    });
                    break;
            }
        };

        function waitForSaveDesign(){
            $scope.saveDesign();
            if( $scope.checkSaveStatus() ){
                _saveData();
            }else{
                var interval = $interval(function(){
                    if( $scope.checkSaveStatus() ){
                        $interval.cancel( interval );
                        _saveData();
                    }
                }, 100);
            }
        }

        if( $scope.onSaveData && NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes' ){
            $scope.loadOutlineFonts();
            var status = $scope.checkLoadedOutlineFont();
            if( status.error ){
                alert( NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font );
                return;
            }
            if( status.loaded ){
                waitForSaveDesign();
            }else{
                var _interval = $interval(function(){
                    var status = $scope.checkLoadedOutlineFont();
                    if( status.error ){
                        $interval.cancel( _interval );
                        alert( NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font );
                    }
                    if( status.loaded ){
                        $interval.cancel( _interval );
                        waitForSaveDesign();
                    }
                }, 100);
            }
        }else{
            waitForSaveDesign();
        }
    };
    $scope.createShareLink = function(type, origin_url){
        $scope.resource.social.type = type;
        var d = new Date();
        var share_url = NBDESIGNCONFIG.nbd_create_own_page + '?product_id=' + NBDESIGNCONFIG.product_id + '&variation_id=' + NBDESIGNCONFIG.variation_id + '&reference=' + $scope.resource.social.folder + '&nbd_share_id=' + $scope.resource.social.folder + '&t=' + d.getTime();
        if( jQuery('.quick-view form .variations select').length ){
            share_url += '&' + jQuery('.quick-view form .variations select').serialize();
        }else if( $scope.settings.ui_mode == 1 && nbd_window.jQuery('.variations_form .variations select').length ){
            share_url += '&' + nbd_window.jQuery('.variations_form .variations select').serialize();
        }
        $scope.resource.social.link = origin_url + encodeURIComponent(share_url);
        $scope.resource.social.design_link = share_url;
        var comment = angular.isDefined($scope.resource.social.comment) ? $scope.resource.social.comment : $scope.settings.nbdlangs.my_design;
        if( type == 'twitter' ) $scope.resource.social.link += '&text=' + comment;
    };
    $scope.copyShareLink = function(e){
        jQuery(e.target).siblings('input').select();
        document.execCommand("copy");
    };
    $scope.updateShareLink = function(){
        var link = $scope.resource.social.link;
        if(link.indexOf('&text=') > -1){
            link = link.substr(0, link.indexOf('&text=') + 6) + $scope.resource.social.comment;
            $scope.resource.social.link = link;
        }
    };
    $scope.outlineFonts = [];
    $scope.loadOutlineFonts= function(){
        _.each($scope.stages, function(stage, index){
            var _canvas = stage.canvas;
            _canvas.forEachObject(function(obj, objIndex) {
                if( obj.type == 'i-text' || obj.type == 'textbox' || obj.type == 'text' || obj.type == 'curvedText' ){
                    var fontName = obj.get('fontFamily'),
                    font = _.filter($scope.resource.font.data, { alias: fontName })[0],
                    fontWeight = obj.get('fontWeight'),
                    fontStyle = obj.get('fontStyle'),
                    font_url = '';

                    if( fontWeight == 'bold' ){
                        if( fontStyle == 'italic' ){
                            font_url = font.file.bi != 1 ? font.file.bi : NBDESIGNCONFIG.default_font.file.bi;
                            fontName += '__bi';
                        } else {
                            font_url = font.file.b != 1 ? font.file.b : NBDESIGNCONFIG.default_font.file.b;
                            fontName += '__b';
                        }
                    } else {
                        if( fontStyle == 'italic' ){
                            font_url = font.file.i != 1 ? font.file.i : NBDESIGNCONFIG.default_font.file.i;
                            fontName += '__i';
                        } else {
                            font_url = font.file.r != 1 ? font.file.r : NBDESIGNCONFIG.default_font.file.r;
                        }
                    }

                    if( font.type != 'google' ){
                        font_url = NBDESIGNCONFIG['font_url'] + font_url;
                    }else{
                        font_url = font_url.replace('http:', 'https:');
                    }

                    if( _.filter($scope.outlineFonts, { name: fontName }).length == 0 ){
                        $scope.outlineFonts.push({
                            name: fontName,
                            url: font_url,
                            loaded: false,
                            error: false
                        });
                    }
                }
            });
        });

        $scope.outlineFonts.forEach(function(font){
            opentype.load( font.url, function (err, fontJson) {
                if( err ){
                    font.error = true;
                }else{
                    font.loaded = true;
                    window.outlineFonts[font.name] = fontJson;
                }
            });
        });
    };
    $scope.checkLoadedOutlineFont = function(){
        var status = {
            loaded: true,
            error: false
        };
        $scope.outlineFonts.forEach(function(font){
            if( !font.loaded ){
                status.loaded = false;
            }
            if( font.error ){
                status.error = true;
            }
        });
        return status;
    };
    $scope.maybeZoomStage = false;
    $scope.stageSaveStatus = [];
    $scope.originPDFs = [];
    $scope.pdfStacks = [];
    $scope.partialSvgs = [];
    $scope.checkSaveStatus = function(){
        var status = true;
        $scope.stageSaveStatus.forEach(function(stageStatus){
            if( !stageStatus ){
                status = false;
            }
        });
        return status;
    };
    $scope.createPreviewWithClippath = function( index, callback ){
        var stage = $scope.stages[index];
        if( angular.isUndefined( stage ) ) return;

        var design = stage.design,
        _canvas = stage.canvas,
        width = _canvas.width,
        height = _canvas.height;

        if( !design ) return;

        function createPreviewSvg(){
            var svg = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
            svg += '<defs>';
            svg +=      '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignClipPaths[index] + '" /></clipPath>';
            svg += '</defs>';

            svg += '<g clip-path="url(#area-design-shape-' + index + ')">';
            if( stage.config.bgType == 'color' ){
                svg += '<rect x="0" y="0" width="' + width + '" height="' + height + '" fill="' + stage.config.bgColor + '" />';
            }

            svg +=      '<image x="0" y="0" width="' + width + '" height="' + height + '"' + ' xlink:href="' + design + '" />';
            svg += '</g>';
            svg += '</svg>';
            return svg;
        }

        var previewSvg = createPreviewSvg(),
        img = new Image();
        url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( previewSvg );
        img.onload = function() {
            var kanvas = document.createElement("canvas");
            kanvas.width = width;
            kanvas.height = height,
            context = kanvas.getContext('2d');
            context.drawImage(img, 0, 0, width, height, 0, 0, width, height);

            stage.design = kanvas.toDataURL();
            if( typeof callback == 'function' ){
                $timeout(function(){
                    callback();
                });
            }
        }
        img.src = url;
    };
    $scope.downloadDesign = function( downloadType ){
        if( NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes' ){
            $scope.loadOutlineFonts();
            var status = $scope.checkLoadedOutlineFont();
            if( status.error ){
                alert( NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font );
                return;
            }
            if( status.loaded ){
                $scope.saveDesign( downloadType );
            }else{
                var _interval = $interval(function(){
                    var status = $scope.checkLoadedOutlineFont();
                    if( status.error ){
                        $interval.cancel( _interval );
                        alert( NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font );
                    }
                    if( status.loaded ){
                        $interval.cancel( _interval );
                        $scope.saveDesign( downloadType );
                    }
                }, 100);
            }
        }else{
            $scope.saveDesign( downloadType );
        }
    };
    $scope.saveDesign = function( downloadType ){
        if( $scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined( downloadType ) && downloadType == 'png' ){
            $scope.maybeZoomStage = true;
        }
        $scope.stageSaveStatus = [];
        $scope.partialSvgs = [];
        _.each($scope.stages, function(stage, index){
            $scope.stageSaveStatus[index] = false;
            $scope.deactiveAllLayer(index);
            var zoomIndex = stage.states.fillScaleIndex != -1 ? stage.states.fillScaleIndex : stage.states.fitScaleIndex;
            if( $scope.maybeZoomStage ) $scope.zoomStage(zoomIndex, index);
            var _canvas = stage.canvas,
                key = 'frame_' + index;
            $scope.renderStage(index);
            $scope.resource.jsonDesign[key] = _canvas.toJSON($scope.includeExport);
            stage.svg = _canvas.toSVG();
            stage.design = _canvas.toDataURL();
            stage.config.svgWidth = _canvas.width;
            stage.config.svgHeight = _canvas.height;

            $scope.pdfStacks[index] = '';
            if( angular.isDefined( $scope.originPDFs[index] ) && $scope.originPDFs[index].length ){
                var objectLen = _canvas.getObjects().length, 
                    pdfLen = $scope.originPDFs[index].length,
                    part = 0,
                    first, last;

                function storePartialSvg( first, last, part ){
                    var count = 0;
                    _canvas.forEachObject(function(obj, objIndex) {
                        if( objIndex > first && objIndex < last ){
                            obj.set({excludeFromExport: false});
                            count++;
                        }else{
                            obj.set({excludeFromExport: true});
                        }
                    });
                    if( count ) {
                        $scope.partialSvgs[index] = $scope.partialSvgs[index] || [];
                        $scope.partialSvgs[index][part] = _canvas.toSVG();
                        return true;
                    }
                    return false;
                }

                var stack = '';
                $scope.originPDFs[index].forEach(function(pdf, pdfIndex){
                    if( pdfIndex == 0 ){
                        first = -1;
                        last = pdf.index;
                        if( storePartialSvg( first, last, part ) ){
                            part++;
                            stack = '0';
                        }
                    }

                    first = pdf.index;
                    if( pdfIndex < ( pdfLen - 1 ) ){
                        last = $scope.originPDFs[index][pdfIndex + 1].index;
                    } else {
                        last = objectLen;
                    }

                    stack += '_P';

                    if( storePartialSvg( first, last, part ) ){
                        stack += '_' + part;
                        part++;
                    }
                });
                if( stack.startsWith("_") ){
                    stack = stack.substr(1);
                }
                $scope.pdfStacks[index] = stack;

                _canvas.forEachObject(function(obj) {
                    obj.set({excludeFromExport: false});
                });
            }

            if( angular.isDefined( $scope.areaDesignZoomedClipPaths[index] ) && $scope.areaDesignZoomedClipPaths[index] && !downloadType ){
                $timeout(function(){
                    var clipPath = '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignZoomedClipPaths[index] + '" /></clipPath>';

                    var bg = '';
                    if( stage.config.bgType == 'color' ){
                        bg = '<rect x="0" y="0" width="' + stage.config.svgWidth + '" height="' + stage.config.svgHeight + '" fill="' + stage.config.bgColor + '" />';
                    }
                    var newSvg = stage.svg.replace('<\/defs>', clipPath + '<\/defs><g clip-path="url(#area-design-shape-' + index + ')">' + bg);

                    newSvg = newSvg.replace('<\/svg>', '<\/g><\/svg>');
                    stage.svg = newSvg;

                    $timeout(function(){
                        $scope.createPreviewWithClippath( index, function(){
                            $scope.stageSaveStatus[index] = true;
                        } );
                    }, 100);
                }, 300);
            } else if( $scope.onSaveData && NBDESIGNCONFIG.enable_sticker_preview && index == 0 ){
                $scope.generateStickerCutline( true );
                var interval = $interval(function(){
                    if( $scope.stickerCutline.active ){
                        $interval.cancel( interval );
                        $scope.stageSaveStatus[0] = true;
                        $scope.resource.config.contour = $scope.stickerCutline.svg;
                    }
                }, 100);
            } else {
                $scope.stageSaveStatus[index] = true;
            }

            $scope.resource.usedFonts = _.concat($scope.resource.usedFonts, stage.states.usedFonts);
        });
        $scope.resource.usedFonts = _.uniqBy($scope.resource.usedFonts, 'alias');
        $scope.maybeZoomStage = false;
        if( downloadType ){
            $scope.toggleStageLoading();
            $timeout(function(){
                $scope.toggleStageLoading();
                _.each($scope.stages, function(stage, index){
                    $timeout(function(){
                        var filename = (index + 1) + ( downloadType == 'png' ? '.png' : '.svg' ),
                        a = document.createElement('a');

                        function download(){
                            a.setAttribute('download', filename);
                            a.style.display = 'none';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            if( navigator.userAgent.indexOf("Edge") > -1 ){
                                setTimeout(function() {
                                    return window.URL.revokeObjectURL( _data );
                                }, 1000);
                            }
    
                            if( $scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined( downloadType ) && downloadType == 'png' ){
                                $scope.zoomStage(stage.states.fitScaleIndex, index);
                            }
                        }

                        if( downloadType == 'png' ){
                            function downloadPng(){
                                var _data = stage.design;
                                if( navigator.userAgent.indexOf("Edge") > -1 ){
                                    var blob;
                                    blob = $scope.makeblob( _data );
                                    _data = window.URL.createObjectURL(blob);
                                }
                                a.setAttribute('href', _data);
                                download();
                            }
                            if( angular.isDefined( $scope.areaDesignClipPaths[index] ) && $scope.areaDesignClipPaths[index] ){
                                $timeout(function(){
                                    $scope.createPreviewWithClippath( index, function(){
                                        downloadPng();
                                    } );
                                }, 300);
                            }else{
                                downloadPng();
                            }
                        } else {
                            if( angular.isDefined( $scope.areaDesignZoomedClipPaths[index] ) && $scope.areaDesignZoomedClipPaths[index] ){
                                var clipPath = '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignZoomedClipPaths[index] + '" /></clipPath>';
                                var bg = '';
                                if( stage.config.bgType == 'color' ){
                                    bg = '<rect x="0" y="0" width="' + stage.config.svgWidth + '" height="' + stage.config.svgHeight + '" fill="' + stage.config.bgColor + '" />';
                                }
                                var newSvg = stage.svg.replace('<\/defs>', clipPath + '<\/defs><g clip-path="url(#area-design-shape-' + index + ')">' + bg);
                                newSvg = newSvg.replace('<\/svg>', '<\/g><\/svg>');
                                stage.svg = newSvg;
                            }
                            var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( stage.svg );
                            a.setAttribute('href', url);
                            download();
                        }
                    }, index * 500);
                });
            }, 300);
        }
    };
    $scope.makeblob = function (dataURL) {
        var BASE64_MARKER = ';base64,';
        if (dataURL.indexOf(BASE64_MARKER) == -1) {
            var parts = dataURL.split(',');
            var contentType = parts[0].split(':')[1];
            var raw = decodeURIComponent(parts[1]);
            return new Blob([raw], { type: contentType });
        }
        var parts = dataURL.split(BASE64_MARKER);
        var contentType = parts[0].split(':')[1];
        var raw = window.atob(parts[1]);
        var rawLength = raw.length;
        var uInt8Array = new Uint8Array(rawLength);
        for (var i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }
        return new Blob([uInt8Array], { type: contentType });
    };
    $scope.updateApp = function(){
        if ($scope.$root.$$phase !== "$apply" && $scope.$root.$$phase !== "$digest") $scope.$apply(); 
    };
    $scope.$on('nbd:keypress', function(event, e){
        $scope.keypressHandle(e);
    });
    $scope.$on('nbd:keydown', function(event, e){
        $scope.keydownHandle(e);
    });
    $scope.keydownHandle = function(e){};
    $scope.wraperClickHandle = function($event){
        var $textPicker = jQuery('#nbd-text-color-picker');
        var $bgPicker = jQuery('#nbd-bg-color-picker');
        var $globalPicker = jQuery('#nbd-global-color-picker');
        var $stageBgPicker = jQuery('#nbd-stage-bg-color-picker');
        if (!jQuery($event.target).hasClass('color-palette-add') && $scope.showTextColorPicker 
                && $textPicker.has($event.target).length == 0 && !$textPicker.is($event.target)){
            $scope.showTextColorPicker = false;
        };
        if( !jQuery($event.target).hasClass('color-palette-add') && $scope.showBgColorPicker && $bgPicker.has($event.target).length == 0 && !$bgPicker.is($event.target) ){
            $scope.showBgColorPicker = false;
        }
        if( !jQuery($event.target).hasClass('color-palette-add') && $scope.stageBgColorPicker.status && $stageBgPicker.has($event.target).length == 0 && !$stageBgPicker.is($event.target) ){
            $scope.stageBgColorPicker.status = false;
        }
        if( !jQuery($event.target).hasClass('color-palette-add') && $scope.globalPicker.active && $globalPicker.has($event.target).length == 0 && !$globalPicker.is($event.target) ){
            $scope.globalPicker.active = false;
        };
    };
    /* Hotkeys */
    $scope.keypressHandle = function(e){
        var targetEl = e.target.tagName.toUpperCase();
        if( targetEl == 'INPUT' || targetEl == 'TEXTAREA' ||  $scope.stages[$scope.currentStage].states.isEditing ){
            if( !(e.ctrlKey && (e.which == 66 || e.which == 73))  ){
                return;
            }
        }
        var _stage = $scope.stages[$scope.currentStage],
        _states = _stage.states;
        if(e.ctrlKey || e.metaKey){
            var keepDefault = [67, 116];
            if( _.includes(keepDefault, e.which) ) return;
            e.preventDefault();
            if( e.shiftKey ){
                switch( e.which ) { 
                    case 221:
                        /* Hold Ctrl + Shift + ] Bring layer to front */ 
                        $scope.setStackPosition('bring-front');
                        break;
                    case 219:
                        /* Hold Ctrl + Shift + [ Send layer to back */ 
                        $scope.setStackPosition('send-back');
                        break;
                    case 86:
                        /* Hold Ctrl + Shift + V  Align layer center vertical */
                        $scope.translateLayer('vertical');
                        break;
                    case 73:
                        /* Hold Ctrl + Shift + I  Import Design */ 
                        $scope.importDesign();
                        break;
                    case 69:
                        /* Hold Ctrl + Shift + E  Export Design */ 
                        $scope.exportDesign();
                        break;
                    case 83:
                        /* Hold Ctrl + Shift + S  Save Design for later*/ 
                        $scope.saveData('saveforlater');
                        break;
                    case 76:
                        /* Hold Ctrl + Shift + L  clear all stages*/ 
                        $scope.clearAllStage();
                        break;
                    case 79:
                        /* Hold Ctrl + Shift + O  Load My Design in Cart*/ 
                        $scope.loadMyDesign(null, true);
                        break;
                    case 188:
                        /* Hold Ctrl + Shift + <  Decreate font size*/ 
                        if( _states.isText ){
                            _states.text.ptFontSize -= 1;
                            $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                        }
                        $scope.updateApp();
                        break;
                    case 190:
                        /* Hold Ctrl + Shift + >  Increate font size*/ 
                        if( _states.isText ){
                            _states.text.ptFontSize += 1;
                            $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                        }
                        $scope.updateApp();
                        break; 
                    case 71:
                        /* Hold Ctrl + Shift + G  Ungroup */ 
                        if( _states.isNativeGroup ){
                            $scope.unGroupLayers();
                        }
                        $scope.updateApp();
                        break;
                }
            }else{
                switch( e.which ) {
                    case 65:
                        /* Hold Ctrl press A  select all layers */
                        $scope.selectAllLayers();
                        break;
                    case 66:
                        /* Hold Ctrl press B  set font weight bold */
                        if( _states.isText 
                                && (_states.text.font.file.b 
                                && ( _states.text.fontStyle != 'italic' || ( _states.text.fontStyle == 'italic'  && _states.text.font.file.bi ) )) ){
                            $scope.setTextAttribute('fontWeight', _states.text.fontWeight == 'bold' ? 'normal' : 'bold');
                        }
                        $scope.updateApp();
                        break;
                    case 80:
                        /* Hold Ctrl press P  duplicate layers */
                        $scope.copyLayers();
                        break;
                    case 73:
                        /* Hold Ctrl press I  set text style italic */
                        if( _states.isText 
                                && (_states.text.font.file.i 
                                && ( _states.text.fontWeight != 'bold' || ( _states.text.fontWeight == 'bold'  && _states.text.font.file.bi ) )) ){                    
                            $scope.setTextAttribute('fontStyle', _states.text.fontStyle == 'italic' ? 'normal' : 'italic');
                        }
                        $scope.updateApp();
                        break; 
                    case 68:
                        /* Hold Ctrl press D  deactive all layers */
                        $scope.deactiveAllLayer();
                        break;
                    case 69:
                        /* Hold Ctrl press E  clear stage */
                        $scope.clearStage();
                        break;
                    case 90:
                        /* Hold Ctrl press Z  Undo */
                        if( _states.isUndoable ){
                            $scope.undo();
                        }
                        break;
                    case 89:
                        /* Hold Ctrl press Y  Undo */
                        if( _states.isRedoable ){
                            $scope.redo();
                        }
                        break;
                    case 71:
                        /* Hold Ctrl press G  Group Layers */
                        if( _states.isGroup ){
                            $scope.groupLayers();
                        }
                        $scope.updateApp();
                        break;
                    case 76:
                        /* Hold Ctrl press L  Toggle Bleed Line */
                        $scope.settings.bleedLine = !$scope.settings.bleedLine;
                        $scope.updateApp();
                        break;
                    case 82:
                        /* Hold Ctrl press R  Toggle Ruler */
                        $scope.toggleRuler();
                        $scope.updateApp();
                        break;
                    case 72:
                        /* Hold Ctrl press H  Align layer center horizontal */
                        $scope.translateLayer('horizontal');
                        break;
                    case 107:
                        /* Hold Ctrl press +  Zoom In stage */
                        if( _states.currentScaleIndex < _states.scaleRange.length - 1 ){
                            $scope.zoomStage(_states.currentScaleIndex + 1);
                            $scope.updateApp();
                        }
                        break;
                    case 109:
                        /* Hold Ctrl press -  Zoom out stage */
                        if( _states.currentScaleIndex > 0 ){
                            $scope.zoomStage(_states.currentScaleIndex - 1);
                            $scope.updateApp();
                        }
                        break;
                    case 48:
                    case 96:
                        /* Hold Ctrl press 0  Resize stage to fit */
                        $scope.zoomStage(_states.fitScaleIndex);
                        $scope.updateApp();
                        break;
                    case 49:
                    case 97:
                        /* Hold Ctrl press 1  Resize stage to origin size */
                        if(_states.fillScaleIndex == -1){
                            $scope.zoomStage(_states.fitScaleIndex);
                        }else{
                            $scope.zoomStage(_states.fillScaleIndex);
                        };
                        $scope.updateApp();
                        break;
                    case 221:
                        /* Hold Ctrl press ] Bring layer forward */ 
                        $scope.setStackPosition('bring-forward');
                        break;
                    case 219:
                        /* Hold Ctrl press [ Bring layer backward */ 
                        $scope.setStackPosition('send-backward');
                        break;  
                    case 79:
                        /* Hold Ctrl press O  Load My Design */ 
                        $scope.loadMyDesign(null, false);
                        break;
                }
            }   
        }else if( e.altKey ){
            e.preventDefault();
            switch( e.which ) {
                case 37:
                    /* Hold Alt press left arrow */
                    $scope.moveLayer('left', 'alt');
                    break;
                case 38:
                    /* Hold Alt press up arrow */
                    $scope.moveLayer('up', 'alt');
                    break;
                case 39:
                    /* Hold Alt press right arrow */
                    $scope.moveLayer('right', 'alt');
                    break;
                case 40:
                    /* Hold Alt press down arrow */
                    $scope.moveLayer('down', 'alt');
                    break;   
                case 85:
                    /* Hold Alt press U */
                    if( _states.isText ) $scope.setTextAttribute('is_uppercase', true);
                    $scope.updateApp();
                    break;
                case 76:
                    /* Hold Alt press U */
                    if( _states.isText ) $scope.setTextAttribute('is_uppercase', false);
                    $scope.updateApp();
                    break;
            } 
        } else if( e.shiftKey ){
            switch( e.which ) {
                case 107:
                    /* Hold Shift press +  zoom out layer */
                    $scope.scaleLayer('+');
                    break;
                case 109:
                    /* Hold Shift press -  zoom in layer */
                    $scope.scaleLayer('-');
                    break; 
                case 71:
                    /* Hold Shift + G  Toggle Grid */ 
                    $scope.settings.showGrid = !$scope.settings.showGrid;
                    $scope.updateApp();
                    break;
                case 76:
                    /* Hold Shift + L  clear all guidelines*/ 
                    $scope.clearGuides();
                    break;
                case 68:
                    /* Hold Shift + D  Toggle Dimension */ 
                    $scope.settings.showDimensions = !$scope.settings.showDimensions;
                    $scope.updateApp();
                    break;
            }
        } else {
            switch( e.which ) {
                case 27:
                    /* Press Esc */
                    $scope.deactiveAllLayer();
                    break;
                case 37:
                    /* Press left arrow */
                    if( _states.isActiveLayer )
                        $scope.moveLayer('left');
                    break;
                case 38:
                    /* Press up arrow */
                    if( _states.isActiveLayer )
                        $scope.moveLayer('up');
                    break;
                case 39:
                    /* Press right arrow */
                    if( _states.isActiveLayer )
                        $scope.moveLayer('right');
                    break;
                case 40:
                    /* Press down arrow */
                    if( _states.isActiveLayer )
                        $scope.moveLayer('down');
                    break; 
                case 46:
                case 8:
                    /* Press "delete"  delete layers */
                    $scope.deleteLayers();
                    break;
                case 86:
                    /* Press "V"  disable draw mode */
                    if( $scope.resource.drawMode.status ) jQuery('.item[data-type="draw"]').triggerHandler('click');
                    break;
                case 66:
                    /* Press "B"  enable draw mode */
                    if( !$scope.resource.drawMode.status ) jQuery('.item[data-type="draw"]').triggerHandler('click');
                    break;
            }
        }
    };
    $scope.onClickStage = function( $event ){
        /*
         * Deactive all layer if click outer canvas 
         * Hide context menu
         * Store stages
         */
        if(angular.element($event.target).hasClass('stage')){
            $scope.deactiveAllLayer();
            /* store all stages */    
            if( $scope.settings.nbdesigner_save_latest_design == 'yes' ){
                $scope.saveDesign();
                var json = {config: {}};
                json.config.viewport = $scope.viewPort;
                json.fonts = $scope.resource.usedFonts;
                json.design = $scope.resource.jsonDesign;
                if( angular.isDefined( NBDESIGNCONFIG.design_id ) ){
                    json.config.design_id = NBDESIGNCONFIG.design_id;
                }
                var pid = NBDESIGNCONFIG['product_id'] + '-' + NBDESIGNCONFIG['variation_id'];
                $scope.localStore.update(pid, json, function(){
                    jQuery('.nbd-toasts').nbToasts();
                });
            }
        }
        $scope.ctxMenuStyle.visibility = 'hidden';
        $scope.updateApp();
    };
    $scope.$on('nbd:contextmenu', function(event, e){
        $scope.contextMenu(e);
    });
    $scope.ctxMenuStyle = {
        'top': '17%',
        'left': '33%',
        'visibility': 'hidden'
    };
    $scope.contextMenu = function(e){
        if( $scope.stages[$scope.currentStage].states.isEditing || $scope.stages[$scope.currentStage].states.isMask ) return;
        e.preventDefault();
        var posX = e.pageX,
            posY = e.pageY;
        var contextEl = angular.element(document.getElementById('nbd-context-menu'))[0],
            height = contextEl.clientHeight,
            width = contextEl.clientWidth; 
        if($scope.workBenchWidth < (posX + width + 15)) posX = $scope.workBenchWidth - width - 15;
        if($scope.workBenchHeight < (posY + height + 15)) posY = $scope.workBenchHeight - height - 15;
        $scope.ctxMenuStyle = {
            'visibility': 'visible',
            top: posY,
            left: posX
        }
        $scope.updateApp();
    }; 
    $scope.preventLoadDesign = false;
    $scope.globalPicker = {
        color: NBDESIGNCONFIG.nbdesigner_default_color,
        attr: 'text.stroke',
        active: false
    };
    $scope.selectGlobalPicker = function(color){
        $scope.globalPicker.color = color;
        var attr_arr = $scope.globalPicker.attr.split(".");
        if( attr_arr.length == 2 && attr_arr[0] == 'text' ){
            $scope.setTextAttribute(attr_arr[1], $scope.globalPicker.color);
            $timeout(function(){
                jQuery('.menu-item.item-stroke').addClass('active');
            });
        }else if( attr_arr.length == 2 && attr_arr[0] == 'geoObject' ){
            $scope.setGeometricalObjectAttr( attr_arr[1], color );
        }else if( attr_arr.length == 2 && attr_arr[0] == 'shadow' ){
            $scope.stages[$scope.currentStage].states.shadow.color = $scope.globalPicker.color;
            $timeout(function(){
                jQuery('.menu-item.item-shadow').addClass('active');
            });
        }
        jQuery('#nbd-global-color-palette').removeClass('show');
    };
    $scope.$on('nbd:picker', function(event, attr, color){
        $scope.globalPicker.attr = attr;
        $scope.globalPicker.color = color;
    });
    $scope.$on('canvas:created', function(event, id, last){
        /* init canvas parameters */
        $scope.initStageSetting( id );
        var _canvas = $scope.stages[id].canvas;
        if(!checkMobileDevice()){
            jQuery('#stage-container-'+id).perfectScrollbar();
            jQuery('#stage-container-'+id).on('drop', function(event){
                $scope.onDrop(event, id);
            });
        };
        /* Listen canvas events */
        _canvas.on('mouse:down', function(options) {
            $scope.onMouseDown(id, options);
        });
        _canvas.on("mouse:over", function(options){
            $scope.onMouseOverStage(id, options);
        });
        _canvas.on("mouse:out", function(options){
            $scope.onMouseOutStage(id, options);
        });
        _canvas.on("mouse:move", function(options){
            $scope.onMouseMoveStage(id, options);
        });
        _canvas.on("mouse:up", function(options){
            $scope.onMouseUpStage(id, options);
        });
        _canvas.on("path:created", function(options){
            $scope.onPathCreated(id, options);
        });
        _canvas.on("object:added", function(options){
            $scope.onObjectAdded(id, options);
        });
        _canvas.on("object:removed", function(options){
            $scope.onObjectRemoved(id, options);
        });
        _canvas.on("selection:created", function(options){
            $scope.onSelectionCreated(id, options);
        });
        _canvas.on("object:scaling", function(options){
            $scope.onObjectScaling(id, options);
        });
        _canvas.on("object:scaled", function (options) {
            $scope.onObjectScaled(id, options);
        });
        _canvas.on("object:moving", function(options){
            $scope.onObjectMoving(id, options);
        });
        _canvas.on("object:moved", function (options) {
            $scope.onObjectMoved(id, options);
        });
        _canvas.on("object:rotating", function(options){
            $scope.onObjectRotating(id, options);
        });
        _canvas.on("object:modified", function(options){
            $scope.onObjectModified(id, options);
        });
        _canvas.on("before:render", function(options){
            $scope.onBeforeRender(id, options);
        });
        _canvas.on("after:render", function(options){
            $scope.onAfterRender(id, options);
        });
        _canvas.on("selection:cleared", function(options){
            $scope.onSelectionCleared(id, options);
        });
        _canvas.on("text:editing:entered", function(options){
            $scope.onEditingEntered(id, options);
        });   
        _canvas.on("text:editing:exited", function(options){
            $scope.onEditingExited(id, options);
        });
        _canvas.on("text:changed", function(options){
            $scope.onTextChanged(id, options);
        });
        _canvas.on("selection:updated", function(options){
            $scope.onSelectionUpdated(id, options);
        });
        _canvas.on("text:selection:changed", function(options){
            $scope.onSelectionChanged(id, options);
        });
        _canvas.on("mouse:dblclick", function(options){
            $scope.onDblclick(options);
        });
        _canvas.on("drop", function(options){
            $scope.onDropOnCanvas(options);
        });
        _canvas.on("dragenter", function(options){
            $scope.onDragenterOnCanvas(options);
        });
        _canvas.on("dragleave", function(options){
            $scope.onDragleaveOnCanvas(options);
        });
        /* Load template after render canvas */
        if( last == '1' ){
            appConfig.ready = true;
            if( $scope.preventLoadDesign ){
                $scope.preventLoadDesign = false;
                return;
            }
            $scope.loadTemplateAfterRenderCanvas();
        }
        if( $scope.duplicateStageIndex == id ){
            $scope.duplicateStageIndex = -1;
            $scope.contextAddLayers = 'template';
            $scope.onloadTemplate = true;
            $scope.stages[id].canvas.loadFromJSON($scope.resource.jsonDesign[id], function() {
                $scope.onloadTemplate = false;
                $scope.contextAddLayers = 'normal';
            });
        }
    });
    $scope.loadTemplateAfterRenderCanvas = function(){
        $scope.initStagesCanvas();
        if( $scope.forceInitStage ){
            $scope.initStagesSettingWithoutTemplate();
            $scope.forceInitStage = false;
            return;
        }
        if( !$scope.isTemplateMode || ($scope.isTemplateMode && $scope.settings.task == 'edit') ){
            $timeout(function(){
                function loadTemplate(){
                    if( $scope.the_first_time_load_page && angular.isDefined( $scope.settings.product_data.lazy_load_design_folder ) && $scope.settings.product_data.lazy_load_design_folder != '' ){
                        $scope.insertTemplate(false, {id: $scope.settings.product_data.lazy_load_design_folder});
                        $scope.the_first_time_load_page = false;
                        delete($scope.settings.product_data.lazy_load_design_folder);
                    }else if( angular.isDefined($scope.settings.product_data.design) ){
                        var config = ( $scope.the_first_time_load_page && angular.isDefined($scope.settings.product_data.config_ref) ) ? $scope.settings.product_data.config_ref : $scope.settings.product_data.config;
                        var viewport = config.viewport; $scope.the_first_time_load_page = false;
                        if( angular.isUndefined( config.viewport ) && angular.isDefined( config.scale ) ){
                            viewport = {width: config.scale * 500, height: config.scale * 500};
                        }
                        $scope.insertTemplate(true, {fonts: $scope.settings.product_data.fonts, design: $scope.settings.product_data.design, viewport: viewport});
                        if( angular.isDefined( $scope.settings.product_data.design_id ) ){
                            NBDESIGNCONFIG.design_id = $scope.settings.product_data.design_id;
                        }
                    }else{
                        if( NBDESIGNCONFIG.product_data.option.admindesign == "1" && $scope.resource.templates.length == 0 && NBDESIGNCONFIG.product_data.option.global_template == "1" && 
                                NBDESIGNCONFIG.product_data.option.global_template_cat != "" && $scope.settings.nbdesigner_disable_auto_load_template == 'no' ){
                            var interval = setInterval(function () {
                                if ($scope.globalTemplateLoaded) {
                                    if( $scope.resource.globalTemplate.data.length > 0 ){
                                        $scope.insertGlobalTemplate($scope.resource.globalTemplate.data[0].id);
                                    }else{
                                        $scope.initStagesSettingWithoutTemplate();
                                    };
                                    clearInterval(interval);
                                }
                            }, 100);
                        }else{
                            $scope.initStagesSettingWithoutTemplate();
                        }
                    }
                }
                function loadLocalDesign(){
                    var pid = NBDESIGNCONFIG['product_id'] + '-' + NBDESIGNCONFIG['variation_id'];
                    if( $scope.settings.nbdesigner_save_latest_design == 'yes' ){
                        if($scope.localStore.ready){
                            $scope.localStore.get(pid, function(data){
                                if(data){
                                    $scope.insertTemplate(true, {fonts: data.data.fonts, design: data.data.design, viewport: data.data.config.viewport});
                                    if( angular.isDefined( data.data.config.design_id ) ){
                                        NBDESIGNCONFIG.design_id = data.data.config.design_id;
                                    }
                                }else{
                                    loadTemplate();
                                }
                            });  
                        }else{
                            loadTemplate();
                        }
                    }else{
                        loadTemplate();
                    }
                }
                if( $scope.preventChangeCurrentDesign ){
                    loadTemplate();
                    return;
                }
                if( angular.isDefined($scope.settings.product_data.is_reference) ){
                    delete $scope.settings.product_data.is_reference;
                    loadTemplate();
                    return;
                };
                if( angular.isDefined($scope.settings.product_data.is_template) || $scope.settings.task == 'create_template' ){
                    loadLocalDesign();
                }else{
                    loadTemplate();
                }
            });
        }else{
            $scope.initStagesSettingWithoutTemplate();
        }
    };
    $scope.initStagesCanvas = function(){
        _.each($scope.stages, function(stage, index){
            var _canvas = stage.canvas;
            if( angular.isDefined( $scope.settings.nbes_enable_settings ) ){
                var forceBg = false, color = '';
                if( $scope.settings.nbes_enable_settings.combination == 1 ){
                    if( angular.isDefined( $scope.settings.nbes_settings.combination_colors ) && angular.isDefined( $scope.settings.nbes_settings.combination_colors.bg_codes ) && $scope.settings.nbes_settings.combination_colors.bg_codes.length > 0 ){
                        forceBg = true;
                        color = $scope.settings.nbes_settings.combination_colors.bg_codes[ $scope.currentCombinationColor ];
                        $scope.settings.hideColorPalette = true;
                    }
                } else if( $scope.settings.nbes_enable_settings.background == 1 ){
                    if( angular.isDefined( $scope.settings.nbes_settings.background_colors ) && angular.isDefined( $scope.settings.nbes_settings.background_colors.codes ) && $scope.settings.nbes_settings.background_colors.codes.length > 0 ){
                        forceBg = true;
                        color = $scope.settings.nbes_settings.background_colors.codes[ $scope.currentBackgroundColor ];
                    }
                }
                if( forceBg ){
                    _canvas.backgroundColor = color;
                }
            }
            if( stage.config.area_design_type == "2" ){
                $scope.contextAddLayers = 'template';
                var width = _canvas.width,
                height = _canvas.height,
                path = new fabric.Path("M0 0 H"+width+" V"+height+" H0z M "+width/2+" 0 A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" "+height+" A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" 0z");
                path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
                _canvas.add(path);
            }
        });
    };
    $scope.theFirstCalcViewport = true;
    $scope.viewPort = {};
    $scope.calcViewport = function(){
        var _offsetWidth = checkMobileDevice() ? 20 : 100,
            _offsetHeight = checkMobileDevice() ? 70 : 100,
            _width = jQuery('.nbd-stages').width() - _offsetWidth,
            _height = jQuery('.nbd-stages').height() - _offsetHeight;

        if( navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("CriOS") == -1 ){
            _offsetHeight = checkMobileDevice() ? 60 : 100;
            var ratio = window.devicePixelRatio || 1;
            if( checkMobileDevice() ){
                var screen = {
                    width : window.screen.width * ratio,
                    height : window.screen.height * ratio
                };
                if( ( screen.width == 1125 && screen.height === 2436 ) || ( screen.width == 1242 && screen.height === 2688 ) || ( screen.width == 828 && screen.height === 1792 ) ){
                    _offsetHeight = 180;
                }
            }
        };

        if( navigator.userAgent.indexOf("CriOS") != -1 ){
            var ratio = window.devicePixelRatio || 1;
            if( checkMobileDevice() ){
                var screen = {
                    width : window.screen.width * ratio,
                    height : window.screen.height * ratio
                };
                if( ( screen.width == 1125 && screen.height === 2436 ) || ( screen.width == 1242 && screen.height === 2688 ) || ( screen.width == 828 && screen.height === 1792 ) ){
                    _offsetHeight = 180;
                }
            }
        }

        _height = jQuery('.nbd-stages').height() - _offsetHeight;
        if( $scope.theFirstCalcViewport ){
            $scope.viewPort = {width: _width, height: _height};
        }
        $scope.viewPort = {width: _width, height: _height};
        $scope.theFirstCalcViewport = false;
        return {width: _width, height: _height};
    };
    $scope.reCalcViewPort = function(){

    };
    $scope.calcStyle = function(value){
        return value + 'px';
    };
    $scope.getDPI = function() {
        var div = document.createElement( "div");
        div.style.height = "1in";
        div.style.width = "1in";
        div.style.top = "-200%";
        div.style.left = "-200%";
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        div.style.opacity = "0";
        document.body.appendChild(div);
        var dpi =  div.offsetHeight;
        document.body.removeChild( div );
        return dpi;
    };
    $scope.processProductSettings = function(){
        var unitRatio = 1;
        switch( $scope.settings.nbdesigner_dimensions_unit ){
            case 'in':
                unitRatio = 2.54;
                break;
            case 'mm':
                unitRatio = 0.1;
                break;
            case 'ft':
                unitRatio = 30.48;
                break;
            case 'px':
                unitRatio = 2.54 / parseFloat( $scope.settings.product_data.option.dpi );
                break;
            default:
                unitRatio = 1;
                break;
        }
        $scope.rateConvert2Px = $scope.rateConvertCm2Px96dpi * unitRatio * parseFloat($scope.settings.product_data.option.dpi) / 96;
        var viewPort = $scope.calcViewport();
        var scaleRange = [0.1, 0.25, 0.3, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 5], 
            maxSize = checkMobileDevice() ? 1E3 : 2E3;
        $scope.stages = [];
        _.each($scope.settings.product_data.product, function(side, index){
            var _width = side.product_width * $scope.rateConvert2Px,
                _height = side.product_height * $scope.rateConvert2Px,
                designViewPort = $scope.fitRectangle(viewPort.width, viewPort.height, _width, _height, true),
                fillScale = _width / designViewPort.width,
                minScale = 200 / Math.max(designViewPort.width, designViewPort.height),
                maxScale = maxSize / Math.max(designViewPort.width, designViewPort.height),
                screenViewPort = $scope.fitRectangle(screen.width, screen.height, _width, _height, true),
                fullScreenScale = screenViewPort.width / designViewPort.width;
            var _scaleRange = scaleRange.filter(function(item){
                return item >= minScale && item <= maxScale;
            });
            $scope.stages[index] = {
                config: {
                    _width: _width,
                    _height: _height,
                    name: side.orientation_name,
                    width: designViewPort.width * side.real_width / side.product_width,
                    height: designViewPort.width * side.real_height / side.product_width,
                    top: designViewPort.width * side.real_top / side.product_width,
                    left: designViewPort.width * side.real_left / side.product_width,
                    cwidth: designViewPort.width,
                    cheight: designViewPort.height,
                    bleed_lr: designViewPort.width * side.bleed_left_right / side.product_width,
                    bleed_tb: designViewPort.width * side.bleed_top_bottom / side.product_width,
                    margin_lr: designViewPort.width * side.margin_left_right / side.product_width,
                    margin_tb: designViewPort.width * side.margin_top_bottom / side.product_width,
                    pWidth: side.product_width,
                    pHeight: side.product_height,
                    bgType: side.bg_type,
                    bgColor: side.bg_color_value,
                    bgImage: side.img_src,
                    showBleed: side.show_bleed,
                    showOverlay: side.show_overlay,
                    showSafeZone: side.show_safe_zone,
                    area_design_type: side.area_design_type,
                    show_overlay: side.show_overlay,
                    img_overlay: side.img_overlay
                },
                states: {},
                undos: [],
                redos: [],
                layers: [],
                canvas: {},
                rulers: [],
                rulerLines: {vers: [], hors: []}
            };
            if( angular.isDefined( side.bleed_radius ) && side.bleed_radius != 0 ){
                $scope.stages[index].config.bleed_radius = designViewPort.width * side.bleed_radius / side.product_width;
                $scope.stages[index].config.safezone_radius = designViewPort.width * side.safezone_radius / side.product_width;
            }
            var _state = $scope.stages[index].states;
            angular.copy($scope.defaultStageStates, _state);
            var factor = 6.4516;
            switch( $scope.settings.nbdesigner_dimensions_unit ){
                case 'in':
                    factor = 1;
                    break;
                case 'mm':
                    factor = 645.16;
                    break;
                case 'ft':
                    factor = 1 / 144;
                    break;
                case 'px':
                    factor = parseFloat( $scope.settings.product_data.option.dpi ) * parseFloat( $scope.settings.product_data.option.dpi );
                    break;
                default:
                    factor = 6.4516;
                    break;
            }
            _state.ratioConvertFont = designViewPort.width / (side.product_width / unitRatio * 2.54 * 72) * factor;
            _scaleRange.forEach(function(value){
                value != 1 && _state.scaleRange.push({ratio: value, value: (value * 100).toFixed() + '%', label: (value * 100).toFixed() + '%'});
            });
            _state.scaleRange.push({ratio: 1, value: '100%', label: 'Fit'});
            _state.scaleRange.push({ratio: fullScreenScale, value: (fullScreenScale * 100).toFixed() + '%', label: (fullScreenScale * 100).toFixed() + '%'});
            if( fillScale >= minScale && fillScale <= maxScale  ) _state.scaleRange.push({ratio: fillScale, value: (fillScale * 100).toFixed() + '%', label: 'Fill'});
            
            var printFactor = 2.54;
            switch( $scope.settings.nbdesigner_dimensions_unit ){
                case 'in':
                    printFactor = 1;
                    break;
                case 'mm':
                    printFactor = 25.4;
                    break;
                case 'ft':
                    printFactor = 1 / 12;
                    break;
                case 'px':
                    printFactor = parseFloat( $scope.settings.product_data.option.dpi );
                    break;
                default:
                    printFactor = 2.54;
                    break;
            }

            var dpi = $scope.getDPI(),
            printSizeWidth = side.product_width / printFactor * dpi,
            printSizeHeight = side.product_height / printFactor * dpi;
            
            var printScale = 0;
            if( printSizeWidth < maxSize && printSizeHeight < maxSize && printSizeWidth > minScale && printSizeHeight > minScale ){
                printScale = printSizeWidth / designViewPort.width;
                _state.scaleRange.push({ratio: printScale, value: (printScale * 100).toFixed() + '%', label: 'Print Size'});
            }
            _state.scaleRange = _.sortBy(_state.scaleRange, [function(o) { return o.ratio; }]);
            _state.currentScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == 1; });
            _state.fitScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == 1; });
            _state.fillScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == fillScale; });
            _state.fullScreenScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == fullScreenScale; });
            _state.printScaleIndex = _.findIndex(_state.scaleRange, function(o) { return o.ratio == printScale; });

            $timeout(function(){
                if( angular.isDefined( $scope.areaDesignShapes[index] ) && $scope.areaDesignShapes[index] ){
                    $scope.changeAreaDesignShape( index, $scope.areaDesignShapes[index] );
                }
            });
        });
        if( $scope.settings.task == 'typography' || $scope.settings.task == 'create_template' ){
            $scope.stages = [{
                    config: {},
                    states: {
                        scaleRange: [{ratio: 1, value: '100%', label: 'Fit'}, {ratio: 2, value: '200%', label: '200%'}, {ratio: 3, value: '300%', label: '300%'}],
                        currentScaleIndex: 0,
                        fitScaleIndex: 0,
                        fillScaleIndex: 0
                    },
                    undos: [],
                    redos: [],
                    layers: [],
                    canvas: {}
                }
            ]; 
            $scope.stages[0].states.ratioConvertFont = 1;
            if( $scope.settings.task == 'create_template' ) 
                $scope.stages[0].states.scaleRange = [{ratio: 1, value: '100%', label: 'Fit'}, {ratio: 2, value: '200%', label: '200%'}, {ratio: 3, value: '300%', label: '300%'}, {ratio: 4, value: '400%', label: '400%'}, {ratio: 5, value: '500%', label: '500%'}]
            angular.copy($scope.defaultConfig, $scope.stages[0].config);
            angular.merge($scope.stages[0].states, $scope.defaultStageStates);
        };
        ($scope.settings.showRuler && appConfig.isModern) && $scope.initRuler();
    };
    $scope.changeAreaDesignShape = function( stageIndex, svg ){
        jQuery('#stage-container-' + stageIndex + ' .stage-area-design-shape').html('').append( svg );
        $scope.areaDesignShapes[stageIndex] = svg;
        $timeout(function(){
            $scope.processAreaDesignShape(stageIndex);
        });
    };
    $scope.processAreaDesignShape = function(index){
        var stage = $scope.stages[index];
        if( angular.isUndefined( stage ) ) return;
        if( angular.isUndefined( $scope.areaDesignShapes[index] ) && $scope.areaDesignShapes[index] ) return;

        var svgWdth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
        var svgHght = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;

        function makeSVGElement(tag, attrs) {
            var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            return el;
        }

        function standardizePathDStrFormat(str) {
            return str
              .replace(/\n|\r/gm    , " "   )
              .replace(/,/g         , " "   )
              .replace(/-/g         , " -"  )
              .replace(/([A-Za-z])/g, " $1 ")
              .replace(/  /g        , " "   )
              .replace(/ ([Ee]) /g  , "$1"  )
              .replace(/^ /g        , ""    )
              .replace(/ $/g        , ""    );
        }

        function getArrayOfPathDComponents(str) {
            str = standardizePathDStrFormat(str);
            return str.split(" ");
        }

        function getTransformedPathDStr(oldPathDStr, pathTranslX, pathTranslY, scale) {
            var BOTH_X_AND_Y = 1;
            var JUST_X = 2;
            var JUST_Y = 3;
            var NONE = 4;
            var ELLIPTICAL_ARC = 5;
            var ABSOLUTE = 6;
            var RELATIVE = 7;

            var oldPathDArr = getArrayOfPathDComponents(oldPathDStr);
            var newPathDArr = [];

            var commandParams, absOrRel, oldPathDComp, newPathDComp;

            var idx = 0;

            while (idx < oldPathDArr.length) {
                var oldPathDComp = oldPathDArr[idx];
                if (/^[A-Za-z]$/.test(oldPathDComp)) {
                    newPathDArr[idx] = oldPathDArr[idx];
                    switch (oldPathDComp.toUpperCase()) {
                        case "A":
                            commandParams = ELLIPTICAL_ARC;
                            break;
                        case "H":
                            commandParams = JUST_X;
                            break;
                        case "V":
                            commandParams = JUST_Y;
                            break;
                        case "Z":
                            commandParams = NONE;
                            break;
                        default:
                            commandParams = BOTH_X_AND_Y;
                    }
                    absOrRel = ((oldPathDComp === oldPathDComp.toUpperCase()) ? ABSOLUTE : RELATIVE);
                    idx += 1;
                } else {
                    var translX, translY;
                    if (absOrRel === ABSOLUTE) {
                        translX = pathTranslX;
                        translY = pathTranslY;
                    } else if (absOrRel === RELATIVE) {
                        translX = 0;
                        translY = 0;
                    }
                    switch (commandParams) {
                        case BOTH_X_AND_Y:
                            newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                            newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                            idx += 2;
                            break;
                        case JUST_X:
                            newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                            idx += 1;
                            break;
                        case JUST_Y:
                            newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.Y + translY;
                            idx += 1;
                            break;
                        case ELLIPTICAL_ARC:
                            newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                            newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                            newPathDArr[idx + 2] = Number(oldPathDArr[idx + 2]);
                            newPathDArr[idx + 3] = Number(oldPathDArr[idx + 3]);
                            newPathDArr[idx + 4] = Number(oldPathDArr[idx + 4]);
                            newPathDArr[idx + 5] = Number(oldPathDArr[idx + 5]) * scale.X + translX;
                            newPathDArr[idx + 6] = Number(oldPathDArr[idx + 6]) * scale.Y + translY;
                            idx += 7;
                            break;
                        case NONE:
                            throw new Error('numeric value should not follow the SVG Z/z command');
                            break;
                    }
                }
            }
            return newPathDArr.join(" ");
        }

        function getTranslationAndScaling( origPathBoundingBox, svgWdth, svgHght ) {

            var origPathWdth = origPathBoundingBox.width;
            var origPathHght = origPathBoundingBox.height;
            var origPathX = origPathBoundingBox.x;
            var origPathY = origPathBoundingBox.y;

            if( origPathWdth == 0 ) return { pathTranslX: 0, pathTranslY: 0, scale: {X: 1, Y: 1} };

            var scaleBasedOnWdth = svgWdth / origPathWdth;
            var scaleBasedOnHght = svgHght / origPathHght;

            var scale = Math.min(scaleBasedOnWdth, scaleBasedOnHght);

            var scaledPathX = origPathX * scaleBasedOnWdth;
            var scaledPathY = origPathY * scaleBasedOnHght;
            var scaledPathWdth = origPathWdth * scaleBasedOnWdth;
            var scaledPathHght = origPathHght * scaleBasedOnHght;

            var scaledPathCentreX = scaledPathX + (scaledPathWdth / 2);
            var scaledPathCentreY = scaledPathY + (scaledPathHght / 2);
            var svgRootCentreX = 0 + (svgWdth / 2);
            var svgRootCentreY = 0 + (svgHght / 2);

            var pathTranslX = svgRootCentreX - scaledPathCentreX;
            var pathTranslY = svgRootCentreY - scaledPathCentreY;

            return { pathTranslX: pathTranslX, pathTranslY: pathTranslY, scale: {X: scaleBasedOnWdth, Y: scaleBasedOnHght} };
        }

        $timeout(function(){
            if( jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').length == 0 ) return;

            var _viewBox = $scope.areaDesignShapes[index].match(/viewBox="(.*?)"/)[1],
            viewBox = _viewBox.split(/\s+|,/);

            var defs = makeSVGElement('defs', {}),
            clipPath = makeSVGElement('clipPath', {id: 'area-design-shape-' + index}),
            svg = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg'),
            path = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg > path');
            var origPathBoundingBox = path.getBBox(),
            d = path.getAttribute('d');
            oldDefs = svg.getElementsByTagName('defs')[0];
            if( oldDefs ){
                svg.removeChild( oldDefs );
            }
            svg.insertBefore( defs, svg.firstChild );
            defs.appendChild( clipPath );

            var stageScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            var obj = getTranslationAndScaling( origPathBoundingBox, svgWdth, svgHght ),
            zoomedObj = getTranslationAndScaling( origPathBoundingBox, svgWdth / stageScale, svgHght / stageScale ),
            pathTranslX = obj.pathTranslX,
            pathTranslY = obj.pathTranslY,
            scale       = obj.scale,
            zoomedPathTranslX = zoomedObj.pathTranslX,
            zoomedPathTranslY = zoomedObj.pathTranslY,
            zoomedScale       = zoomedObj.scale,
            newPathDStr = getTransformedPathDStr(d, pathTranslX, pathTranslY, scale),
            newZoomedPathDStr = getTransformedPathDStr(d, zoomedPathTranslX, zoomedPathTranslY, zoomedScale),
            newPath     = makeSVGElement('path', {d: newPathDStr});
            clipPath.appendChild( newPath );
            $scope.areaDesignClipPaths[index] = newPathDStr;
            $scope.areaDesignZoomedClipPaths[index] = newZoomedPathDStr;
            jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + svgWdth + " " + svgHght);

            var bleedWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr),
            bleedHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb),
            safeZoneWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr - 2 * stage.config.margin_lr),
            safeZoneHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb - 2 * stage.config.margin_tb),
            bleedScaleX = viewBox[2] / bleedWidth,
            bleedScaleY = viewBox[3] / bleedHeight,
            safeZoneScaleX = viewBox[2] / safeZoneWidth,
            safeZoneScaleY = viewBox[3] / safeZoneHeight;
            jQuery('#stage-container-' + index + ' .bleed-line').html('').append( $scope.areaDesignShapes[index] );
            jQuery('#stage-container-' + index + ' .safe-line').html('').append( $scope.areaDesignShapes[index] );

            var bleedObj = getTranslationAndScaling( origPathBoundingBox, bleedWidth, bleedHeight ),
            safeZoneObj = getTranslationAndScaling( origPathBoundingBox, safeZoneWidth, safeZoneHeight ),
            bleedPathTranslX = bleedObj.pathTranslX,
            bleedPathTranslY = bleedObj.pathTranslY,
            bleedScale       = bleedObj.scale,
            safeZonePathTranslX = safeZoneObj.pathTranslX,
            safeZonePathTranslY = safeZoneObj.pathTranslY,
            safeZoneScale       = safeZoneObj.scale,
            newBleedPathDStr = getTransformedPathDStr(d, bleedPathTranslX, bleedPathTranslY, bleedScale),
            newSafeZonePathDStr = getTransformedPathDStr(d, safeZonePathTranslX, safeZonePathTranslY, safeZoneScale);
            //jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr, transform: 'scale(' + bleedScaleX + ', ' + bleedScaleY + ')'});
            jQuery('#stage-container-' + index + ' .bleed-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + bleedWidth + " " + bleedHeight);
            jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr});
            //jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr, transform: 'scale(' + safeZoneScaleX + ', ' + safeZoneScaleY + ')'});
            jQuery('#stage-container-' + index + ' .safe-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + safeZoneWidth + " " + safeZoneHeight);
            jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr});

            $scope.updateApp();
        });
    };
    $scope.removeAreaDesignShape = function( stageIndex ){
        jQuery('#stage-container-' + stageIndex + ' .stage-area-design-shape').html('');
        jQuery('#stage-container-' + stageIndex + ' .bleed-line').html('');
        jQuery('#stage-container-' + stageIndex + ' .safe-line').html('');
        $scope.areaDesignShapes[stageIndex] = false;
        $scope.areaDesignClipPaths[stageIndex] = false;
    };
    /* Ruler and ruler guide line */
    $scope.toggleRuler = function(){
        $scope.settings.showRuler = !$scope.settings.showRuler;
        if($scope.settings.showRuler && appConfig.isModern){
            $scope.initRuler();
        }else{
            $scope.clearGuides();
        };
    };
    $scope.initRuler = function(){
        var viewPort = $scope.calcViewport();
        $timeout(function(){
            _.each($scope.settings.product_data.product, function(side, index){
                var stage = $scope.stages[index];
                stage.hozRuler = jQuery('#hoz-ruler-'+index).nbdRuler({layout: 'horizontal', viewPort: viewPort, config: stage.config, zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio, unit: $scope.settings.nbdesigner_dimensions_unit});
                stage.verRuler = jQuery('#ver-ruler-'+index).nbdRuler({layout: 'vertical', viewPort: viewPort, config: stage.config, zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio, unit: $scope.settings.nbdesigner_dimensions_unit});
                stage.hozRuler.render();
                stage.verRuler.render();
            });
        }, 100);
    };
    $scope.calcRulerPaddingLeft = function(cwidth){
        var viewPort = $scope.calcViewport();
        var additionalPadding = (viewPort.width - cwidth) / 2;
        additionalPadding = additionalPadding > 0 ? (additionalPadding + 50) : 50;
        return additionalPadding + 'px';
    };
    $scope.calcRulerPaddingTop = function(){
        return '40px';
    };
    $scope.addRulerGuideLine = function( $event, direction ){
        var stage = $scope.stages[$scope.currentStage],
        el = jQuery($event.currentTarget),
        stageEl = el.parent('.stage'),
        stagePos = stageEl.offset(),
        top = $event.pageY - stagePos.top,
        left = $event.pageX - stagePos.left;
        stage.rulerLines[direction].push({top: top, left: left});
    };
    $scope.calcStyleGuideline = function(line, cf, ratio, direction){
        var style = {};
        var viewPort = $scope.calcViewport();
        if( direction == 'hor' ){
            style.top = (line.top > 40 ? ( 40 + (line.top - 40) * ratio - 3) : (line.top - 3) ) + 'px';
            style.width = ((cf.cwidth * ratio > viewPort.width ? cf.cwidth * ratio : viewPort.width) + 100) + 'px';
        }else{
            var additionalPadding = (cf.cwidth * ratio - viewPort.width) / 2;
            if(additionalPadding < 0){
                if( line.left <= 50 ){
                    style.left = line.left;
                }else{
                    style.left = viewPort.width / 2 - ( viewPort.width / 2 - (line.left-50) ) * ratio + 50;
                }
            }else{
                style.left = viewPort.width / 2 - ( viewPort.width / 2 - (line.left - 50) ) * ratio + 50 + additionalPadding;
            }
            style.left = ( style.left - 3 )+ 'px';
            style.height = ((cf.cheight * ratio > viewPort.height ? cf.cheight * ratio : viewPort.height) + 90) + 'px';
        }
        return style;
    };
    $scope.clearGuides = function(){
        $scope.stages[$scope.currentStage].rulerLines = {vers: [], hors: []};
    };
    $scope.initStageSetting = function( id ){
        $scope.setStageDimension(id);
        $scope.renderStage(id);
        $scope.updateApp();
    };
    $scope.initStagesSettingWithoutTemplate = function(){
        _.each($scope.stages, function(stage, index){
            var _canvas = stage.canvas;
            _canvas.requestRenderAll();
        });
        $scope.afterInsertTemplate();
    };
    $scope.firstTimeLoadedTemplate = true;
    $scope.firstTimeShowTemplateFiledsPopup = true;
    $scope.afterInsertTemplate = function(){
        if( $scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2 ){
            var showTourGuide = localStorage.getItem('showTourGuide');
            if( !showTourGuide ){
                $scope.startTourGuide();
            }else{
                $scope.showTemplateFieldsPopup();
            }
        }
        _.each($scope.stages, function(stage, index){
            $scope.updateMaskedLayers(index);
            $timeout(function(){
                $scope.setHistory(index, true);
            });
        });
        $scope.firstTimeLoadedTemplate      = false;
        $scope.completedInsertTemplate      = true;
        $scope.onLoadPrintingOptions        = false;
        $scope.preventChangeCurrentDesign   = false;
        $scope.forceLoadVariationDesign     = false;
        $scope.onChangePrintingOptions      = false;

        if ( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) 
              && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) ) {
            $scope.selectCombinationColor( $scope.currentCombinationColor );
        }

        if( $scope.awaitSubmitForm ){
            $scope.saveData();
        }
    };
    $scope.updateMaskedLayers = function( stage_id ){
        function getLayerbyId( canvas, id ){
            var layer;
            canvas.forEachObject(function(obj, idx) {
                if( obj.get('itemId') == id ) layer = obj;
            });
            return layer;
        }
        var _canvas = $scope.stages[stage_id].canvas,
        needRender = false;
        _canvas.forEachObject(function(obj, layerIndex) {
            if(!!obj.get('maskId')){
                var id = obj.get('maskId'),
                maskLayer = getLayerbyId( _canvas, id );
                if( maskLayer ){
                    needRender = true;
                    maskLayer.set({opacity: 0.001, fill: '#ffffff'});
                    obj.set({clipPath: maskLayer});
                }
            }
        });
        if( needRender ){
            $scope.renderStage( stage_id );
        }
    };
    $scope.showTemplateFieldsPopup = function( force ){
        if( !$scope.settings.is_mobile && ( $scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2 ) && NBDESIGNCONFIG.nbdesigner_enable_template_mapping == 'yes' 
                && $scope.firstTimeShowTemplateFiledsPopup && NBDESIGNCONFIG.is_logged != 1 && !$scope.tourGuideShowing && $scope.templateHolderFields.length > 0 ){
            $timeout(function(){
                jQuery( '.popup-template-fields' ).nbShowPopup();
                $scope.firstTimeShowTemplateFiledsPopup = false;
            }, 400);
        }
        if( angular.isDefined( force ) ){
            jQuery( '.popup-template-fields' ).nbShowPopup();
        }
    };
    $scope.updateTemplateFields = function(){
        if( $scope.templateHolderFields.length > 0 ){
            _.each($scope.templateHolderFields, function(field, index){
                if( field.value != '' ){
                    _.each($scope.stages, function(stage, index){
                        var _canvas = stage.canvas;
                        _canvas.forEachObject(function(obj) { 
                            if( angular.isDefined( obj.field_mapping ) && field.key == obj.field_mapping ){
                                obj.text = field.value;
                            }
                        });
                        _canvas.calcOffset();
                        _canvas.requestRenderAll();
                    });
                }
            });
        }
        jQuery( '.popup-template-fields .close-popup' ).triggerHandler('click');
    };
    $scope.duplicateStageIndex = -1;
    $scope.addStage = function( duplicate ){
        var new_stage = {}, new_side_config = {}, stageLen = $scope.stages.length, currentStage = $scope.currentStage;
        var _canvas = $scope.stages[$scope.currentStage].canvas;
        angular.copy($scope.stages[$scope.currentStage], new_stage);
        if( angular.isDefined($scope.settings.product_data.option.new_side_name) ){
            if( angular.isUndefined($scope.settings.product_data.origin_product) ){
                $scope.settings.product_data.origin_product = [];
                angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
            }
            new_stage.config.name = $scope.settings.product_data.option.new_side_name;
            var max_number_side = parseInt($scope.settings.product_data.option.max_number_side);
            if( ($scope.settings.product_data.origin_product.length + max_number_side ) ==  $scope.stages.length ){
                $scope.resource.canAdd = false;
                return;
            }
        }
        $scope.preventLoadDesign = true;
        angular.copy($scope.settings.product_data.product[$scope.currentStage], new_side_config);
        $scope.settings.product_data.product.splice($scope.currentStage + 1, 0, new_side_config);
        $scope.resource.config.qty++;
        if( duplicate ){
            if(stageLen > ($scope.currentStage + 1)){
                $scope.duplicateStageIndex = $scope.currentStage + 1;
            }
            $scope.resource.jsonDesign[$scope.currentStage + 1] = {};
            angular.copy(_canvas.toJSON($scope.includeExport), $scope.resource.jsonDesign[$scope.currentStage + 1]);
        }
        $scope.stages.splice($scope.currentStage + 1, 0, new_stage);
        $scope.updateApp();
        if( angular.isDefined($scope.settings.product_data.option.max_number_side) ){
            if( ($scope.settings.product_data.origin_product.length + parseInt( $scope.settings.product_data.option.max_number_side ) ) ==  $scope.stages.length ){
                $scope.resource.canAdd = false;
            }
        };
        $timeout(function(){
            $scope.switchStage($scope.currentStage, 'next');
            if(stageLen == (currentStage + 1)){
                $scope.contextAddLayers = 'template';
                $scope.onloadTemplate = true;
                $scope.stages[stageLen].canvas.loadFromJSON($scope.resource.jsonDesign[stageLen], function() {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                });
            }
        }, 100);
    }; 
    $scope.removeStage = function( index ){
        var currentStage = angular.isDefined(index) ? index : $scope.currentStage;
        if($scope.currentStage > 0){
            $scope.currentStage--;
            $scope.switchStage(currentStage, 'prev', 'top-bottom', true);
        }
        $scope.saveDesign();
        $scope.settings.product_data.product.splice(currentStage, 1);
        $scope.stages.splice(currentStage, 1);
        $scope.updateApp();
        $scope.closePopup('.popup-nbd-delete-stage-alert');
        $scope.resource.config.qty--;
        $scope.resource.canAdd = true;
        $timeout(function(){
            
        }, 100);
    };
    $scope.closePopup = function( popup ){
        jQuery(popup + ' .close-popup').triggerHandler('click');
    };
    $scope.resetStage = function(){
        var new_stage = {};
        angular.copy($scope.stages[0], new_stage);
        $scope.stages = [];
        $scope.stages.push(new_stage);
        $scope.currentStage = 0;
        $scope.preventLoadDesign = true;
    };
    $scope.setStageDimension = function(id){
        id = angular.isDefined(id) ? id : $scope.currentStage;
        var _stage = $scope.stages[id];
        var currentWidth = _stage.config.width * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
            currentHeight = _stage.config.height * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
        $scope.stages[id]['canvas'].setDimensions({'width' : currentWidth, 'height' : currentHeight});
    };
    $scope.switchStageTo = function( id, direction ){
        $scope.currentStage = id;
        jQuery('.stage').addClass('_nbd_hidden')
            .removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp')
            .removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
        var idCurrentStage = '#stage-container-' + id,
        fadeInClass = direction == 'left-right' ? 'fadeInRight' : 'fadeInUp';
        jQuery(idCurrentStage).removeClass('_nbd_hidden').addClass(fadeInClass);
    };
    $scope.switchStage = function(id, command, direction, onRemoveStage){
        var idCurrentStage = 'stage-container-' + id,
            next =  parseInt(id) + 1;
        if(command == 'prev')  {
            next  = parseInt(id) - 1;
        };
        jQuery('.temporary-hidden').addClass('nb-opacity-0');
        $timeout(function(){
            jQuery('.temporary-hidden').removeClass('nb-opacity-0');
        }, 600);
        jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').addClass('nbd-hiden');
        $timeout(function(){
            jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').removeClass('nbd-hiden');
        }, 700);
        direction = angular.isDefined(direction) ? direction : 'top-bottom';
        var fadeInNext = 'fadeInUp', fadeInPrev = 'fadeInDown', fadeOutNext = 'fadeOutDown', fadeOutPrev = 'fadeOutUp';
        if( direction == 'left-right' ){
            fadeInNext = 'fadeInRight'; 
            fadeInPrev = 'fadeInLeft';
            fadeOutNext = 'fadeOutRight';
            fadeOutPrev = 'fadeOutLeft';
        };

        var idNextStage = 'stage-container-' + next;
        var currentStage = angular.element(document.getElementById(idCurrentStage)),
        nextStage = angular.element(document.getElementById(idNextStage));
        if( direction == 'left-right' ){
            currentStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
            nextStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
        }else{
            currentStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
            nextStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
        }
        currentStage.addClass('animated');
        currentStage.removeClass(fadeInNext);
        currentStage.removeClass(fadeInPrev);
        nextStage.addClass('animated');
        nextStage.removeClass('_nbd_hidden');
        nextStage.removeClass(fadeOutNext);
        nextStage.removeClass(fadeOutPrev);
        if(command == 'prev'){
            currentStage.removeClass(fadeOutNext);
            currentStage.addClass(fadeOutPrev);
            nextStage.addClass(fadeInPrev);
        }else {
            currentStage.removeClass(fadeOutPrev);
            currentStage.addClass(fadeOutNext);
            nextStage.addClass(fadeInNext);
        };

        if(angular.isUndefined(onRemoveStage)) $scope.currentStage = next;
        if(appConfig.isVisual){
            $scope.deactiveAllLayer();
        }
        $scope.renderStage();
        $scope.updateLayersList();
    };
    $scope.stageEvent = {
        dropped: false,
        target: null,
        lastDistance: null,
        lastScaleX: null,
        lastScaleY: null
    };
    $scope.onDropOnCanvas = function( op ){
        $scope.stageEvent.dropped = true;
        if( op.target ){
            $scope.stageEvent.target = op.target;
        }
    };
    $scope.onDragenterOnCanvas = function( op ){};
    $scope.onDragleaveOnCanvas = function( op ){};
    $scope.onDrop = function(event){
        event.preventDefault();
        var src = event.originalEvent.dataTransfer.getData("src"),
        extenal = event.originalEvent.dataTransfer.getData("extenal"),
        type = event.originalEvent.dataTransfer.getData("type"),
        origin_url = event.originalEvent.dataTransfer.getData("origin_url"),
        width = event.originalEvent.dataTransfer.getData("origin_width"),
        height = event.originalEvent.dataTransfer.getData("origin_height");
        switch(type){
            case 'image':
                function addImage( maskId ){
                    if(extenal == 'true'){
                        if( angular.isDefined( maskId ) ){
                            $scope.addImageFromUrl(src, true, false, maskId);
                        }else{
                            $scope.addImageFromUrl(src, true);
                        }
                    }else{
                        var data  = src;
                        if( angular.isDefined( origin_url ) && origin_url != '' ){
                            var data = {
                                url: src,
                                src: src,
                                origin_url: origin_url,
                                width: parseInt( width ),
                                height: parseInt( height )
                            };
                        }
                        if( angular.isDefined( maskId ) ){
                            $scope.addImageFromUrl(data, false, false, maskId);
                        }else{
                            $scope.addImageFromUrl(data, false);
                        }
                    };
                }
                var interval = $interval(function(){
                    if( $scope.stageEvent.dropped ){
                        $interval.cancel( interval );
                        if( !!$scope.stageEvent.target && !!$scope.stageEvent.target.get('itemId') && !!$scope.stageEvent.target.get('maskId') ){
                            addImage( $scope.stageEvent.target.get('maskId') );
                        }else{
                            addImage();
                        }
                        $scope.stageEvent.dropped = false;
                        $scope.stageEvent.target = null;
                    }
                }, 50);
                break;
            case 'svg':
                if( extenal == 'true' ){
                    $scope.addSvgFromMedia({url: src});
                    break;
                }
                $scope.addImageFromUrl(src, false);
                break;
            case 'typo':
                $scope.insertTypography({folder: src});
                break;
        };
    };
    $scope.onMouseDown = function(id, options){
        $scope.stages[$scope.currentStage].states.isShowToolBox = true;
        if( checkMobileDevice() ){
            jQuery('.nbd-main-menu .menu-item').removeClass('active');
        }
        $scope.updateApp();
    };
    $scope.onDblclick = function(options){
        var item = options.target;
        if( item ){
            if( item.type === 'activeSelection' ){
                $scope.deactiveAllLayer();
            } else if( !!item.get('maskId') && !$scope.stages[$scope.currentStage].states.lockMask ){
                $scope.editMask();
                var _stage = $scope.stages[$scope.currentStage];
                _stage.states.corners = [];
            }
        }
    };
    $scope.onMouseOverStage = function(id, options){
        if(options.target){
            var item = options.target;
            $scope.updateBoundingRect(item);
            $scope.updateApp();
        }
    };   
    $scope.onMouseOutStage = function(id, options){
        if(options.target){
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
        }
        $scope.updateApp();
    }; 
    $scope.onMouseMoveStage = function(id, options){
        if( $scope.settings.showRuler && appConfig.isModern ){
            var _stage = $scope.stages[$scope.currentStage];
            if( _stage.hozRuler ){
                var pointer = _stage.canvas.getPointer(options.e);
                var x = (pointer.x + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
                y = (pointer.y + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
                _stage.hozRuler.updateCursorIndicator({x: x, y: y});
                _stage.verRuler.updateCursorIndicator({x: x, y: y});
            }
        }
        if( options.target && options.e.touches && options.e.touches.length == 2 ){
            var item = options.target;
            if( item && item.type != 'activeSelection' ){
                var scaleX = item.get('scaleX'),
                scaleY = item.get('scaleY'),
                pageX1 = options.e.touches[0].pageX,
                pageY1 = options.e.touches[0].pageY,
                pageX2 = options.e.touches[1].pageX,
                pageY2 = options.e.touches[1].pageY,
                distance = Math.sqrt( ( pageX1 - pageX2 ) * ( pageX1 - pageX2 ) + ( pageY1 - pageY2 ) * ( pageY1 - pageY2 ) );
                distance = distance == 0 ? 1 : distance;
                if( !$scope.stageEvent.lastDistance ){
                    $scope.stageEvent.lastDistance = distance;
                    $scope.stageEvent.lastScaleX = scaleX;
                    $scope.stageEvent.lastScaleY = scaleY;
                }
                var ratio = distance / $scope.stageEvent.lastDistance;
                ratio = ratio > 3 ? 3 : ratio;
                item.set({scaleX: $scope.stageEvent.lastScaleX * ratio, scaleY: $scope.stageEvent.lastScaleY * ratio});
                item.setCoords();
                $scope.adjustMaskedLayers( item, 'at' );
                $scope.renderStage();
            }
        }
    };
    $scope.onMouseUpStage = function(id, options){
        var _stage = $scope.stages[$scope.currentStage];
        /*
         * Hide bounding rect, coordinates label, snap lines, rotate label
         */
        angular.merge(_stage.states.boundingObject, {visibility: 'hidden'});
        angular.merge(_stage.states.coordinates, {style: {visibility: 'hidden'}});
        var position = {
            ht: {top: -9999},
            hb: {top: -9999},
            hc: {top: -9999},
            vl: {left: -9999},
            vr: {left: -9999},
            vc: {left: -9999},
            hcc: {top: -9999},
            vcc: {left: -9999},
            vel: {left: -9999},
            ver: {left: -9999},
            het: {top: -9999},
            heb: {top: -9999}
        };
        angular.merge(_stage.states.snaplines, position);
        angular.merge(_stage.states.rotate, {style: {visibility: 'hidden'}});
        /* get layer parameters before modify */
        var _canvas = _stage.canvas,
            objects =  _canvas.getActiveObjects();
        _stage.tempParameters = null;
        if( objects.length == 1 ){
            _stage.tempParameters = JSON.stringify(objects[0].toJSON());
        }
        /* Delete layer if out of stage fully */
        if( options.target ){
            if(!options.target.isOnScreen()) $scope.deleteLayers();
        }
        
        $scope.stageEvent.lastDistance = null;
        $scope.stageEvent.lastScaleX = null;
        $scope.stageEvent.lastScaleY = null;

        if( $scope.settings.nbdesigner_always_show_layer_action == 'yes' ){
            $scope.updateCorners();
        }

        $scope.updateApp(); 
    };  
    $scope.beforeObjectModify = function( item ){
        /*$scope.setHistory({
            element: item,
            parameters: JSON.stringify(item.toJSON()),
            interaction: 'modify'
        });*/
    };
    $scope.afterObjectModify = function(){
        $scope.setHistory( $scope.currentStage, true );
        $scope.stageDesignChanged();
    };
    $scope.stageDesignChanged = function(){
        $scope.stickerCutline.active = false;
    };
    $scope.onPathCreated = function(id, options){};
    $scope.onObjectAdded = function(id, options){
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage['canvas'],
        item = options.target,
        d = new Date(),
        itemId = d.getTime() + Math.floor(Math.random() * 1000);
        if( $scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' ){
            if( !$scope.canAddMoreLayer() ){
                _canvas.remove( item );
                return
            };
        }
        if( $scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' || $scope.contextAddLayers == 'template' ){
            if( angular.isUndefined( item.get('itemId') ) ){
                item.set({"itemId" : itemId});
            }
        };
        if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
            _stage.states.isShowToolBox = true;
            _canvas.viewportCenterObject(item);
            $scope.toggleTip();
        }
        var type = item.get('type');
        if( $scope.resource.upload.ilr ){
            item.set({ilr: true});
            $scope.resource.upload.ilr = false;
        }
        if(type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText') item.initDimensions();
        item.setCoords();
        if( (['normal', 'copy', 'undo', 'redo'].indexOf($scope.contextAddLayers) > -1) && _stage.config.area_design_type == "2" )  $scope.setStackLayerAlwaysOnTop();
        var top = item.get('top'),
            left = item.get('left');
        if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
            item.set({top: top - 50});
            item.animate('top', top, {
                duration: 400,
                onChange: function(){
                    $scope.renderStage();
                },
                onComplete: function(){
                    if( item.isBgImg ){
                        $scope.setStackLayerAlwaysOnBottom();
                    }else{
                        _canvas.setActiveObject(item);
                    }
                    /*$scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });*/
                    $scope.setHistory($scope.currentStage, true);
                    $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                    if(type == 'i-text' || type == 'textbox'){
                        item.selectAll();
                        item.enterEditing();
                    }
                    $scope.renderStage();
                    $scope.afterAddNewObject();
                },
                easing: FabricWindow.util.ease['easeInQuad']
            });
            $scope.stages[$scope.currentStage].states.isActiveLayer = true;
        }else if( $scope.contextAddLayers == 'copy' ){
            item.set({top: top - 20, left: left - 20});
            item.animate({'top': top, 'left': left}, {
                duration: 400,
                onChange: function(){
                    $scope.renderStage();
                },
                onComplete: function(){
                    /*$scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });*/
                    $scope.setHistory($scope.currentStage, true);
                    $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                    $scope.renderStage();
                },
                easing: FabricWindow.util.ease['easeInQuad']
            });
        }else{
            $scope.renderStage();
        };
        if( !$scope.onloadTemplate ){
            if($scope.onUnloadGroup.status){
                if( angular.isDefined($scope.onUnloadGroup.prevIndex) ){
                    item.moveTo( parseInt( $scope.onUnloadGroup.prevIndex ) + $scope.onUnloadGroup.length - $scope.onUnloadGroup.remain );
                }
                if( type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText' ){
                    item.set({editable: true});
                }
                if( $scope.onUnloadGroup.remain > 1 ){
                    $scope.onUnloadGroup.remain -= 1;
                }else{
                    $scope.onUnloadGroup = {
                        status: false,
                        remain: 0
                    };
                    $scope.contextAddLayers = 'normal';
                    $scope.setHistory($scope.currentStage, true);
                }
            }else{
                $scope.contextAddLayers = 'normal';
            }
        }
        if( $scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status ){
            $scope.showDesignTab();
        }
        $scope.forceForeground( item );
        $scope.updateLayersList();
        $scope.stageDesignChanged();
    };
    $scope.onObjectRemoved = function(id, options){
        $scope.stageDesignChanged();
    };
    $scope.afterAddNewObject = function(){};
    $scope.showDesignTab = function(){
        if( checkMobileDevice() ){
            jQuery('#design-tab').triggerHandler('click');
        };
    };
    $scope.disablePreventClickMode = function(){
        jQuery('.tabs-content').removeClass('nbd-prevent-click');
    };
    $scope.onObjectScaling = function(id, options){
        var item = options.target; 
        $scope.adjustMaskedLayers( item );
        $scope.updateAssociateLayer(item);
        $scope.stages[$scope.currentStage].states.isShowToolBox = false;
        $scope.stages[$scope.currentStage].states.corners = [];
    };
    $scope.onObjectScaled = function (id, options) {
        var item = options.target;
        $scope.stages[$scope.currentStage].states.isShowToolBox = true;
        $scope.setPositionToolbox();
        $scope.adjustMaskedLayers( item, 'at' );
    };
    $scope.onObjectMoving = function(id, options){
        var item = options.target;
        if($scope.settings.snapMode.status){

        }
        $scope.adjustMaskedLayers( item );
        $scope.updateAssociateLayer(item); 
        $scope.stages[$scope.currentStage].states.isShowToolBox = false;
        $scope.stages[$scope.currentStage].states.corners = [];
    }; 
    $scope.onObjectMoved = function (id, options) {
        var item = options.target;
        $scope.stages[$scope.currentStage].states.isShowToolBox = true;
        $scope.setPositionToolbox();
        $scope.adjustMaskedLayers( item, 'at' );
    };
    $scope.onObjectRotating = function(id, options){
        var item = options.target;
        $scope.updateAssociateLayer(item);
        $scope.updateAngleLabel(item);
        $scope.stages[$scope.currentStage].states.corners = [];
    };
    $scope.adjustMaskedLayers = function( obj, context ){
        var _canvas = this.stages[$scope.currentStage].canvas;
        function adjustMaskedLayer( item ){
            if( !!item.get('maskId') ){
                var maskLayerIndex = $scope.getLayerById( item.get('maskId') );
                if( typeof maskLayerIndex != "undefined" ){
                    var maskLayer = _canvas.item( maskLayerIndex ),
                    maskLeft = maskLayer.get('left'),
                    maskTop = maskLayer.get('top'),
                    maskWidth = maskLayer.get('width') * maskLayer.get('scaleX'),
                    maskHeight = maskLayer.get('height') * maskLayer.get('scaleY'),
                    scaleX = item.get('scaleX'),
                    scaleY = item.get('scaleY'),
                    imWidth = item.get('width'),
                    imHeight = item.get('height'),
                    width = item.get('width') * scaleX,
                    height = item.get('height') * scaleY,
                    left = item.get('left'),
                    top = item.get('top'),
                    realLeft = left - width / 2,
                    realTop = top - height / 2;
                    
                    function lessThan(x, y){
                        var epsilon = 0.00001;
                        return x < y && Math.abs( x - y ) > epsilon;
                    };
                    
                    if( lessThan(width, maskWidth) || lessThan(height, maskHeight) ){
                        if( lessThan(width, maskWidth) ){
                            var _scaleX = maskWidth / item.get('width');
                            item.set({
                                left: maskLeft + maskWidth / 2,
                                scaleX: _scaleX
                            });
                            if( imWidth < imHeight && scaleY < _scaleX ){
                                item.set({
                                    scaleY: _scaleX
                                });
                            }
                        }
                        if( lessThan(height, maskHeight) ){
                            var _scaleY = maskHeight / item.get('height');
                            item.set({
                                top: maskTop + maskHeight / 2,
                                scaleY: _scaleY
                            });
                            if( imWidth > imHeight && scaleX < _scaleY ){
                                item.set({
                                    scaleX: _scaleY
                                });
                            }
                        }
                    } else {
                        if( realLeft > maskLeft ){
                            item.set({
                                left: left - ( realLeft - maskLeft )
                            });
                        }
                        if( realTop > maskTop ){
                            item.set({
                                top: top - ( realTop - maskTop )
                            });
                        }
                        if( ( realLeft + width ) < ( maskLeft + maskWidth ) ){
                            item.set({
                                left: left + ( maskLeft + maskWidth - realLeft - width )
                            });
                        }
                        if( ( realTop + height ) < ( maskTop + maskHeight ) ){
                            item.set({
                                top: top + ( maskTop + maskHeight - realTop - height )
                            });
                        }
                    }
                    item.setCoords();
                }
            } else if( !!item.get('isMask') ){
                var maskId = item.get('itemId'),
                maskedLayer = $scope.getMaskedLayerByMaskId( maskId );
                if( typeof maskedLayer != "undefined" ){
                    var maskLeft = item.get('left'),
                    maskTop = item.get('top'),
                    maskWidth = item.get('width') * item.get('scaleX'),
                    maskHeight = item.get('height') * item.get('scaleY'),
                    scaleX = maskedLayer.get('scaleX'),
                    scaleY = maskedLayer.get('scaleY'),
                    width = maskedLayer.get('width') * scaleX,
                    height = maskedLayer.get('height') * scaleY,
                    newWidth = width,
                    newHeight = height;
                    if( width < maskWidth || height < maskHeight ){
                        if( ( width / height ) > ( maskWidth / maskHeight ) ){
                            newHeight = maskHeight;
                            newWidth = width / height * newHeight;
                        }else{
                            newWidth = maskWidth;
                            newHeight = height / width * newWidth;
                        }
                    }
                    maskedLayer.set({
                        left: maskLeft + maskWidth / 2,
                        top: maskTop + maskHeight / 2,
                        scaleX: newWidth / maskedLayer.get('width'),
                        scaleY: newHeight / maskedLayer.get('height')
                    });
                    maskedLayer.setCoords();
                }
            }
        }
        if( obj.type == 'activeSelection' ){
            if( context == 'at' ){
                $scope.deactiveAllLayer();
                obj.forEachObject(function(o) {
                    if( !!o.get('maskId') ) adjustMaskedLayer( o, obj );
                });
            }
        } else {
            adjustMaskedLayer( obj );
        }
    };
    $scope.updateAssociateLayer = function(item){
        if(item){
            var d = new Date(),
            t = d.getTime();
            if( $scope.stages[$scope.currentStage].states.coordinates.lastCheck < ( t - 20 ) ){
                item.setCoords();
                $scope.stages[$scope.currentStage].states.coordinates.lastCheck = t;
                $scope.updateCoordenatesLabel(item);
                $scope.updateBoundingRect(item);
                $scope.updateSnapLines();
                $scope.updateUploadZone(item);
                $scope.updateApp();
            }
        }
    };
    $scope.snapLayer = function(item){
        if(item){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
            stage = $scope.stages[$scope.currentStage],
            left = item.get('left'),
            top = item.get('top'),
            translateLeft = 0,
            translateTop = 0,
            threshold = 4,
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            var bound = item.getBoundingRect(true);
            switch ($scope.settings.snapMode.type) {
                case 'layer':
                    _canvas.forEachObject(function(obj) {
                        if( obj === item ) return;
                        var _bound = obj.getBoundingRect(true);
                        if(Math.abs(bound.left - _bound.left) < threshold){
                            translateLeft = bound.left - _bound.left;
                            console.log(translateLeft);
                        }
//                        if(Math.abs(bound.left + bound.width - _bound.left) < 1){
//                            if( Math.abs(bound.left + bound.width - _bound.left) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width - _bound.left;
//                        }
//                        if(Math.abs(bound.left - _bound.left - _bound.width) < 1){
//                            if( Math.abs(bound.left - _bound.left - _bound.width) < Math.abs(translateLeft)  ) translateLeft = bound.left - _bound.left - _bound.width;
//                        }
//                        if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1){
//                            if( Math.abs(bound.left + bound.width - _bound.left - _bound.width) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width - _bound.left - _bound.width;
//                        }
//                        if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1){
//                            if( Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width / 2 - _bound.left - _bound.width / 2;
//                        }
                        
                        
//                        if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
//                        if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
//                        if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
//                        
//                        if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
//                        
//                        if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;  
                    });
                    item.set({
                        left: item.left - translateLeft
                    });
                    break;
                case 'bounding':
                    if(  Math.abs( bound.left - _canvas.width ) < threshold ){
                        translateLeft = ( bound.left - _canvas.width ) / scale;
                    }else if( Math.abs( bound.left + bound.width - _canvas.width ) < threshold ){
                        translateLeft = ( _canvas.width - bound.width - bound.left) / scale;
                    }else if( Math.abs( item.left ) < threshold ){
                        translateLeft = item.left;
                    }
//                    if(  Math.abs( bound.top - _canvas.height ) < threshold ){
//                        translateTop = ( bound.top - _canvas.height ) / scale;
//                    }else if( Math.abs( bound.top + bound.height - _canvas.height ) < threshold ){
//                        translateTop = ( _canvas.height - bound.height) / scale;
//                    }else if( Math.abs( item.top ) < threshold ){
//                        translateTop = item.top;
//                    }
                    break;
                case 'grid':
                    var grid = 10;
                    if ( (item.left * scale - Math.round(item.left * scale / grid) * grid) < threshold ){
                        item.set({
                            left: Math.round(item.left * scale / grid) * grid / scale
                        });
                        item.setCoords();
                    }
                    if ( (item.top * scale - Math.round(item.top * scale / grid) * grid) < threshold ){
                        item.set({
                            top: Math.round(item.top * scale / grid) * grid / scale
                        });
                        item.setCoords();
                    }
                    break;
            }
//            if( $scope.settings.snapMode == 'layer' || $scope.settings.snapMode == 'bounding' ){
//                item.set({
//                    left: item.left - translateLeft,
//                    top: item.top - translateTop
//                });
//                item.setCoords();
//                console.log(item.getBoundingRect(true));
//                console.log(item.width * item.scaleX);
//            }
        }
        $scope.afterObjectModify();
    };
    $scope.updateUploadZone = function(item){
        var type = item.get('type'),
        elementUpload = item.get('elementUpload');
        if( (type == 'image' || type == 'custom-image' ) && elementUpload  ){
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {
                visibility: 'visible',
                top: item.oCoords.tl.y - 1,
                left: item.oCoords.tl.x - 1,
                width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                transform: "rotate("+item.angle+"deg)"
            });
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'}); 
        }
    };
    $scope.updateMaskZone = function( item ){
        var type = item.get('type'),
        isMask = item.get('isMask');
        if( isMask ){
            
        }
    };
    $scope.updateAngleLabel = function( item ){
        if(item){
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {
                style: {
                    transform: "rotate("+item.angle+"deg)",
                    top: item.oCoords.mtr.y,
                    left: item.oCoords.mtr.x,
                    visibility: 'visible'
                },
                angle: fabric.util.toFixed(item.angle, 0)
            });
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});
        }
    };
    $scope.updateCoordenatesLabel = function(item){
        if(item){
            var top = item.oCoords.tl.y,
                left = item.oCoords.tl.x;
            if( (item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90) 
                    || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270) ){
                if( item.oCoords.tr.x < left ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.x < left ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.x < left ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }
            }else{
                if( item.oCoords.tr.y < top ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.y < top ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.y < top ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }
            }
            angular.merge($scope.stages[$scope.currentStage].states.coordinates, {
                style: {
                    visibility: 'visible',
                    top: top,
                    left: left
                },
                top: parseInt(top),
                left: parseInt(left)
            });
        }
    };
    $scope.updateBoundingRect = function(item){
        var stage = $scope.stages[$scope.currentStage];
        if(item){
            angular.merge(stage.states.boundingObject, {
                visibility: 'visible',
                top: item.oCoords.tl.y - 1,
                left: item.oCoords.tl.x - 1,
                width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                transform: "rotate("+item.angle+"deg)"
            });
            stage.states.boundingRealSize = {
                size: (item.width * item.scaleX / stage.config.cwidth * stage.config.pWidth).toFixed(2) +'x'+ (item.height * item.scaleY / stage.config.cheight * stage.config.pHeight).toFixed(2) + '' + $scope.settings.nbdesigner_dimensions_unit,
                transform: (item.angle > 270 || item.angle < 90 ) ? "rotate(0deg)" : "rotate(180deg)"
            };
            $scope.updateApp();
        }else{
            angular.merge(stage.states.boundingObject, {visibility: 'hidden'});
            angular.merge(stage.states.coordinates, {visibility: 'hidden'});
        }
    };
    $scope.updateCorners = function(){
        if( checkMobileDevice() ) return;
        var stage = $scope.stages[$scope.currentStage];
        stage.states.corners = [];

        function getCornerCursor( corner ){
            if( corner === 'mtr' ){
                return 'crosshair';
            }else{
                var cursorOffset = {
                    mt: 0,
                    tr: 1,
                    mr: 2,
                    br: 3,
                    mb: 4,
                    bl: 5,
                    ml: 6,
                    tl: 7
                },
                cursorMap = [
                    'n-resize',
                    'ne-resize',
                    'e-resize',
                    'se-resize',
                    's-resize',
                    'sw-resize',
                    'w-resize',
                    'nw-resize'
                ],
                n = Math.round((item.angle % 360) / 45);
                if (n < 0) {
                    n += 8;
                }
                n += cursorOffset[corner];
                n %= 8;
                return cursorMap[n];
            }
        }
        var item = stage.canvas.getActiveObject();
        if(item){
            var controls = item.get('_controlsVisibility');
            var items = stage.canvas.getActiveObjects();
            if( controls || items.length ){
                var canvasWidth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                canvasHeight = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                ['tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'].forEach(function(control){
                    if( ( controls && controls[control] ) || items.length ){
                        var _style = {
                            left: item.oCoords[control].x - fabric.Object.prototype.cornerSize / 2,
                            top: item.oCoords[control].y - fabric.Object.prototype.cornerSize / 2,
                            width: fabric.Object.prototype.cornerSize,
                            height: fabric.Object.prototype.cornerSize,
                            cursor: getCornerCursor( control )
                        };
                        if( item.oCoords[control].x < 0 || item.oCoords[control].x > canvasWidth || item.oCoords[control].y < 0 || item.oCoords[control].y > canvasHeight ){
                            stage.states.corners.push({
                                type: control,
                                style: _style
                            })
                        }
                    }
                });
                if( stage.states.corners.length ){
                    stage.states.corners.push({
                        type: '',
                        style: {
                            top: item.oCoords.tl.y - 1,
                            left: item.oCoords.tl.x - 1,
                            width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                            height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                            transform: "rotate("+item.angle+"deg)"
                        }
                    })
                }
            }
        }

        $scope.updateApp();
    };
    $scope.updateSnapLines = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
            item = _canvas.getActiveObject(),
            position = {
                ht: {top: -9999},
                hb: {top: -9999},
                hc: {top: -9999},
                vl: {left: -9999},
                vr: {left: -9999},
                vc: {left: -9999},
                hcc: {top: -9999},
                vcc: {left: -9999},
                vel: {left: -9999},
                ver: {left: -9999},
                het: {top: -9999},
                heb: {top: -9999}
            };
        if( item ){
            var bound = item.getBoundingRect();
            _canvas.forEachObject(function(obj) {
                if( obj === item ) return;
                var _bound = obj.getBoundingRect();
                if(Math.abs(bound.left - _bound.left) < 1)  position.vl.left = _bound.left;
                if(Math.abs(bound.left + bound.width - _bound.left) < 1) position.vr.left = _bound.left;
                if(Math.abs(bound.left - _bound.left - _bound.width) < 1)  position.vl.left = _bound.left + _bound.width;
                if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
                if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
                if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1)  position.vr.left = _bound.left + _bound.width;
                if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) position.vc.left = _bound.left + _bound.width / 2;
                if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;  
            });
            if(Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1)  position.vcc.left = _canvas.width / 2;
            if(Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1)  position.hcc.top = _canvas.height / 2;
            
            if(Math.abs(bound.left) < 1)  position.vel.left = 0;
            if(Math.abs(bound.top) < 1)  position.het.top = 0;
            if(Math.abs(bound.left + bound.width - _canvas.width) < 1)  position.ver.left = _canvas.width;
            if(Math.abs(bound.top + bound.height - _canvas.height) < 1)  position.heb.top = _canvas.height;
            
            angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
        }
    };
    $scope.updateWarning = function(item){
        if($scope.settings.showWarning.oos){
            var stage = $scope.stages[$scope.currentStage];
            var _canvas = stage['canvas'],
            bound = item.getBoundingRect();
            if( bound.left < 0 || bound.top < 0 || (bound.left + bound.width) > (_canvas.width)|| (bound.top + bound.height) > (_canvas.height)  ){
                stage.states.oos = true;
            }else{
                stage.states.oos = false;
            }
            $scope.updateApp();
        }
    };
    $scope.onObjectModified = function(id, options){
        var item = options.target;
        var newAngle = item.angle;
        newAngle = (Math.abs(item.angle - 0) <= 1 || Math.abs(item.angle - 360) <= 1 ) ? 0 : ( Math.abs(item.angle - 180) <= 1 ? 180 : newAngle );
        item.set({angle: newAngle, dirty: true});
        /*if( $scope.stages[$scope.currentStage].tempParameters ){
            $scope.setHistory({
                element: item,
                parameters: $scope.stages[$scope.currentStage].tempParameters,
                interaction: 'modify'
            });
            $scope.stages[$scope.currentStage].tempParameters = null;
        }*/
        $scope.setHistory($scope.currentStage, true);
        if( $scope.stages[$scope.currentStage].states.isText && $scope.stages[$scope.currentStage].states.type != 'curvedText' && NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no'){
            var newFontSize = item.fontSize * item.scaleX;
            var lastScaleX = item.scaleX;
            var newPtFontSize = newFontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont;
            var minSize = arrayMin($scope.listFontSizeInPt),
                maxSize = arrayMax($scope.listFontSizeInPt);
            if( $scope.forceMinSize && minSize > newPtFontSize ){
                newPtFontSize = minSize;
                newFontSize   = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
            }
            if( $scope.forceMaxSize && maxSize < newPtFontSize ){
                newPtFontSize = maxSize;
                newFontSize   = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
            }
            newPtFontSize = newPtFontSize.toFixed(2);
            item.set({
                dirty: true,
                scaleX: 1,
                scaleY: 1,
                fontSize: newFontSize,
                ptFontSize: newPtFontSize,
                width: item.width * lastScaleX
            });
            $scope.stages[$scope.currentStage].states.text.fontSize = newFontSize;
            $scope.stages[$scope.currentStage].states.text.ptFontSize = newPtFontSize;
        }

        $scope.updateWarning(item);
        $scope.stageDesignChanged();

        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage['canvas'];
        $scope.originPDFs[$scope.currentStage] = [];
        _canvas.forEachObject(function(obj, index) {
            if( angular.isDefined( obj.origin_pdf ) ){
                $scope.originPDFs[$scope.currentStage].push({
                    index: index,
                    origin_pdf: obj.origin_pdf,
                    top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                    left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                    width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                    height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                });
            }
        });
    };
    $scope.updateTextPxFontSize = function (item) {
        var textTypes = ['i-text', 'text', 'textbox'],
            itemType = item.get('type');
        if (textTypes.indexOf(itemType) > -1) {
            if (NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no') {
                var lastScaleX = item.scaleX,
                ptFontSize = item.ptFontSize,
                newFontSize = ptFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                item.set({
                    dirty: true,
                    scaleX: 1,
                    scaleY: 1,
                    fontSize: newFontSize,
                    width: item.width * lastScaleX
                });
            }
        }
    };
    $scope.onBeforeRender = function(id, options){};
    $scope.onAfterRender = function(id, options){
        var stage = $scope.stages[id];
        if( !stage ) return;
        var _canvas = stage['canvas'];
        function checkLayerById( id ){
            var check = false;
            _canvas.forEachObject(function(obj) {
                if(obj.get('itemId') == id) check = true;
            });
            return check;
        }
        $scope.stages[$scope.currentStage].states.lostCharLayers = $scope.stages[$scope.currentStage].states.lostCharLayers.filter(function(layerId){
            return checkLayerById( layerId );
        });
    };
    $scope.onSelectionCleared = function(id, options){
        $scope.stages[$scope.currentStage].states.isActiveLayer = false;
        $scope.stages[$scope.currentStage].states.itemId = null;
        $scope.stages[$scope.currentStage].states.isEditing = false;
        angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
        $scope.stages[$scope.currentStage].states.elementUpload = false;
        $scope.stages[$scope.currentStage].states.oos = false;
        $scope.stages[$scope.currentStage].states.ilr = false;
        $scope.updateMaskLayer();
    };
    $scope.onEditingEntered = function(id, options){
        $scope.stages[$scope.currentStage].states.isEditing = true;     
        $scope.updateApp();
    };    
    $scope.onEditingExited = function(id, options){
        $scope.stages[$scope.currentStage].states.isEditing = false;
        var item = options.target;
        if( item ){
            $scope.updateLayersList();
        }
        $scope.updateApp();
    };
    $scope.onSelectionChanged = function(id, options){
        $scope.getCurrentLayerInfo();
        var item = options.target;
        $scope.updateUploadZone(item);
        $scope.updateWarning(item);
        if( $scope.stages[$scope.currentStage].states.isGroup ){
            $scope.stages[$scope.currentStage].states.ilr = false;
        }else if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0' ){
            $scope.hideRotateControl( item );
        }
        if( $scope.stages[$scope.currentStage].states.isMask ){
            $scope.hideRotateControl( item );
        }
        $scope.updateMaskLayer( item );
    };
    $scope.onSelectionUpdated = function(id, options){
        $scope.getCurrentLayerInfo();
        $scope.updateUploadZone(options.target);
        $scope.updateWarning(options.target);
        if( $scope.stages[$scope.currentStage].states.isGroup ){
            $scope.stages[$scope.currentStage].states.ilr = false;
        }
        var item = options.target;
        if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0' ){
            if( !!item.get('itemId') ) $scope.hideRotateControl( item );
        }
        if( $scope.stages[$scope.currentStage].states.isMask ){
            if( !!item.get('itemId') ) $scope.hideRotateControl( item );
        }else{
            if( !!item.get('itemId')  ) $scope.updateMaskLayer( item );
        }
    };
    $scope.onSelectionCreated = function(id, options){
        $scope.getCurrentLayerInfo();
        $scope.updateUploadZone(options.target);
        $scope.updateWarning(options.target);
        $scope.toggleTip();
        var item = options.target;
        $scope.updateMaskLayer( item );
        if( ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0' ){
            $scope.hideRotateControl( item );
        }
        if( $scope.stages[$scope.currentStage].states.isMask ){
            $scope.hideRotateControl( item );
        }
    }; 
    $scope.hideRotateControl = function( item ){
        if( item != null ){
            item.set({hasRotatingPoint: false});
        }
    };
    $scope.onTextChanged = function(id, options){
        var item = options.target;
        if( item ){
            $scope.normalizeText( item );
            if( angular.isDefined( item.field_mapping ) ){
                _.each($scope.stages, function(stage, index){
                    var _canvas = stage.canvas;
                    _canvas.forEachObject(function(obj) { 
                        if( angular.isDefined( obj.field_mapping ) && item.field_mapping == obj.field_mapping ){
                            obj.text = item.text;
                        }
                    });
                });
            }
            if( $scope.settings.nbdesigner_enable_text_check_lang == 'yes' ){
                $scope.checkCharacter( item );
            }
            $scope.updateLayersList();
        }
        angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});   
        $scope.updateApp();
    };
    $scope.normalizeText = function( item ){
        if( !!String.prototype.normalize ){
            var normalizeText = item.text.normalize();
            if( item.text != normalizeText ){
                item.text = normalizeText;
            }
        }
    };
    $scope.checkCharacter = function( object ){
        var font = _.filter($scope.resource.font.data, { alias: object.get('fontFamily') })[0];
        var arr = [], 
            check = true,
            text = object.text.replace(/\r?\n|\r/gm, ''),
            fontWeight = object.get('fontWeight'),
            fontStyle = object.get('fontStyle'),
            itemId = object.get('itemId'),
            font_url = '';
        if( fontWeight == 'bold' ){
            if( fontStyle == 'italic' ){
                font_url = font.file.bi;
            } else {
                font_url = font.file.b;
            }
        } else {
            if( fontStyle == 'italic' ){
                font_url = font.file.i;
            } else {
                font_url = font.file.r;
            }
        }
        if( font_url == 1 ) return;
        if( font.type != 'google' ){
            font_url = NBDESIGNCONFIG['font_url'] + font_url;
        }else{
            font_url = font_url.replace('http:', 'https:');
        }
        opentype.load( font_url, function (err, font) {
            if( err ){
                console.log(err);
            }else{
                $scope.currentJsFont = font;
                var glyphs = font.glyphs.glyphs;
                _.each(glyphs, function(glyph, index){
                    arr['g-' + glyph.unicode] = 1;
                });
                for(var i = 0; i < text.length; i++){
                    var uc_index = 'g-' + text.charCodeAt(i);
                    if( angular.isUndefined( arr[uc_index] ) ){
                        check = false;
                    }
                }
                var _index = _.findIndex($scope.stages[$scope.currentStage].states.lostCharLayers, function(layerId) { return layerId == itemId; });
                if( !check ){
                    object.set({lostChar: 1});
                    if( _index == -1 ) $scope.stages[$scope.currentStage].states.lostCharLayers.push( itemId );
                } else {
                    delete object.lostChar;
                    if( _index > -1 ) $scope.stages[$scope.currentStage].states.lostCharLayers.splice(_index, 1);
                }
                $scope.updateLayersList();
            }
        });
    };
    $scope.currentJsFont = null;
    $scope.onClickDone = function () {
        $scope.stages[$scope.currentStage].states.isShowToolBox = false;
        $scope.updateApp();
        $scope.renderStage();
        jQuery('html,body').animate({
            scrollTop: jQuery("#nbd-vista-app").offset().top
        }, 'slow');
    };
    $scope.canAddMoreLayer = function(){
        $check = true;
        if( $scope.settings.nbdesigner_prevent_add_more_layer == 'yes' && !$scope.isTemplateMode ) $check = false;
        return $check;
    }
    $scope.canDeleteLayer = function(){
        $check = true;
        if( $scope.settings.nbdesigner_prevent_delete_template_layer == 'yes' && !$scope.isTemplateMode ) $check = false;
        return $check;
    }
    $scope.setPositionToolbox = function () {
        if( appConfig.isModern ) return;
        $timeout(function(){
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                object = _canvas.getActiveObject(),
                objects = _canvas.getActiveObjects();

            var $vista = jQuery('.nbd-vista'),
                $stageActive = jQuery('.nbd-vista .stage.nbd-active'),
                $stageMainActive = jQuery('.nbd-vista .stage.nbd-active .stage-main'),
                $layout = jQuery('.nbd-vista .nbd-layout'),
                $toolMain = jQuery('.nbd-vista .v-toolbox .nbd-nav-tab[data-tab="tab-main-box"]');

            var bound =  object.getBoundingRect(),
                stage = $scope.stages[$scope.currentStage];

            var ratioScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                paddingL = parseInt($stageActive.css('padding-left').slice(0, -2)),
                paddingT = parseInt($stageActive.css('padding-top').slice(0, -2)),
                paddingB = parseInt($stageActive.css('padding-bottom').slice(0, -2)),
                paddingR = parseInt($stageActive.css('padding-right').slice(0, -2)),
                pLeft = 0,
                pTop = 0,
                transform = 'translateX(-50%)',
                _canvasWidth = _canvas.width,
                _canvasHeight = _canvas.height,
                mTop = stage.config.top * ratioScale,
                mBottom = (stage.config.cheight - stage.config.top - stage.config.height) * ratioScale,
                mRight = (stage.config.cwidth - stage.config.left - stage.config.width) * ratioScale,
                mLeft = stage.config.left * ratioScale,
                boundTop = bound.top + bound.height,
                boundLeft = bound.left + bound.width,
                _boundLeft = bound.left + bound.width / 2,
                scrollXHeight = 5,
                scrollYWidth = 5,
                scrollTop = $stageActive.scrollTop(),
                scrollLeft = $stageActive.scrollLeft();
            $toolMain.each(function (index, value) {
                jQuery(this).triggerHandler('click');
            });

            if( $stageMainActive.height() > ( $stageActive.height() - scrollXHeight ) ){
                if( ( $stageMainActive.height() - mBottom ) > ($stageActive.outerHeight() + scrollTop - paddingT) ){
                    if( (boundTop + mTop) > ($stageActive.outerHeight() + scrollTop) ){
                        pTop = $stageActive.outerHeight();
                    }else{
                        pTop = boundTop + mTop - scrollTop + paddingT;
                    }
                }else{
                    if( boundTop > _canvas.height ){
                        pTop = $stageMainActive.height() - mBottom - scrollTop + paddingT; 
                    }else{
                        pTop = boundTop + mTop - scrollTop + paddingT; 
                    }
                }
            } else{
                if ( (bound.top + bound.height) > _canvas.height ) {
                    pTop = _canvas.height + paddingT + mTop;
                }else{
                    pTop = boundTop + paddingT + mTop;
                }
            }
            pTop += 7;
            stage.states.toolboxTriangle = 'center';
            if( $stageMainActive.width() > ( $stageActive.width() - scrollYWidth ) ){
                if( (_boundLeft + mLeft - scrollLeft + paddingL) < 0 ){
                    pLeft = 0;
                    transform = 'translateX(0)';
                }else if( (_boundLeft + mLeft - scrollLeft + paddingL - $stageActive.outerWidth() ) > 0 ){
                    pLeft = $stageActive.outerWidth();
                    transform = 'translateX(-100%)';
                }else{
                    pLeft = _boundLeft + mLeft - scrollLeft + paddingL;
                }
            }else{
                if( _boundLeft < 0 ){
                    pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft;
                    transform = 'translateX(0)';
                }else if( _boundLeft > _canvas.width ){
                    pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft + _canvas.width;
                    transform = 'translateX(-100%)';
                }else{
                    pLeft = ( $stageActive.outerWidth() - $stageMainActive.width() ) / 2 + mLeft + _boundLeft;
                }
            }
            pLeft -= 7;
            if( pLeft + 160 > $stageActive.outerWidth() ){
                pLeft = $stageActive.outerWidth();
                transform = 'translateX(-100%)';
            };
            if( pLeft < 160 ){
                transform = 'translateX(0)';
                pLeft = 0;
            };
            stage.states.toolboxStyle = {
                top: pTop,
                left: pLeft,
                transform: transform
            };
        });
    };
    $scope.getCurrentLayerInfo = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
        object = _canvas.getActiveObject(),
        objects = _canvas.getActiveObjects();

        ['isActiveLayer', 'enableRotate', 'enableOpacity', 'enableChangePathColor', 'enableShadow'].forEach(function(key){
            $scope.stages[$scope.currentStage].states[key] = true;
        });
        ['isGroup', 'isNativeGroup', 'isLayer', 'isText', 'isImage', 'isPath', 'isShape', 'isEditing', 'isMask', 'isMasked', 'lockMask', 'isEmptyMask', 'isTemMask', 'elementUpload', 'isGroupText', 'srcChanged'].forEach(function(key){
            $scope.stages[$scope.currentStage].states[key] = false;
        });
        
        if(appConfig.isVisual) $scope.setPositionToolbox();
        if( objects.length > 1 ){
            $scope.stages[$scope.currentStage].states.isGroup = true;
            if( appConfig.isVisual ){
                var textType = ['i-text', 'text', 'textbox', 'curvedText'];
                _.each(objects, function (item, key) {
                    if (!_.includes(textType,item.get('type'))) {
                        $scope.stages[$scope.currentStage].states.isGroupText = false;
                        return false;
                    }
                });
            }
        }else{
            $scope.stages[$scope.currentStage].states.isLayer = true;
            if( object ){
                if(!object.get('itemId')) {
                    var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    object.set({"itemId" : itemId});
                }
                ['isMask', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask'].forEach(function(key){
                    if( object.get(key) ){
                        $scope.stages[$scope.currentStage].states[key] = true;
                    }
                });
                if( !!object.get('maskId') ){
                    $scope.stages[$scope.currentStage].states.isMasked = true; 
                }
                $scope.stages[$scope.currentStage].states.ilr  = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                $scope.stages[$scope.currentStage].states.forceLock  = angular.isDefined(object.get('forceLock')) ? object.get('forceLock') : false;
                $scope.stages[$scope.currentStage].states.opacity = fabric.util.toFixed(object.get('opacity') * 100);
                ['type', 'itemId', 'lockMovementX', 'lockMovementY', 'lockScalingX', 'lockScalingY', 'lockRotation', 'lockUniScaling', 'selectable', 'visible', 'angle', 'excludeFromExport', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent', 'v_card'].forEach(function(key){
                    var val = object.get(key);
                    if( key == 'angle' && val < 0 ){
                        val += 360;
                    }
                    $scope.stages[$scope.currentStage].states[key] = val;
                });
                switch(object.type) {
                    case 'i-text':
                    case 'text':
                    case 'textbox':
                    case 'curvedText':
                        angular.copy($scope.defaultStageStates.text, $scope.stages[$scope.currentStage].states.text);
                        $scope.addColor(tinycolor(object.get('fill')).toHexString());
                        $scope.stages[$scope.currentStage].states.isText = true;
                        $scope.stages[$scope.currentStage].states.isEditing = object.isEditing ? object.isEditing : false;
                        $scope.stages[$scope.currentStage].states.fixedWidth = angular.isDefined(object.fixedWidth) ? object.fixedWidth : false;
                        $scope.stages[$scope.currentStage].states.text = {
                            font: $scope.getFontInfo(object.get('fontFamily')),
                            is_uppercase: $scope.isUpperCase(object)
                        };
                        ['fontFamily', 'ptFontSize', 'fontSize', 'editable', 'textAlign', 'fontWeight', 'textDecoration', 'fontStyle', 'spacing', 'lineHeight', 'fill', 'charSpacing', 'textBackgroundColor', 'stroke', 'strokeWidth', 'text'].forEach(function(key){
                            $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                        });
                        if( angular.isUndefined($scope.stages[$scope.currentStage].states.text.ptFontSize) ){
                            $scope.stages[$scope.currentStage].states.text.ptFontSize = ( $scope.stages[$scope.currentStage].states.text.fontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont ).toFixed(2);
                        }
                        if( $scope.stages[$scope.currentStage].states.text.textBackgroundColor == '' ) $scope.stages[$scope.currentStage].states.text.textBackgroundColor = '#ffffff';
                        if( !$scope.stages[$scope.currentStage].states.text.stroke ) $scope.stages[$scope.currentStage].states.text.stroke = '#ffffff';
                        if( object.type == 'curvedText' ){
                            ['reverse', 'spacing', 'radius'].forEach(function(key){
                                $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                            });
                            $scope.stages[$scope.currentStage].states.text.rtl = angular.isDefined( object.rtl ) ? object.rtl : false;
                            if( $scope.stages[$scope.currentStage].states.text.rtl ){
                                $scope.stages[$scope.currentStage].states.text.text = $scope.stages[$scope.currentStage].states.text.text.split('').reverse().join('');
                            };
                            $timeout(function(){
                                jQuery('.item-curved').addClass('active');
                                if( $scope.settings.is_mobile ) jQuery('.main-toolbar').addClass('overflow-hidden');
                            }, 300);
                        }else{
                            if( $scope.settings.is_mobile ) jQuery('.main-toolbar').removeClass('overflow-hidden');
                        };
                        $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false;
                        $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_text_opacity == '1' ? true : false;
                        $scope.stages[$scope.currentStage].states.enableShadow = ( NBDESIGNCONFIG.nbdesigner_text_shadow == '1' && NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ) ? true : false;
                        break;
                    case 'image':
                    case 'custom-image':
                        $scope.stages[$scope.currentStage].states.elementUpload  = angular.isDefined(object.get('elementUpload')) ? object.get('elementUpload') : false;
                        $scope.stages[$scope.currentStage].states.ilr  = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                        $scope.stages[$scope.currentStage].states.isImage = true;
                        $scope.stages[$scope.currentStage].states.src = object.getSvgSrc();
                        $scope.stages[$scope.currentStage].states.origin_src = angular.isDefined( object.origin_src ) ? object.origin_src :  object.getSvgSrc();
                        if( angular.isDefined( object.origin_url ) ){
                            $scope.stages[$scope.currentStage].states.origin_url = object.origin_url;
                            $scope.stages[$scope.currentStage].states.origin_width = object.origin_width;
                            $scope.stages[$scope.currentStage].states.origin_height = object.origin_height;
                        }else{
                            delete $scope.stages[$scope.currentStage].states.origin_url;
                            delete $scope.stages[$scope.currentStage].states.origin_width;
                            delete $scope.stages[$scope.currentStage].states.origin_height;
                        }
                        ['crop_left', 'crop_top', 'crop_width', 'crop_height', 'crop_scaleX', 'crop_scaleY'].forEach(function(key){
                            if( angular.isDefined(object[key]) ){
                                $scope.stages[$scope.currentStage].states[key] = object[key];
                            }
                        });
                        $scope.stages[$scope.currentStage].states.filters = [];
                        if( $scope.settings.enableImageFilter ){
                            $scope.availableFilters.forEach(function(filter){
                                $scope.stages[$scope.currentStage].states.filters[filter] = $scope.checkActiveFilter( filter, object.filters );
                            });
                        }
                        break;
                    case 'rect':
                    case 'triangle':
                    case 'polygon':
                    case 'circle':
                    case 'ellipse':
                    case 'line':
                    case 'polyline':
                        $scope.stages[$scope.currentStage].states.isShape = true;
                        if( NBDESIGNCONFIG.nbdesigner_clipart_change_path_color == '1' ){
                            $scope.stages[$scope.currentStage].states.geoObject = {
                                fill: object.get('fill'),
                                stroke: object.get('stroke') ? object.get('stroke') : '#ffffff',
                                strokeWidth: object.get('strokeWidth') ? object.get('strokeWidth') : 0,
                                strokeDashArray: object.get('strokeDashArray') ? object.get('strokeDashArray') : ['', ''],
                                strokeUniform: object.get('strokeUniform')
                            };
                        }
                        $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_clipart_rotate == '1' ? true : false;
                        $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_clipart_opacity == '1' ? true : false;
                        break;
                    case 'path-group':
                    case 'path':
                    case 'group':
                        $scope.stages[$scope.currentStage].states.isPath = true;
                        if( NBDESIGNCONFIG.nbdesigner_clipart_change_path_color == '1' ){
                            $scope.stages[$scope.currentStage].states.svg.groupPath = $scope.getPathOfSvg(object);
                        }else{
                            $scope.stages[$scope.currentStage].states.svg.groupPath = [];
                        }
                        if( object.type == 'group' ) $scope.stages[$scope.currentStage].states.isNativeGroup = true;
                        $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_clipart_rotate == '1' ? true : false;
                        $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_clipart_opacity == '1' ? true : false;
                        break; 
                    default:
                        break;
                }

                if( $scope.stages[$scope.currentStage].states.enableShadow ){
                    if( object.shadow ){
                        var colorArr = fabric.Color.sourceFromRgb( object.shadow.color ),
                        color = fabric.Color.fromRgb( object.shadow.color );
                        $scope.stages[$scope.currentStage].states.shadow = {
                            color: '#' + color.toHex(),
                            offsetX: object.shadow.offsetX,
                            offsetY: object.shadow.offsetY,
                            blur: object.shadow.blur,
                            opacity: colorArr[3]
                        }
                    } else {
                        $scope.stages[$scope.currentStage].states.shadow = angular.copy( $scope.defaultStageStates.shadow );
                    }
                }
            }
        }
        $scope.updateApp();
    };
    /* Utility functions */
    $scope.tips = {
        total: 3,
        current: 1,
        firstTime: true
    };
    $scope.toggleTip = function( close ){
        var first_visitor = getCookie("nbdesigner_user");
        if( angular.isDefined( close ) ){
            if( close ){
                jQuery('.nbd-tip').removeClass('nbd-show');
                if( $scope.tips.firstTime ){
                    $timeout(function(){
                        $scope.tips.current = 2;
                        $scope.toggleTip( false );
                    }, 10000);
                }
                $scope.tips.firstTime = false;
            }else{
                jQuery('.nbd-tip').addClass('nbd-show');
            }
        }else{
            if (first_visitor == "") {
                setCookie("nbdesigner_user", 'Hello World', 0.5);
                jQuery('.nbd-tip').addClass('nbd-show');
            }
        }
    };
    $scope.nextTip = function(){
        $scope.tips.current = $scope.tips.current == $scope.tips.total ? 1 : ( $scope.tips.current + 1 );
    };
    $scope.startCountTime = function(){
        $scope.startTime = new Date();
    };
    $scope.endCountTime = function(){
        var endTime = new Date();
        console.log((endTime - $scope.startTime) + " ms");
    };
    $scope.getFontInfo = function(alias){
        var font = _.filter($scope.resource.font.data, { alias: alias })[0],
            _font = angular.copy(font, _font);
        if(_font){    
            _font.file = {r: font.file.r};
            _font.file.i = angular.isDefined(font.file.i) ? font.file.i : 0;
            _font.file.b = angular.isDefined(font.file.b) ? font.file.b : 0;
            _font.file.bi = angular.isDefined(font.file.bi) ? font.file.bi : 0;
        }else{
            _font = {name: 'Roboto', alias: 'Roboto', file: {r: 1, b: 1, i: 1, bi: 1}, cat: ["99"], type:"google",subset:"latin"};
        }
        return _font;
    };
    $scope.getPathOfSvg = function(object){
        var groupPath = [];
        _.each(object._objects, function(path, index){
            if( path.get('fill') != '' ){
                var color = tinycolor(path.get('fill')).toHexString();
                $scope.addColor(color);
                var findex;
                if(  ( findex = _.findIndex(groupPath, ['color', color]) ) > -1 ){
                    groupPath[findex]['index'].push(index);
                }else{
                    groupPath.push({color: color, index: [index]});
                }
            }
        });
        if(groupPath.length == 0){
            if( object.get('fill') ){
                $scope.addColor(tinycolor(object.get('fill')).toHexString());
                groupPath.push({color: tinycolor(object.get('fill')).toHexString(), index: [-2]});
            }
        }
        if(groupPath.length == 0){
            $scope.addColor(tinycolor(object.get('stroke')).toHexString());
            groupPath.push({color: tinycolor(object.get('stroke')).toHexString(), index: [-1]});
        }
        return groupPath;
    };
    $scope.isUpperCase = function( object ){
        var _isUpperCase = angular.isDefined(object.is_uppercase) ? object.is_uppercase : false;
        return _isUpperCase;
    };  
    $scope.fitRectangle = function(x1, y1, x2, y2, fill){
        var rec = {};
        if(x2 < x1 && y2 < y1){
            if(fill){
                if(x1/y1 > x2/y2){
                    rec.width = x2 * y1 / y2;
                    rec.height = y1;
                    rec.top = 0;
                    rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
                }else {
                    rec.width = x1;
                    rec.height = x1 * y2 / x2;
                    rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
                    rec.left = 0;
                }
            }else {
                rec.top = (x1 - x2) / 2;
                rec.left = (y1 - y2) / 2;
                rec.width = x2;
                rec.height = y2;
            }
        } else if( x1/y1 > x2/y2 ){
            rec.width = x2 * y1 / y2;
            rec.height = y1;
            rec.top = 0;
            rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
        } else {
            rec.width = x1;
            rec.height = x1 * y2 / x2;
            rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
            rec.left = 0;
        }
        return rec;
    };
    $scope.insertTemplateFont = function(font_name, callback){
        if(!_.filter($scope.resource.font.data, ['alias', font_name]).length){
            NBDDataFactory.get('nbd_get_resource', {type: 'google_font',font_name: font_name}, function(data){
                data = JSON.parse(data);
                if( data.flag == 1 ){
                    if(!_.filter($scope.resource.font.data, ['alias', font_name]).length){
                        $scope.resource.font.data.push(data.data);
                    };
                    var fontName = data.data.alias;
                    var font_id = fontName.replace(/\s/gi, '').toLowerCase();
                    if( !jQuery('#' + font_id).length ){
                        jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                    };
                    var font = new FontFaceObserver(fontName);
                    font.load($scope.settings.subsets[data.data.subset]['preview_text']).then(function () {
                        if( angular.isDefined(callback) ) callback(fontName);
                    }, function () {
                        console.log('Fail to load: '+fontName);
                        if( angular.isDefined(callback) ) callback('Roboto');
                    });
                }else{
                    if( angular.isDefined(callback) ) callback('Roboto');
                }
            });  
        }else{
            var _font = $scope.getFontInfo(font_name);
            var fontName = font_name;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if( !jQuery('#' + font_id).length ){
                if(_font.type == 'google'){
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                }else{
                    if( _font.file.r == '1' ){
                        var font_url = _font.url;
                        if(! (font_url.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + font_url; 
                        var css = "";
                        css = "<style type='text/css' id='" + font_id + "' >";
                        css += "@font-face {font-family: '" + fontName + "';";
                        css += "src: ";
                        css += "url('" + font_url + "') format('truetype')";
                        css += "}";
                        css += "</style>";
                        jQuery("head").append(css);
                    }else{
                        var css = "<style type='text/css' id='" + font_id + "' >";
                        _.each(_font.file, function (file, index) {
                            if( file != 0 ){
                                var font_url = file;
                                if(! (file.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + file;
                                css += "@font-face {font-family: '" + fontName + "';";
                                css += "src: ";
                                css += "url('" + font_url + "') format('truetype');";
                                switch(index){
                                    case "r":
                                        css += "font-weight: normal;font-style: normal;"
                                        break;
                                    case "b":
                                        css += "font-weight: bold;font-style: normal;"
                                        break;
                                    case "i":
                                        css += "font-weight: normal;font-style: italic;"
                                        break;
                                    case "bi":
                                        css += "font-weight: bold;font-style: italic;"
                                        break;
                                };
                                css += "}";
                            }
                        });
                        css += "</style>";
                        jQuery("head").append(css);
                    }
                }
            };
            var font = new FontFaceObserver(fontName);
            font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                if( angular.isDefined(callback) ) callback(fontName);
            }, function () {
                console.log('Fail to load: '+fontName);
                if( angular.isDefined(callback) ) callback(fontName);
            });
        };
    };
    $scope.onloadTemplate = false;
    $scope.currentLocalTempId = 0;
    $scope.templateHolderFields = [];
    $scope.insertTemplate = function(local, temp){
        if( $scope.settings.nbdesigner_boosting_load_template == 'yes' ){
            $scope.boostInsertTemplate(local, temp);
            return;
        }

        $scope.currentLocalTempId = temp.id;
        if( angular.isUndefined( temp.doNotShowLoading ) ){
            $scope.toggleStageLoading( 6E4 );
            $scope.showDesignTab();
        }
        $scope.onloadTemplate = true;
        $scope.contextAddLayers = 'template';
        function loadDesign(fonts, design, viewport, konfig){
            var stageIndex = 0;
            function loadStage(stageIndex){
                var _index = 'frame_' + stageIndex,
                stage = $scope.stages[stageIndex],
                _canvas = stage['canvas'],
                layerIndex = 0;
                _canvas.clear();
                if( angular.isUndefined(design[_index]) ){
                    design[_index] = {version:"2.3.3",objects:[]};
                };
                if( angular.isDefined(design[_index].background) ){
                    _canvas.backgroundColor = design[_index].background;
                };
                var objects = design[_index].objects;
                function loadLayer(layerIndex){
                    function continueLoadLayer(){
                        layerIndex++;
                        if( objects.length != 0 && layerIndex < objects.length ){
                            loadLayer(layerIndex);
                        }else{
                            stageIndex++;
                            if( stageIndex < $scope.stages.length ){
                                loadStage(stageIndex);
                            }else{
                                _.each($scope.stages, function(_stage, index){
                                    $scope.renderStage(index);
                                    var layers = _stage.canvas.getObjects();
                                    $scope.renderTextAfterLoadFont(layers, function(){
                                        $scope.deactiveAllLayer();
                                        $scope.renderStage(index);
                                        $timeout(function(){
                                            $scope.deactiveAllLayer();
                                            $scope.renderStage(index);
                                            if( index == $scope.stages.length - 1 ){
                                                $scope.onloadTemplate = false;
                                                $scope.contextAddLayers = 'normal';
                                                if( angular.isDefined(viewport) ){
                                                    $scope.resizeStages(viewport);
                                                } else if( angular.isDefined(konfig) &&  angular.isDefined(konfig.scale) ){
                                                    viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                                    $scope.resizeStages(viewport);
                                                }else{
                                                    $scope.toggleStageLoading();
                                                }
                                                $scope.afterInsertTemplate();
                                            }
                                        }, 500);
                                    });
                                });
                            }
                        }
                    };
                    if( objects.length > 0 ){
                        var item = objects[layerIndex],
                        type = item.type;
                        var mustInsert = true;
                        if( type == 'image' || type == 'custom-image' ){
                            if( appConfig.domainChanged ){
                                var _src = item.src;
                                var src = _src.split('nbdesigner');
                                if( src.length == 2 ){
                                    item.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                }
                                var src2 = _src.split('web-to-print-online-designer/assets/');
                                if( src2.length == 2 ){
                                    item.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                                }
                            };
                            if( angular.isDefined(item.avatar) ){
                                if( angular.isDefined($scope.settings.contact_sheets) ){
                                    item.src = $scope.settings.contact_sheets.avatar;
                                }
                            }
                            if(mustInsert){
                                fabric.Image.fromObject(item, function(_image){
                                    _canvas.add(_image);
                                    continueLoadLayer();
                                });
                            }else{
                                continueLoadLayer();
                            }
                        }else{
                            var klass = fabric.util.getKlass(type);
                            if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                                if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                    stage.states.usedFonts.push($scope.getFontInfo(item.fontFamily));
                                };
                            };
                            ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'title'].forEach(function(val){
                                if( angular.isDefined(item[val]) ){
                                    if( angular.isDefined($scope.settings.user_infos) ){
                                        item.text = $scope.settings.user_infos[val].value;
                                    }
                                }
                            });
                            if( angular.isDefined( item.field_mapping ) && !$scope.isTemplateMode ){
                                var field = _.filter($scope.settings.template_fields, { key: item.field_mapping })[0];
                                if( angular.isDefined( field ) ){
                                    if( field.value != '' ){
                                        if( angular.isDefined( item.is_uppercase ) ){
                                            item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                        }else{
                                            item.text = field.value;
                                        }
                                    }else{
                                        var mapping_field = _.filter($scope.templateHolderFields, { key: item.field_mapping })[0];
                                        if( angular.isUndefined( mapping_field ) ){
                                            $scope.templateHolderFields.push( JSON.parse( JSON.stringify( field ) ) );
                                        }
                                    }
                                }
                            }
                            if( angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1' ){
                                $scope.generateVcard( function( newObject ){
                                    var config = {
                                        left: item.left,
                                        top: item.top,
                                        scaleX: item.scaleX,
                                        scaleY: item.scaleY,
                                        fill: object.fill
                                    };
                                    newObject.set( config );
                                    newObject.scaleToWidth(item.width * item.scaleX);
                                    newObject.scaleToWidth(item.width * item.scaleX);
                                    _canvas.add( newObject );
                                    continueLoadLayer();
                                });
                            } else {
                                if( angular.isDefined(item.vcard) ){
                                    var config = {
                                        left: item.left,
                                        top: item.top,
                                        vcard: 1
                                    };
                                    $scope.strVcard = '';
                                    if( angular.isDefined($scope.settings.user_infos) ){
                                        var infos = $scope.settings.user_infos;
                                        $scope.strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
                                        $scope.strVcard += 'N:'+infos.last_name.value+';'+infos.first_name.value+'\n'+ 'FN:'+infos.full_name.value;
                                        $scope.strVcard += '\nADR;TYPE=home:;;'+infos.address.value+';'+infos.city.value+';;'+infos.postcode.value+';'+infos.country.value;
                                        $scope.strVcard += '\nTEL;TYPE=home:'+infos.phone.value;
                                        $scope.strVcard += '\nTEL;TYPE=work:'+infos.mobile.value;
                                        $scope.strVcard += '\nEMAIL;TYPE=internet,work:'+infos.email.value;
                                        $scope.strVcard += '\nURL;TYPE=work:'+infos.website.value;
                                        $scope.strVcard += '\nEND:VCARD';
                                        var qr = qrcode('0', 'M');
                                        qr.addData( $scope.strVcard );
                                        qr.make();
                                        var _qrcode = qr.createSvgTag();
                                        fabric.loadSVGFromString(_qrcode, function(ob, op) {		
                                            var object = fabric.util.groupSVGElements(ob, op);
                                            object.set(config);
                                            object.scaleToWidth(item.width * item.scaleX);
                                            object.scaleToHeight(item.height * item.scaleY);
                                            object.vcard = 1;
                                            _canvas.add(object);
                                            continueLoadLayer();
                                        });
                                    }else{
                                        klass.fromObject(item, function(item){
                                            _canvas.add(item);
                                            continueLoadLayer();
                                        });
                                    }
                                }else{
                                    if(mustInsert){
                                        if( type == 'text' ){
                                            var text = item.text;
                                            var textobj = {};
                                            angular.copy(item, textobj);
                                            delete textobj.text;
                                            delete textobj.type;
                                            var textbox = new fabric.IText(text, textobj);
                                            _canvas.add(textbox);
                                            continueLoadLayer();
                                        } else if( !!item.isTemMask && !$scope.isTemplateMode ){
                                            klass.fromObject(item, function(item){
                                                item.set({
                                                    isMask: 1,
                                                    absolutePositioned: true,
                                                    strokeWidth: 0,
                                                    lockRotation: true,
                                                    selectable: false,
                                                    _isTemMask: true,
                                                    fill: '#ffffff',
                                                    opacity: 0.001
                                                });
                                                delete item.isTemMask;
                                                _canvas.add(item);
                                                var maskLayer = _canvas.item(_canvas.getObjects().length - 1),
                                                maskId = maskLayer.get( 'itemId' ),
                                                defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                                                fabric.Image.fromURL(defaultMaskImageUrl, function(op) {
                                                    var top = maskLayer.get('top'),
                                                    left = maskLayer.get('left'),
                                                    scaleX = maskLayer.get('scaleX'),
                                                    scaleY = maskLayer.get('scaleY'),
                                                    width = maskLayer.get('width'),
                                                    height = maskLayer.get('height'),
                                                    realWidth = width * scaleX,
                                                    realHeight = height * scaleY,
                                                    newWidth = realWidth,
                                                    newHeight = realHeight;
                                                    if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                                                        newWidth = op.width / op.height * newHeight;
                                                    }else{
                                                        newHeight = op.height / op.width * newWidth;
                                                    }
                                                    var d = new Date(),
                                                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                                                    op.set({
                                                        clipPath: maskLayer,
                                                        perPixelTargetFind: true,
                                                        centeredScaling: true,
                                                        maskId: maskId,
                                                        scaleX: newWidth / op.width,
                                                        scaleY: newHeight / op.height,
                                                        top: top + realHeight / 2,
                                                        left: left + realWidth / 2,
                                                        itemId: itemId,
                                                        isEmptyMask: true,
                                                        srcChanged: false
                                                    });
                                                    if( !!maskLayer.get('forceLock') ) op.set({lockMask: true});
                                                    _canvas.add(op);
                                                    continueLoadLayer();
                                                }, {crossOrigin: 'anonymous'});
                                            });
                                        }else{
                                            klass.fromObject(item, function(item){
                                                _canvas.add(item);
                                                continueLoadLayer();
                                            });
                                        }
                                    }else{
                                        continueLoadLayer();
                                    }
                                }
                            }
                        }
                    }else{
                        continueLoadLayer();
                    }
                };
                loadLayer(layerIndex);
            };
            if(fonts.length){
                _.each(fonts, function(font, index){
                    if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                        if( angular.isDefined(font.file) && angular.isDefined(font.file.r) )$scope.resource.font.data.push(font);
                    };
                    if( index == fonts.length - 1 ){
                        $scope.insertTemplateFont(font.alias, function(){
                            loadStage(stageIndex);
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }else{
                        $scope.insertTemplateFont(font.alias, function(){
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }
                });
            }else{
                loadStage(stageIndex);
            }
        }
        if( local ){
            loadDesign(temp.fonts, temp.design, temp.viewport);
        }else{
            NBDDataFactory.get('nbdesigner_get_product_info', {product_id: NBDESIGNCONFIG['product_id'], variation_id: NBDESIGNCONFIG['variation_id'], template_id: temp.id}, function(data){
                data = JSON.parse(data);
                loadDesign(data.fonts, data.design, data.config.viewport, data.config);
                if( angular.isDefined( data.design_id ) ){
                    NBDESIGNCONFIG.design_id = data.design_id;
                }
            });
        }
    };
    $scope.boostInsertTemplate = function(local, temp){
        $scope.currentLocalTempId = temp.id;
        if( angular.isUndefined( temp.doNotShowLoading ) ){
            $scope.toggleStageLoading( 6E4 );
            $scope.showDesignTab();
        }
        $scope.onloadTemplate = true;
        $scope.contextAddLayers = 'template';

        function loadImageFromUrl( img ){
            return new Promise(resolve => {
                fabric.Image.fromURL(img, op => {
                    resolve(op);
                }, {crossOrigin: 'anonymous'});
            });
        }

        function loadImageFromObject( object ){
            return new Promise(resolve => {
                fabric.Image.fromObject(object, function(image){
                    resolve(image);
                });
            });
        }

        function applyImageFilters( object ){
            return new Promise(resolve => {
                object.applyFilters(false, function(){
                    setTimeout(() => resolve(object));
                }, true);
            });
        }

        function loadLayerFromObject( klass, object ){
            return new Promise(resolve => {
                klass.fromObject(object, function(obj){
                    resolve(obj);
                });
            });
        }

        async function loadPhotoFrameFromObject( klass, object ){
            let item = await loadLayerFromObject( klass, object );
            item.set({
                isMask: 1,
                absolutePositioned: true,
                strokeWidth: 0,
                lockRotation: true,
                selectable: false,
                _isTemMask: true,
                fill: '#ffffff',
                opacity: 0.001
            });
            delete item.isTemMask;

            let maskId = item.itemId,
            defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';

            let op = await loadImageFromUrl( defaultMaskImageUrl );
            var top = item.get('top'),
            left = item.get('left'),
            scaleX = item.get('scaleX'),
            scaleY = item.get('scaleY'),
            width = item.get('width'),
            height = item.get('height'),
            realWidth = width * scaleX,
            realHeight = height * scaleY,
            newWidth = realWidth,
            newHeight = realHeight;
            if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                newWidth = op.width / op.height * newHeight;
            }else{
                newHeight = op.height / op.width * newWidth;
            }
            var d = new Date(),
            itemId = d.getTime() + Math.floor(Math.random() * 1000);
            op.set({
                clipPath: item,
                perPixelTargetFind: true,
                centeredScaling: true,
                maskId: maskId,
                scaleX: newWidth / op.width,
                scaleY: newHeight / op.height,
                top: top + realHeight / 2,
                left: left + realWidth / 2,
                itemId: itemId,
                isEmptyMask: true,
                srcChanged: false
            });
            if( !!item.get('forceLock') ) op.set({lockMask: true});

            return {
                layer: item,
                holder: op
            }
        }

        function generateVcard( object ){
            return new Promise(resolve => {
                $scope.generateVcard( function( newObject ){
                    var config = {
                        left: object.left,
                        top: object.top,
                        scaleX: object.scaleX,
                        scaleY: object.scaleY,
                        fill: object.fill
                    };
                    newObject.set( config );
                    newObject.scaleToWidth(object.width * object.scaleX);
                    newObject.scaleToWidth(object.width * object.scaleX);

                    resolve(newObject);
                });
            });
        }

        function loadDesign(fonts, design, viewport, konfig){
            async function loadStages(){
                async function loadLayer(object, objectIndex, stageIndex){
                    let layer, photoHolder,
                    type = object.type,
                    stage = $scope.stages[stageIndex];
                    if( type == 'image' || type == 'custom-image' ){
                        if( appConfig.domainChanged ){
                            var _src = object.src;
                            var src = _src.split('nbdesigner');
                            if( src.length == 2 ){
                                object.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                            }
                            var src2 = _src.split('web-to-print-online-designer/assets/');
                            if( src2.length == 2 ){
                                object.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                            }
                        };
                        layer = await loadImageFromObject( object );
                        if( layer.filters.length ){
                            layer = await applyImageFilters( layer );
                        }
                    } else {
                        var klass = fabric.util.getKlass(type);
                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                            if(!_.filter(stage.states.usedFonts, ['alias', object.fontFamily]).length){
                                stage.states.usedFonts.push($scope.getFontInfo(object.fontFamily));
                            };
                        };
                        if( angular.isDefined( object.field_mapping ) && !$scope.isTemplateMode ){
                            var field = _.filter($scope.settings.template_fields, { key: object.field_mapping })[0];
                            if( angular.isDefined( field ) ){
                                if( field.value != '' ){
                                    if( angular.isDefined( object.is_uppercase ) ){
                                        object.text = object.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                    }else{
                                        object.text = field.value;
                                    }
                                }else{
                                    var mapping_field = _.filter($scope.templateHolderFields, { key: object.field_mapping })[0];
                                    if( angular.isUndefined( mapping_field ) ){
                                        $scope.templateHolderFields.push( JSON.parse( JSON.stringify( field ) ) );
                                    }
                                }
                            }
                        }

                        if( angular.isDefined(object.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1' ){
                            layer = await generateVcard( object );
                        }else{
                            if( type == 'text' ){
                                var text = object.text;
                                var textobj = {};
                                angular.copy(object, textobj);
                                delete textobj.text;
                                delete textobj.type;
                                layer = new fabric.IText(text, textobj);
                            }else if( !!object.isTemMask && !$scope.isTemplateMode ){
                                let res = await loadPhotoFrameFromObject( klass, object );
                                layer = res.layer;
                                photoHolder = res.holder;
                            }else{
                                layer = await loadLayerFromObject( klass, object );
                            }
                        }
                    }
                    return {
                        layer: layer,
                        itemId: layer.itemId,
                        photoHolder: photoHolder
                    };
                }

                async function loadStage(stageIndex){
                    var _index = 'frame_' + stageIndex,
                    stage = $scope.stages[stageIndex],
                    _canvas = stage['canvas'],
                    layers = [],
                    photoHolders = [];
                    _canvas.clear();
                    if( angular.isUndefined(design[_index]) ){
                        design[_index] = {version:"3.4.0",objects:[]};
                    };
                    if( angular.isDefined(design[_index].background) ){
                        _canvas.backgroundColor = design[_index].background;
                    };
                    var objects = design[_index].objects;

                    await Promise.all(objects.map(async (object, objectIndex) => {
                        let res = await loadLayer(object, objectIndex, stageIndex);
                        layers[objectIndex] = res.layer;
                        if( res.photoHolder ){
                            photoHolders.push( { itemId: res.itemId, photoHolder: res.photoHolder } );
                        }
                    }));

                    photoHolders.map(photoHolder => {
                        let holderIndex;
                        layers.map((layer, layerIndex) => {
                            if( photoHolder.itemId == layer.itemId ) holderIndex = layerIndex;
                        });
                        layers.splice(holderIndex + 1, 0, photoHolder.photoHolder);
                    });

                    layers.map(layer => {
                        _canvas.add( layer );
                    });
                    return true;
                }

                await Promise.all($scope.stages.map(async (stage, stageIndex) => {
                    await loadStage(stageIndex);
                }));

                _.each($scope.stages, function(_stage, index){
                    $scope.renderStage(index);
                    var layers = _stage.canvas.getObjects();
                    $scope.renderTextAfterLoadFont(layers, function(){
                        $scope.deactiveAllLayer();
                        $scope.renderStage(index);
                        $timeout(function(){
                            $scope.deactiveAllLayer();
                            $scope.renderStage(index);
                            if( index == $scope.stages.length - 1 ){
                                $scope.onloadTemplate = false;
                                $scope.contextAddLayers = 'normal';
                                if( angular.isDefined(viewport) ){
                                    $scope.resizeStages(viewport);
                                } else if( angular.isDefined(konfig) &&  angular.isDefined(konfig.scale) ){
                                    viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                    $scope.resizeStages(viewport);
                                }else{
                                    $scope.toggleStageLoading();
                                }
                                $scope.afterInsertTemplate();
                            }
                        }, 500);
                    });
                });

                return true;
            }

            if(fonts.length){
                _.each(fonts, function(font, index){
                    if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                        if( angular.isDefined(font.file) && angular.isDefined(font.file.r) )$scope.resource.font.data.push(font);
                    };
                    if( index == fonts.length - 1 ){
                        $scope.insertTemplateFont(font.alias, function(){
                            loadStages();
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }else{
                        $scope.insertTemplateFont(font.alias, function(){
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }
                });
            }else{
                loadStages();
            }
        }

        if( local ){
            loadDesign(temp.fonts, temp.design, temp.viewport);
        }else{
            NBDDataFactory.get('nbdesigner_get_product_info', {product_id: NBDESIGNCONFIG['product_id'], variation_id: NBDESIGNCONFIG['variation_id'], template_id: temp.id}, function(data){
                data = JSON.parse(data);
                loadDesign(data.fonts, data.design, data.config.viewport, data.config);
                if( angular.isDefined( data.design_id ) ){
                    NBDESIGNCONFIG.design_id = data.design_id;
                }
            });
        }
    };
    $scope._currentTempId = 0;
    $scope._currentpartIndex = 0;
    $scope.insertPartTemplate = function(tempId, partIndex){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        layers = _canvas.getObjects();
        if( layers.length > 0 ){
            $scope._currentTempId = tempId;
            $scope._currentpartIndex = partIndex;
            jQuery('.nbd-popup.insert-part-template-alert').nbShowPopup();
        }else{
            $scope._insertPartTemplate(tempId, partIndex);
        }
    };
    $scope.closePopupInertPartTem = function(){
        jQuery('.insert-part-template-alert .close-popup').triggerHandler('click');
    };
    $scope._insertPartTemplate = function(temp, partIndex){
        $scope.onloadTemplate = true;
        $scope.contextAddLayers = 'template';
        $scope.toggleStageLoading();
        jQuery('.insert-part-template-alert .close-popup').triggerHandler('click');
        function loadDesign(fonts, design, viewport, konfig){
            var _index = 'frame_' + partIndex;
            if( angular.isUndefined( design[_index] ) ){
                return;
            };
            var layerIndex = 0, 
                stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                objects = design[_index].objects;
            function loadStage(){
                _canvas.clear();
                function loadLayer(layerIndex){
                    function continueLoadLayer(){
                        layerIndex++;
                        if( objects.length != 0 && layerIndex < objects.length ){
                            loadLayer(layerIndex);
                        }else{
                            $scope.renderStage($scope.currentStage);
                            var layers = _canvas.getObjects();
                            $scope.renderTextAfterLoadFont(layers, function(){
                                $scope.deactiveAllLayer();
                                $scope.renderStage($scope.currentStage);
                                $timeout(function(){
                                    $scope.deactiveAllLayer();
                                    $scope.renderStage($scope.currentStage);
                                    $scope.onloadTemplate = false;
                                    $scope.contextAddLayers = 'normal';
                                    if( angular.isDefined(viewport) ){
                                        $scope.resizeStage(viewport);
                                    } else if( angular.isDefined(konfig) &&  angular.isDefined(konfig.scale) ){
                                        viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                        $scope.resizeStage(viewport);
                                    }else{
                                        $scope.toggleStageLoading();
                                    }
                                }, 100);
                            });
                        }
                    }
                    if( objects.length > 0 ){
                        var item = objects[layerIndex],
                        type = item.type;
                        if( type == 'image' || type == 'custom-image' ){
                            if( appConfig.domainChanged ){
                                var _src = item.src;
                                var src = _src.split('nbdesigner');
                                if( src.length == 2 ){
                                    item.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                }
                            }
                            fabric.Image.fromObject(item, function(_image){
                                _canvas.add(_image);
                                continueLoadLayer();
                            });
                        }else{
                            var klass = fabric.util.getKlass(type);
                            if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                                if(!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length){
                                    stage.states.usedFonts.push($scope.getFontInfo(item.fontFamily));
                                };
                            };
                            if( angular.isDefined( item.field_mapping ) && !$scope.isTemplateMode ){
                                var field = _.filter($scope.settings.template_fields, { key: item.field_mapping })[0];
                                if( angular.isDefined( field ) ){
                                    if( field.value != '' ){
                                        if( angular.isDefined( item.is_uppercase ) ){
                                            item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                        }else{
                                            item.text = field.value;
                                        }
                                    }else{
                                        var mapping_field = _.filter($scope.templateHolderFields, { key: item.field_mapping })[0];
                                        if( angular.isUndefined( mapping_field ) ){
                                            $scope.templateHolderFields.push( JSON.parse( JSON.stringify( field ) ) );
                                        }
                                    }
                                }
                            }
                            if( angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1' ){
                                $scope.generateVcard( function( newObject ){
                                    var config = {
                                        left: item.left,
                                        top: item.top,
                                        scaleX: item.scaleX,
                                        scaleY: item.scaleY
                                    };
                                    newObject.set( config );
                                    newObject.scaleToWidth(item.width * item.scaleX);
                                    newObject.scaleToWidth(item.width * item.scaleX);
                                    _canvas.add( newObject );
                                    continueLoadLayer();
                                });
                            }else{
                                if( type == 'text' ){
                                    var text = item.text;
                                    var textobj = {};
                                    angular.copy(item, textobj);
                                    delete textobj.text;
                                    delete textobj.type;
                                    var textbox = new fabric.IText(text, textobj);
                                    _canvas.add(textbox);
                                    continueLoadLayer();
                                } else if( !!item.isTemMask && !$scope.isTemplateMode ){
                                    klass.fromObject(item, function(item){
                                        item.set({
                                            isMask: 1,
                                            absolutePositioned: true,
                                            strokeWidth: 0,
                                            lockRotation: true,
                                            selectable: false,
                                            fill: '#ffffff',
                                            _isTemMask: true,
                                            opacity: 0.001
                                        });
                                        delete item.isTemMask;
                                        _canvas.add(item);
                                        var maskLayer = _canvas.item(_canvas.getObjects().length - 1),
                                        maskId = maskLayer.get( 'itemId' ),
                                        defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                                        fabric.Image.fromURL(defaultMaskImageUrl, function(op) {
                                            var top = maskLayer.get('top'),
                                            left = maskLayer.get('left'),
                                            scaleX = maskLayer.get('scaleX'),
                                            scaleY = maskLayer.get('scaleY'),
                                            width = maskLayer.get('width'),
                                            height = maskLayer.get('height'),
                                            realWidth = width * scaleX,
                                            realHeight = height * scaleY,
                                            newWidth = realWidth,
                                            newHeight = realHeight;
                                            if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                                                newWidth = op.width / op.height * newHeight;
                                            }else{
                                                newHeight = op.height / op.width * newWidth;
                                            }
                                            var d = new Date(),
                                            itemId = d.getTime() + Math.floor(Math.random() * 1000);
                                            op.set({
                                                clipPath: maskLayer,
                                                perPixelTargetFind: true,
                                                centeredScaling: true,
                                                maskId: maskId,
                                                scaleX: newWidth / op.width,
                                                scaleY: newHeight / op.height,
                                                top: top + realHeight / 2,
                                                left: left + realWidth / 2,
                                                itemId: itemId,
                                                isEmptyMask: true,
                                                srcChanged: false
                                            });
                                            if( !!maskLayer.get('forceLock') ) op.set({lockMask: true});
                                            _canvas.add(op);
                                            continueLoadLayer();
                                        }, {crossOrigin: 'anonymous'});
                                    });
                                } else {
                                    klass.fromObject(item, function(item){
                                        _canvas.add(item);
                                        continueLoadLayer();
                                    });
                                }
                            }
                        }
                    }else{
                        $scope.onloadTemplate = false;
                        $scope.toggleStageLoading();
                    }
                }
                loadLayer(layerIndex);
            }

            async function boostLoadLayer(){
                _canvas.clear();

                function loadImageFromUrl( img ){
                    return new Promise(resolve => {
                        fabric.Image.fromURL(img, op => {
                            resolve(op);
                        }, {crossOrigin: 'anonymous'});
                    });
                }
        
                function loadImageFromObject( object ){
                    return new Promise(resolve => {
                        fabric.Image.fromObject(object, function(image){
                            resolve(image);
                        });
                    });
                }
        
                function applyImageFilters( object ){
                    return new Promise(resolve => {
                        object.applyFilters(false, function(){
                            setTimeout(() => resolve(object));
                        }, true);
                    });
                }
        
                function loadLayerFromObject( klass, object ){
                    return new Promise(resolve => {
                        klass.fromObject(object, function(obj){
                            resolve(obj);
                        });
                    });
                }
        
                async function loadPhotoFrameFromObject( klass, object ){
                    let item = await loadLayerFromObject( klass, object );
                    item.set({
                        isMask: 1,
                        absolutePositioned: true,
                        strokeWidth: 0,
                        lockRotation: true,
                        selectable: false,
                        _isTemMask: true,
                        fill: '#ffffff',
                        opacity: 0.001
                    });
                    delete item.isTemMask;
        
                    let maskId = item.itemId,
                    defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
        
                    let op = await loadImageFromUrl( defaultMaskImageUrl );
                    var top = item.get('top'),
                    left = item.get('left'),
                    scaleX = item.get('scaleX'),
                    scaleY = item.get('scaleY'),
                    width = item.get('width'),
                    height = item.get('height'),
                    realWidth = width * scaleX,
                    realHeight = height * scaleY,
                    newWidth = realWidth,
                    newHeight = realHeight;
                    if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                        newWidth = op.width / op.height * newHeight;
                    }else{
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: item,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: maskId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    if( !!item.get('forceLock') ) op.set({lockMask: true});
        
                    return {
                        layer: item,
                        holder: op
                    }
                }
        
                function generateVcard( object ){
                    return new Promise(resolve => {
                        $scope.generateVcard( function( newObject ){
                            var config = {
                                left: object.left,
                                top: object.top,
                                scaleX: object.scaleX,
                                scaleY: object.scaleY,
                                fill: object.fill
                            };
                            newObject.set( config );
                            newObject.scaleToWidth(object.width * object.scaleX);
                            newObject.scaleToWidth(object.width * object.scaleX);
        
                            resolve(newObject);
                        });
                    });
                }

                async function loadLayer(object){
                    let layer, photoHolder,
                    type = object.type;
                    if( type == 'image' || type == 'custom-image' ){
                        if( appConfig.domainChanged ){
                            var _src = object.src;
                            var src = _src.split('nbdesigner');
                            if( src.length == 2 ){
                                object.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                            }
                            var src2 = _src.split('web-to-print-online-designer/assets/');
                            if( src2.length == 2 ){
                                object.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                            }
                        };
                        layer = await loadImageFromObject( object );
                        if( layer.filters.length ){
                            layer = await applyImageFilters( layer );
                        }
                    } else {
                        var klass = fabric.util.getKlass(type);
                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( type ) > -1  ){
                            if(!_.filter(stage.states.usedFonts, ['alias', object.fontFamily]).length){
                                stage.states.usedFonts.push($scope.getFontInfo(object.fontFamily));
                            };
                        };
                        if( angular.isDefined( object.field_mapping ) && !$scope.isTemplateMode ){
                            var field = _.filter($scope.settings.template_fields, { key: object.field_mapping })[0];
                            if( angular.isDefined( field ) ){
                                if( field.value != '' ){
                                    if( angular.isDefined( object.is_uppercase ) ){
                                        object.text = object.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                    }else{
                                        object.text = field.value;
                                    }
                                }else{
                                    var mapping_field = _.filter($scope.templateHolderFields, { key: object.field_mapping })[0];
                                    if( angular.isUndefined( mapping_field ) ){
                                        $scope.templateHolderFields.push( JSON.parse( JSON.stringify( field ) ) );
                                    }
                                }
                            }
                        }

                        if( angular.isDefined(object.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1' ){
                            layer = await generateVcard( object );
                        }else{
                            if( type == 'text' ){
                                var text = object.text;
                                var textobj = {};
                                angular.copy(object, textobj);
                                delete textobj.text;
                                delete textobj.type;
                                layer = new fabric.IText(text, textobj);
                            }else if( !!object.isTemMask && !$scope.isTemplateMode ){
                                let res = await loadPhotoFrameFromObject( klass, object );
                                layer = res.layer;
                                photoHolder = res.holder;
                            }else{
                                layer = await loadLayerFromObject( klass, object );
                            }
                        }
                    }
                    return {
                        layer: layer,
                        itemId: layer.itemId,
                        photoHolder: photoHolder
                    };
                }

                var layers = [],
                photoHolders = [];

                await Promise.all(objects.map(async (object, objectIndex) => {
                    let res = await loadLayer(object);
                    layers[objectIndex] = res.layer;
                    if( res.photoHolder ){
                        photoHolders.push( { itemId: res.itemId, photoHolder: res.photoHolder } );
                    }
                }));

                photoHolders.map(photoHolder => {
                    let holderIndex;
                    layers.map((layer, layerIndex) => {
                        if( photoHolder.itemId == layer.itemId ) holderIndex = layerIndex;
                    });
                    layers.splice(holderIndex + 1, 0, photoHolder.photoHolder);
                });

                layers.map(layer => {
                    _canvas.add( layer );
                });

                $scope.renderStage($scope.currentStage);
                var layers = _canvas.getObjects();
                $scope.renderTextAfterLoadFont(layers, function(){
                    $scope.deactiveAllLayer();
                    $scope.renderStage($scope.currentStage);
                    $timeout(function(){
                        $scope.deactiveAllLayer();
                        $scope.renderStage($scope.currentStage);
                        $scope.onloadTemplate = false;
                        $scope.contextAddLayers = 'normal';
                        if( angular.isDefined(viewport) ){
                            $scope.resizeStage(viewport);
                        } else if( angular.isDefined(konfig) &&  angular.isDefined(konfig.scale) ){
                            viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                            $scope.resizeStage(viewport);
                        }else{
                            $scope.toggleStageLoading();
                        }
                    }, 100);
                });

                return true;
            }

            if( fonts.length ){
                _.each(fonts, function(font, index){
                    if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                        if( angular.isDefined(font.file) && angular.isDefined(font.file.r) )$scope.resource.font.data.push(font);
                    };
                    if( index == fonts.length - 1 ){
                        $scope.insertTemplateFont(font.alias, function(){
                            if( $scope.settings.nbdesigner_boosting_load_template == 'yes' ){
                                boostLoadLayer();
                            }else{
                                loadStage();
                            }
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }else{
                        $scope.insertTemplateFont(font.alias, function(){
                            if(!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length){
                                $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }
                });
            }else{
                if( $scope.settings.nbdesigner_boosting_load_template == 'yes' ){
                    boostLoadLayer();
                }else{
                    loadStage();
                }
            }
        }
        NBDDataFactory.get('nbdesigner_get_product_info', {product_id: NBDESIGNCONFIG['product_id'], variation_id: NBDESIGNCONFIG['variation_id'], template_id: temp}, function(data){
            data = JSON.parse(data);
            if( angular.isDefined( data.design ) ){
                $scope.setHistory($scope.currentStage, true);
                loadDesign(data.fonts, data.design, data.config.viewport, data.config);
            }else{
                $scope.onloadTemplate = false;
                $scope.contextAddLayers = 'normal';
                $scope.toggleStageLoading(); 
            }
        });
    };
    $scope.resizeStage = function(viewport, stage_id, wihoutLoading){
        var stage = angular.isDefined( stage_id ) ? $scope.stages[stage_id] : $scope.stages[$scope.currentStage];
        var currentViewport = $scope.viewPort;
        var newFitRec = $scope.fitRectangle(viewport.width, viewport.height, stage.config._width, stage.config._height, true);
        var oldFitRec = $scope.fitRectangle(currentViewport.width, currentViewport.height, stage.config._width, stage.config._height, true);
        var factor = oldFitRec.width / newFitRec.width;
        if (factor != 1) {
            stage.canvas.forEachObject(function (obj) {
                var scaleX = obj.scaleX,
                    scaleY = obj.scaleY,
                    left = obj.left,
                    top = obj.top,
                    tempScaleX = scaleX * factor,
                    tempScaleY = scaleY * factor,
                    tempLeft = left * factor,
                    tempTop = top * factor;
                obj.scaleX = tempScaleX;
                obj.scaleY = tempScaleY;
                obj.left = tempLeft;
                obj.top = tempTop;
                if( obj.clipPath && obj.clipPath.absolutePositioned & !obj.clipPath._isTemMask ){
                    var scaleX = obj.clipPath.scaleX,
                        scaleY = obj.clipPath.scaleY,
                        left = obj.clipPath.left,
                        top = obj.clipPath.top,
                        tempScaleX = scaleX * factor,
                        tempScaleY = scaleY * factor,
                        tempLeft = left * factor,
                        tempTop = top * factor;
                    obj.clipPath.scaleX = tempScaleX;
                    obj.clipPath.scaleY = tempScaleY;
                    obj.clipPath.left = tempLeft;
                    obj.clipPath.top = tempTop;
                }
                if( obj.clipPath && obj.clipPath.absolutePositioned & obj.clipPath._isTemMask ){
                    delete obj.clipPath._isTemMask;
                }
                obj.setCoords();
            });
            stage.canvas.calcOffset();
            $scope.renderStage($scope.currentStage);
        }
        if( !wihoutLoading ) $scope.toggleStageLoading();
    };
    $scope.resizeStages = function(viewport){
        _.each($scope.stages, function(stage, index){ 
            var currentViewport = $scope.viewPort;
            var newFitRec = $scope.fitRectangle(viewport.width, viewport.height, stage.config._width, stage.config._height, true);
            var oldFitRec = $scope.fitRectangle(currentViewport.width, currentViewport.height, stage.config._width, stage.config._height, true);
            var factor = oldFitRec.width / newFitRec.width;
            if( factor != 1 ){
                stage.canvas.forEachObject(function(obj) {
                    var scaleX = obj.scaleX,
                    scaleY = obj.scaleY,
                    left = obj.left,
                    top = obj.top,
                    tempScaleX = scaleX * factor,
                    tempScaleY = scaleY * factor,
                    tempLeft = left * factor,
                    tempTop = top * factor;

                    obj.scaleX = tempScaleX;
                    obj.scaleY = tempScaleY;

                    obj.left = tempLeft;
                    obj.top = tempTop;

                    if( obj.clipPath && obj.clipPath.absolutePositioned & !obj.clipPath._isTemMask ){
                        var scaleX = obj.clipPath.scaleX,
                        scaleY = obj.clipPath.scaleY,
                        left = obj.clipPath.left,
                        top = obj.clipPath.top,
                        tempScaleX = scaleX * factor,
                        tempScaleY = scaleY * factor,
                        tempLeft = left * factor,
                        tempTop = top * factor;
                        obj.clipPath.scaleX = tempScaleX;
                        obj.clipPath.scaleY = tempScaleY;
                        obj.clipPath.left = tempLeft;
                        obj.clipPath.top = tempTop;
                    }
                    if( obj.clipPath && obj.clipPath.absolutePositioned & obj.clipPath._isTemMask ){
                        delete obj.clipPath._isTemMask;
                    }
                    obj.setCoords();
                });
                stage.canvas.calcOffset();
                $scope.renderStage(index);
            }
            if( index == $scope.stages.length - 1 ){
                $scope.toggleStageLoading();
            }
        });
    };
    $scope.insertTypography = function(typo){
        if( !$scope.canAddMoreLayer() ) return;
        var stage = $scope.stages[$scope.currentStage],
        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
        _canvas = stage['canvas'];
        $scope.toggleStageLoading();
        $scope.showDesignTab();
        NBDDataFactory.get('nbd_get_resource', {type: 'get_typo', folder: typo.folder}, function(data){
            data = JSON.parse(data);
            var fonts = data.data.font,
            layers = data.data.design.frame_0.objects;
            $scope.resource.tempData.template = [];
            function loadLayers(){
                _.each(layers, function(layer, _index){
                    if( _index == layers.length - 1 ){
                        $scope.loadTemplateLayer(layer, function(){
                            $scope.renderTextAfterLoadFont($scope.resource.tempData.template, function(){
                                var selection = new fabric.ActiveSelection($scope.resource.tempData.template, {
                                  canvas: _canvas
                                });
                                _canvas.setActiveObject(selection);
                                selection.addWithUpdate();
                                if( ( selection.width * scale ) > ( _canvas.width * 0.8 ) ){
                                    var canvasWidth = _canvas.width;
                                    selection.scaleX = selection.scaleX * canvasWidth * 0.8 / ( selection.width * scale );
                                    selection.scaleY = selection.scaleY * canvasWidth * 0.8 / ( selection.width * scale );
                                    selection.width = selection.width * canvasWidth * 0.8 / ( selection.width * scale );
                                    selection.addWithUpdate();
                                    if( ( selection.height * scale ) > ( _canvas.height * 0.8 ) ){
                                        var canvasHeight = _canvas.height;
                                        selection.scaleX = selection.scaleX * canvasHeight * 0.8 / ( selection.height * scale );
                                        selection.scaleY = selection.scaleY * canvasHeight * 0.8 / ( selection.height * scale );
                                        selection.height = selection.height * canvasHeight * 0.8 / ( selection.height * scale );
                                        selection.addWithUpdate();
                                    }
                                }
                                _canvas.viewportCenterObjectH(selection);
                                _canvas.viewportCenterObjectV(selection);
                                $scope.renderStage();
                                $timeout(function(){
                                    $scope.deactiveAllLayer();
                                    _canvas.setActiveObject(selection);
                                    selection.addWithUpdate();
                                    _canvas.viewportCenterObjectH(selection);
                                    _canvas.viewportCenterObjectV(selection);
                                    if( stage.config.area_design_type == "2" ) $scope.setStackLayerAlwaysOnTop();
                                    $scope.renderStage();
                                    $scope.toggleStageLoading();
                                    $scope.setHistory($scope.currentStage, true);
                                }, 500);
                            });
                        });
                    }else{
                        $scope.loadTemplateLayer(layer);
                    }
                });
            };
            if(fonts.length){
                _.each(fonts, function(font, index){
                    if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                        $scope.resource.font.data.push(font);
                    };
                    if( index == fonts.length - 1 ){
                        $scope.insertTemplateFont(font.alias, function(){
                            loadLayers();
                            if(!_.filter(stage.states.usedFonts, ['alias', font.alias]).length){
                                stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }else{
                        $scope.insertTemplateFont(font.alias, function(){
                            if(!_.filter(stage.states.usedFonts, ['alias', font.alias]).length){
                                stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                            };
                        });
                    }
                });
            }else{
                loadLayers();
            }
        });
    };
    $scope.renderTextAfterLoadFont = function(layers, callback ){
        if( layers.length == 0 ) {
            callback();
            return;
        };
        _.each(layers, function(item, index){
            if( ['text', 'i-text', 'curvedText', 'textbox'].indexOf(item.type) > -1 ){
                var fontFamily = item.get('fontFamily'),
                fontWeight = item.get('fontWeight'),
                fontStyle = item.get('fontStyle'),
                _font = $scope.getFontInfo(fontFamily);
                var opt = {};
                if( fontWeight != '' ) opt.weight = fontWeight;
                if( fontStyle != '' ) opt.style = fontStyle;
                item.set({objectCaching: false});
                fabric.util.clearFabricFontCache();
                var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                    fabric.util.clearFabricFontCache();
                    item.initDimensions();
                    item.setCoords();
                }, function () {
                    /* todo */
                });
            };
            if( index == (layers.length -1) && typeof callback == 'function' ){
                callback();
            }
        });
    };
    $scope.loadTemplateLayer = function(json, callback, stage_id){
        stage_id =  angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
        var stage = $scope.stages[stage_id],
        _canvas = stage['canvas'];
        var klass = fabric.util.getKlass(json.type);
        klass.fromObject(json, function(item){
            $scope.contextAddLayers = 'template';
            _canvas.add(item);
            var _item = _canvas.item( _canvas.getObjects().length - 1 );
            $scope.resource.tempData.template.push(_item);
            if( typeof callback == 'function' ) callback();
        });
    };
    $scope.insertCanvaTypo = function(typo){
        if( $scope.settings.task != 'typography' ){
            $scope.insertTypography(typo);
            return;
        };
        $scope.stages[0].states.usedFonts = [];
        $scope.zoomStage(0);
        var url = $scope.generateTypoLink(typo);
        $scope.resource.currentTypo = typo.id;
        var svg_url = url.replace("png", "svg"),
            svg_url = svg_url.replace("/img/", "/svg/"),
        _stages = $scope.stages[0],
        _canvas = _stages['canvas'];
        _canvas.clear();
        $scope.toggleStageLoading();
        function validFontName(fontName){
            fontName = fontName.replace(/'/g, "");
            fontName = fontName.split("-")[0];
            fontName = fontName.replace(/([A-Z])/g, ' $1').trim();
            return fontName;
        };
        fabric.Image.fromURL(url, function(op) {
            _stages.config.width = op.width;
            _stages.config.height = op.height;
            _canvas.setDimensions({'width' : op.width, 'height' : op.height});
            fabric.loadSVGFromURL(svg_url, function(ob, op) {
                _canvas.add((fabric.util.groupSVGElements(ob, op)).set({
                    scaleX: _stages.config.width / op.width,
                    scaleY: _stages.config.height / op.height
                }));
                $scope.renderStage(0);
                $timeout(function(){
                    var object = _canvas.getActiveObject();
                    var textIndexArr = [],
                        count = 0;
                    _.each(object._objects, function(path, index){
                        if( angular.isDefined(path.text) ){
                            var color = tinycolor(path.get('fill')).toHexString();
                            color = color.toLowerCase() == '#ffffff' ? '#404762' : color;
                            textIndexArr.push({index: index, type: 'text', text: path.text, font: validFontName(path.fontFamily), fill: color});
                        }
                        if( path.get('fill') == '' ){
                            textIndexArr.push({index: index, type: 'empty_rect'});
                        };
                    });
                    object.set({dirty: true});
                    _.each(textIndexArr, function(el, index){
                        var _index = el.index - count;
                        object._objects.splice(_index, 1);
                        count++;
                        if(el.type == 'text'){
                            var _text = new FabricWindow.IText(el.text, {
                                    radius: 50,
                                    fontSize: 20,
                                    noScaleCache: false,
                                    fill: el.fill,
                                    lockUniScaling: true,
                                    lockRotation: true,
                                    spacing: 0
                                });
                                _text["setControlVisible"]("mtr", false);
                            if( index < _.findLastIndex(textIndexArr, function(o) { return o.type == 'text'; }) ){
                                $scope.insertTemplateFont(el.font, function(fontName){
                                _text.set({fontFamily: fontName});
                                _canvas.add(_text);
                                if(!_.filter(_stages.states.usedFonts, ['alias', fontName]).length){
                                    _stages.states.usedFonts.push($scope.getFontInfo(fontName));
                                };
                                });
                            }else{
                                $scope.insertTemplateFont(el.font, function(fontName){
                                    _text.set({fontFamily: fontName});
                                    _canvas.add(_text);
                                    if(!_.filter(_stages.states.usedFonts, ['alias', fontName]).length){
                                        _stages.states.usedFonts.push($scope.getFontInfo(fontName));
                                    };
                                    $scope.renderStage(0);
                                    $scope.toggleStageLoading();  
                                    $scope.updateLayersList();
                                });
                            }
                        }
                    });
                }, 1000);
            });
        }, {crossOrigin: 'anonymous'});
    };
    /* History */
    $scope.itemToJson = function(item, params){
        if(params){
            return JSON.stringify(params);
        }else{
            return JSON.stringify(item);
        }
    };
    $scope.setItemParameters = function(parameters, itemId){
        var params = JSON.parse(parameters),
            _canvas = this.stages[this.currentStage]['canvas'],
            item = _canvas.item(this.getLayerById(itemId));
            if(typeof params.src !== "undefined"){
                fabric.Image.fromURL(params.src, function(op) {
                    item.getElement().setAttribute("src", params.src);
                }, {crossOrigin: 'anonymous'});
            } 
        item.set(params);
        item.setCoords();
    };
    $scope.undo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas']; 
        if( _stage.undos.length > 1 ){
            var last = _stage.undos.pop(),
                nexttoLast = _stage.undos[ _stage.undos.length - 1 ];
            $scope._loadStageFromJson($scope.currentStage, nexttoLast);
            $scope.setHistory($scope.currentStage, false, last, true);
            $scope.deactiveAllLayer();
            this.renderStage();

            if( $scope.resource.shareDesign ){
                if( NBDESIGNCONFIG['ui_mode'] == 1 ) {
                    nbd_window.jQuery(nbd_window.document).triggerHandler( 'nbd_pass_design_json', {stage_id: this.currentStage, design: nexttoLast, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                }else{
                    jQuery( document ).triggerHandler( 'nbd_pass_design_json', {stage_id: this.currentStage, design: nexttoLast, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                }
            }
        }
        $scope.updateApp();
    };
    $scope.redo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas'];
        if( _stage.redos.length > 0 ){
            var last = _stage.redos.pop();
            $scope._loadStageFromJson($scope.currentStage, last);
            $scope.setHistory($scope.currentStage, last, false, true);
            $scope.deactiveAllLayer();
            this.renderStage();
        };
        $scope.updateApp();
    }; 
    $scope._undo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas'];
        if( _stage.undos.length > 0 ){
            var json = _stage.undos.pop();
            _canvas.clear();
            $scope.contextAddLayers = 'template';
            $scope.onloadTemplate = true;
            _canvas.loadFromJSON(json, function() {
                $scope.onloadTemplate = false;
                $scope.contextAddLayers = 'normal';
            });
            $scope._setHistory(false, json);
        }
    };
    $scope._redo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas'];
        if( _stage.redos.length > 0 ){
            var json = _stage.redos.pop();
            _canvas.clear();
            $scope.contextAddLayers = 'template';
            $scope.onloadTemplate = true;
            _canvas.loadFromJSON(json, function() {
                $scope.onloadTemplate = false;
                $scope.contextAddLayers = 'normal';
            });
            $scope._setHistory(json);
        }
    };
    $scope._setHistory = function(undo, redo){
        var _stage = this.stages[this.currentStage];
        if (undo) {
            if(angular.isUndefined(_stage.undos)) _stage.undos = [];
            _stage.undos.push(undo);
            if(_stage.undos.length > 20) _stage.undos.shift();
            _stage.states.isUndoable = true;
        }else{
            if(angular.isUndefined(_stage.redos)) _stage.redos = [];
            _stage.states.isRedoable = true;
            _stage.redos.push(redo);
        };
        $scope.updateApp();
        $scope.updateStatusHistory();
    };
    $scope.setHistory = function(stage_id, undo, redo, hasJson){
        stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
        var _stage = this.stages[stage_id];
        if( angular.isUndefined( _stage ) ) return;
        /*if (undo) {
            if(angular.isUndefined(_stage.undos)) _stage.undos = [];
            _stage.undos.push(undo);
            if(_stage.undos.length > 50) _stage.undos.shift();
            _stage.states.isUndoable = true;
        }else{
            if(angular.isUndefined(_stage.redos)) _stage.redos = [];
            _stage.states.isRedoable = true;
            _stage.redos.push(redo);
        };*/
        var _canvas = _stage['canvas'];
        if ( undo ) {
            if(angular.isUndefined(_stage.undos)) _stage.undos = [];
            if( typeof _canvas.toJSON == 'function' ){
                if( angular.isUndefined( hasJson ) ){
                    var json = _canvas.toJSON($scope.includeExport);
                    if(angular.isUndefined(_stage.undos)) _stage.undos = [];
                }else{
                    var json = undo;
                }
                _stage.undos.push(json);
                if(_stage.undos.length > 30) _stage.undos.shift();
                _stage.states.isUndoable = true;

                if( $scope.resource.shareDesign ){
                    if( NBDESIGNCONFIG['ui_mode'] == 1 ) {
                        nbd_window.jQuery(nbd_window.document).triggerHandler( 'nbd_pass_design_json', {stage_id: stage_id, design: json, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                    }else{
                        jQuery( document ).triggerHandler( 'nbd_pass_design_json', {stage_id: stage_id, design: json, config: { width: _canvas.width, height: _canvas.height, zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio }, fonts: _stage.states.usedFonts } );
                    }
                }
            }
        } else {
            if(angular.isUndefined(_stage.redos)) _stage.redos = [];
            _stage.states.isRedoable = true;
            _stage.redos.push(redo);
        }
        $scope.updateApp();
        $scope.updateStatusHistory();
    };
    $scope.updateStatusHistory = function(){
        var _stage = this.stages[this.currentStage];
        _stage.states.isUndoable = (_stage.undos.length > 1) ? true : false; 
        _stage.states.isRedoable = (_stage.redos.length > 0) ? true : false;
        $scope.updateApp();
    }; 
    $scope.clearHistory = function(){
        var _stage = this.stages[this.currentStage];
        _stage.undos = [];
        _stage.redos = [];
        _stage.states.isRedoable = false;
        _stage.states.isUndoable = false;
        $scope.updateApp();
    };
    $scope._loadStageFromJson = function(stage_id, json, callback, withoutLoading){
        $scope.onloadTemplate = true;
        $scope.contextAddLayers = 'template';
        if( !withoutLoading ) $scope.toggleStageLoading();
        stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
        var layerIndex = 0, 
            stage = $scope.stages[stage_id],
            _canvas = stage['canvas'],
            objects = json.objects;
        _canvas.clear();
        if( json.background ){
            _canvas.backgroundColor = json.background;
        }else{
            _canvas.backgroundColor = null;
        }
        function loadLayer(layerIndex){
            function continueLoadLayer(){
                layerIndex++;
                if( objects.length != 0 && layerIndex < objects.length ){
                    loadLayer(layerIndex);
                }else{
                    $scope.renderStage($scope.currentStage);
                    var layers = _canvas.getObjects();
                    $scope.renderTextAfterLoadFont(layers, function(){
                        $scope.deactiveAllLayer();
                        $scope.renderStage($scope.currentStage);
                        $timeout(function(){
                            $scope.deactiveAllLayer();
                            $scope.renderStage($scope.currentStage);
                            $scope.onloadTemplate = false;
                            $scope.contextAddLayers = 'normal';
                            $scope.updateMaskedLayers( stage_id );
                            if( !withoutLoading ) $scope.toggleStageLoading();
                            if( typeof callback == 'function' ){
                                callback();
                            }
                        }, 100);
                    });
                }
            }
            if( objects.length > 0 ){
                var item = objects[layerIndex],
                type = item.type;
                if( type == 'image' || type == 'custom-image' ){
                    fabric.Image.fromObject(item, function(_image){
                        _canvas.add(_image);
                        continueLoadLayer();
                    });
                }else{
                    var klass = fabric.util.getKlass(type);
                    klass.fromObject(item, function(item){
                        _canvas.add(item);
                        continueLoadLayer();
                    });
                }
            }else{
                $scope.contextAddLayers = 'normal';
                $scope.onloadTemplate = false;
                if( !withoutLoading ) $scope.toggleStageLoading();
                if( typeof callback == 'function' ){
                    callback();
                }
            }
        }
        loadLayer(layerIndex);
    };
    $scope.enableFullScreenMode = function(){
        var ele = document.getElementById('nbd-stages');
        requestFullScreen(ele);  
    };
    $scope.exitFullscreenMode = function(){
        exitFullscreen();
    };
    $scope.toggleStageFullScreenMode = function(){
        _.each($scope.stages, function(stage, index){
            var zoomIndex = $scope.fullScreenMode ?  stage.states.fullScreenScaleIndex : stage.states.fitScaleIndex;
            $scope.zoomStage(zoomIndex, index);
            $scope.deactiveAllLayer(index);
            $scope.renderStage(index);
        });
    };
    /* Design tools */
    $scope.debug = function(){};
    $scope.setGeometricalObjectAttr = function( type, value ){
        var _stage = $scope.stages[$scope.currentStage],
            _states = _stage.states,
            _canvas = _stage['canvas'],
            item = _canvas.getActiveObject();
        if( !item ) return;
        switch( type ){
            case 'fill':
                item.set({fill: value});
                _states.geoObject.fill = value;
                break;
            case 'strokeUniform':
                item.set({strokeUniform: value});
                break;
            case 'stroke':
                if( value === false ){
                    item.set({stroke: null});
                    _states.geoObject.stroke = '#ffffff';
                }else{
                    item.set({stroke: value});
                    _states.geoObject.stroke = value;
                }
                break;
            case 'strokeWidth':
                var strokeWidth = value * 1;
                strokeWidth =  isNaN( strokeWidth ) ? 0 : Math.abs( strokeWidth ),
                item.set({strokeWidth: strokeWidth});
                break;
            case 'strokeDashArray':
                var dash1 = value[0] * 1,
                dash2 = value[1] * 1;
                if( isNaN( dash1 ) || isNaN( dash2 ) || dash1 == 0 || dash2 == 0 ){
                    item.set({strokeDashArray: null});
                }else{
                    var i = isNaN( dash1 ) ? 0 : Math.abs( dash1 ),
                    j = isNaN( dash2 ) ? 0 : Math.abs( dash2 );
                    item.set({strokeDashArray: [i, j]});
                }
                break;
        }
        item.setCoords();
        $scope.afterObjectModify();
        $scope.renderStage();
    };
    $scope.addGeometricalObject = function( type ){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var object;
        $scope.disableDrawMode();
        switch(type){
            case 'rect':
                object = new fabric.Rect({
                    width: 50,
                    height: 50
                });
                break;
            case 'circle':
                object = new fabric.Circle({
                    radius: 50
                });
                break;
            case 'triangle':
                object = new fabric.Triangle({
                    width: 50,
                    height: 50
                });
                break;
            case 'hexagon':
                object = new fabric.Polygon( [{x: 10,y: 17.321},{x: -10,y: 17.321},{x: -20,y: 0},{x: -10,y: -17.321},{x: 10,y: -17.321},{x: 20,y: 0}] );
                break;
            case 'line':
                object = new fabric.Line([0, 20, 100, 20], {stroke: NBDESIGNCONFIG.nbdesigner_default_color});
                break;
            case 'polyline':
                object = new fabric.Polyline([
                    { x: 10, y: 10 },
                    { x: 50, y: 30 },
                    { x: 40, y: 70 },
                    { x: 60, y: 50 },
                    { x: 100, y: 150 },
                    { x: 40, y: 100 }
                ]);
                break;
            case 'ellipse':
                object = new fabric.Ellipse({
                    rx: 80,
                    ry: 50
                });
                break;
        }
        _canvas.add(object);
    };
    $scope.tempLayer = {};
    $scope.renderStage = function( stage_id ){
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.stages[stage_id]['canvas'].calcOffset();
        //$scope.stages[stage_id]['canvas'].requestRenderAll();
        $scope.stages[stage_id]['canvas'].renderAll();
    };
    $scope.deactiveAllLayer = function(stage_id){
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.stages[stage_id]['canvas'].discardActiveObject();
        angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
        $scope.updateCorners();
        $scope.renderStage();
        $scope.updateApp();
    };
    $scope.groupLayers = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
        activeObject = _canvas.getActiveObject();
        if (activeObject.type === 'activeSelection') {
            $scope.contextAddLayers = 'template';
            activeObject.toGroup();
            $scope.renderStage();
            $scope.getCurrentLayerInfo();
        }
    };
    $scope.onUnloadGroup = {
        status: false,
        remain: 0,
        length: 0
    };
    $scope.unGroupLayers = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
        activeObject = _canvas.getActiveObject();
        if (activeObject.type === 'group') {
            $scope.onUnloadGroup = {
                status: true,
                remain: activeObject._objects.length,
                length: activeObject._objects.length
            };
            if( angular.isDefined(activeObject.itemId) ){
                $scope.onUnloadGroup.prevIndex = $scope.getLayerById(activeObject.itemId);
            }
            $scope.contextAddLayers = 'template';
            activeObject.toActiveSelection();
            $scope.renderStage();
            $scope.getCurrentLayerInfo();
        }
    };
    /* General */
    $scope._clearAllStage = function(){
        if( !$scope.canDeleteLayer() ) return;
        jQuery('.nbd-popup.clear-all-stage-alert').nbShowPopup();
    };
    $scope.clearAllStage = function(){
        _.each($scope.stages, function(stage, index){
            stage.canvas.clear();
            stage.layers = [];
        });
        $scope.initStagesSettingWithoutTemplate();
        jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
    };
    /* Draw mode */
    $scope.disableDrawMode = function(){
        $scope.resource.drawMode.status = false;
        _.each($scope.stages, function(stage, index){
            stage.canvas.isDrawingMode = false;
        });
        $scope.changeBush();
        $scope.updateApp();
    };
    $scope.enableDrawMode = function(){
        $scope.resource.drawMode.status = true;
        _.each($scope.stages, function(stage, index){
            stage.canvas.isDrawingMode = true;
        });
        $scope.updateApp();
    }; 
    $scope.changeBush = function(color){
        if(color) $scope.resource.drawMode.brushColor = color;
        _.each($scope.stages, function(stage, index){
            stage.canvas.freeDrawingBrush = new fabric[$scope.resource.drawMode.brushType + "Brush"](stage.canvas);
            stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
            stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
        });
    };
    $scope.importDesign = function(){
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = 'text/json|application/json';
        input.style.display = 'none';
        input.addEventListener('change', onChange.bind(input), false);
        document.body.appendChild(input);
        input.click();
        function onChange(){
            if (this.files.length > 0) {
                var file = this.files[0],
                reader = new FileReader();
                reader.onload = function(event){
                    if (event.target.readyState === 2) {
                        var result = JSON.parse(reader.result);
                        $scope.importImages( result, function( new_design, fonts, extenalDesign ){
                            var temp = {fonts: fonts, design: new_design, viewport: result.config.viewport};
                            if( !!extenalDesign ) temp.doNotShowLoading = true;
                            $scope.insertTemplate(true, temp);
                        } );
                        destroy();
                    }
                };
                reader.readAsText(file);
            }
        }
        function destroy() {
            input.removeEventListener('change', onChange.bind(input), false);
            document.body.removeChild(input);
        }
    };
    $scope.exportDesign = function(){
        $scope.saveDesign();
        var json = {config: {}};
        json.config.viewport = $scope.calcViewport();
        json.config.home_url = $scope.settings.home_url;
        json.fonts = $scope.resource.usedFonts;
        json.design = $scope.resource.jsonDesign;
        var filename = 'design.json',
        text = JSON.stringify(json),
        a = document.createElement('a');
        a.setAttribute('href', 'data:application/json;charset=utf-8,'+ encodeURIComponent(text));
        a.setAttribute('download', filename);
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    };
    $scope.importImages = function( result, callback ){
        var images = [], extenalDesign = false,
        design = result.design, fonts = result.fonts, new_fonts = fonts;

        if( angular.isDefined( result.config.home_url ) ){
            if( $scope.settings.home_url != result.config.home_url ){
                new_fonts = [];
                _.each(fonts, function(font, index){
                    if( font.type == "google" ){
                        new_fonts.push( font );
                    }
                });
            }
        }

        _.each(design, function(side, sideIndex){
            var objects = side.objects;
            _.each(objects, function(object, objectIndex){
                var type = object.type, src = object.src;
                if( type == 'image' || type == 'custom-image' ){
                    if( src.indexOf( $scope.settings.home_url ) == -1 && src.indexOf( 'data:im' ) == -1 ){
                        var __index = sideIndex + '_' + objectIndex;
                        ['src', 'origin_url', 'origin_src'].forEach(function(val){
                            if( angular.isDefined( object[val] ) ){
                                var _index = __index + '_' + val;
                                images[_index] = object[val];
                                extenalDesign = true;
                            }
                        });
                    }
                }
            });
        });
        if( extenalDesign ){
            $scope.toggleStageLoading();
            var dataObj = {images: images, nonce: NBDESIGNCONFIG['nonce']};
            NBDDataFactory.get('nbd_import_images', dataObj, function(data){
                data = JSON.parse(data);
                if( data.flag == 1 ){
                    var new_images = data.images;
                    _.each(design, function(side, sideIndex){
                        var objects = side.objects;
                        _.each(objects, function(object, objectIndex){
                            var type = object.type;
                            if( type == 'image' || type == 'custom-image' ){
                                var __index = sideIndex + '_' + objectIndex;
                                ['src', 'origin_url', 'origin_src'].forEach(function(val){
                                    var _index = __index + '_' + val;
                                    if( angular.isDefined( new_images[_index] ) ){
                                        if( angular.isDefined( object[val] ) ){
                                            object[val] = new_images[_index];
                                        }
                                    }
                                });
                            }
                        });
                    });
                    callback( design, new_fonts, extenalDesign );
                } else {
                    alert( 'Import images fail!' );
                }
            });
        }else{
            callback( design, new_fonts );
        }
    };
    $scope.loadMyDesign = function(did, inCart){
        function process(){
            var dataObj = {}, loadAllMyTemplate = true;
            $scope.toggleStageLoading();
            var popup = inCart ? '.popup-nbd-my-designs-in-cart' : '.popup-nbd-my-templates';
            if( did != null ){
                dataObj = { did: did };
                loadAllMyTemplate = false;
                jQuery(popup).removeClass('nb-show');
            }else{
                dataObj = {
                    product_id: NBDESIGNCONFIG['product_id'],
                    variation_id: NBDESIGNCONFIG['variation_id']
                };
                if( appConfig.loadAllDesign ){
                    dataObj = {};
                }
            };
            var action = inCart ? 'nbd_get_designs_in_cart' : 'nbd_get_user_designs';
            NBDDataFactory.get(action, dataObj, function(data){
                data = JSON.parse(data);
                if(data.flag == 1){
                    if( loadAllMyTemplate ){
                        if( inCart ){
                            $scope.resource.cartTemplates = data.designs;
                        }else{
                            $scope.resource.myTemplates = data.designs;
                        }
                        $scope.toggleStageLoading();
                        jQuery(popup).nbShowPopup();
                    }else{
                        $scope.insertTemplate(true, {fonts: data.fonts, design: data.design, doNotShowLoading: true});
                    }
                }
            });
        }
        if( inCart ){
            process();
        }else{
            $scope.login(function(){
                process();
            });
        }
    };
    $scope.tempCanvas = null;
    $scope.storeLayers = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'];
        var item = _canvas.getActiveObjects();
        if(item){
            var bound = _canvas.getActiveObject().getBoundingRect();
            if( jQuery('#temp-canvas-wrap').length == 0 ){
                var tempCanvasWrap = document.createElement('div');
                tempCanvasWrap.setAttribute('id', 'temp-canvas-wrap');
                var canvasEl = document.createElement('canvas');
                canvasEl.setAttribute('id', 'temp-canvas');
                tempCanvasWrap.appendChild(canvasEl);
                document.body.appendChild(tempCanvasWrap);
                $scope.tempCanvas = new fabric.Canvas("temp-canvas");
            }
            $scope.tempCanvas.setDimensions({'width' : bound.width, 'height' : bound.height});
            $scope.tempCanvas.clear();
            $scope.tempCanvas.renderAll();
            var designData = {
                used_font: [],
                design: null,
                preview: null,
                tempLayers: []
            };
            var layers = []; var currentIndex = 0;
            _canvas.getActiveObjects().forEach(function( obj ){
                if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( obj.type ) > -1  ){
                    var font = $scope.getFontInfo(obj.fontFamily);
                    designData.used_font.push(font);
                }
                layers.push( JSON.stringify(obj) );
            });
            function importLayerToTempCanvas( currentIndex ){
                var object = JSON.parse(layers[currentIndex]);
                function continueLoadLayer(){
                    var _item = $scope.tempCanvas.item( $scope.tempCanvas.getObjects().length - 1 );
                    designData.tempLayers.push(_item);
                    currentIndex++;
                    if( currentIndex <= (layers.length - 1) ){
                        importLayerToTempCanvas( currentIndex );
                    }else{
                        var selection = new fabric.ActiveSelection(designData.tempLayers, {
                          canvas: $scope.tempCanvas
                        });
                        $scope.tempCanvas.setActiveObject(selection);
                        selection.addWithUpdate();
                        $scope.tempCanvas.viewportCenterObjectH(selection);
                        $scope.tempCanvas.viewportCenterObjectV(selection);
                        $scope.tempCanvas.discardActiveObject().renderAll();
                        $timeout(function(){
                            designData.preview = $scope.tempCanvas.toDataURL();
                            designData.design = $scope.tempCanvas.toJSON($scope.includeExport);
                            var designObj = {
                                used_font: designData.used_font,
                                json: designData.design,
                                width: bound.width,
                                height: bound.height
                            };
                            var _dataObj = {
                                type: 'save_user_design',
                                design: new Blob([JSON.stringify(designObj)], {type: "application/json"}),
                                preview: $scope.makeblob( designData.preview )
                            };
                            $scope.toggleStageLoading();
                            NBDDataFactory.get('nbd_get_resource', _dataObj, function(_data){
                                _data = JSON.parse(_data);
                                if($scope.resource.myDesigns.length == 0){
                                    $scope.needReloadUserDesigns = true;
                                }else{
                                    $scope.resource.myDesigns.splice(0, 0, _data.data);
                                }
                                $scope.toggleStageLoading();
                            });
                        });
                    }
                };
                var klass = fabric.util.getKlass(object.type);
                if( object.type == 'image' || object.type == 'custom-image' ){
                    fabric.Image.fromObject(object, function(_image){
                        $scope.tempCanvas.add(_image);
                        continueLoadLayer();
                    });
                }else{
                    klass.fromObject(object, function(object){
                        $scope.tempCanvas.add(object);
                        continueLoadLayer();
                    });
                }
            };
            importLayerToTempCanvas( currentIndex );
        }
    };
    $scope.needReloadUserDesigns = false;
    $scope.loadUserDesigns = function( template_id ){
        $scope.toggleStageLoading();
        var _dataObj = {
            type: 'load_user_designs'
        };
        if( angular.isDefined(template_id) ){
            _dataObj.type = 'load_user_design';
            _dataObj.template_id = template_id;
        }else{
            if( $scope.resource.myDesigns.length && !$scope.needReloadUserDesigns){
                jQuery('.popup-nbd-user-design').nbShowPopup();
                $scope.toggleStageLoading();
                return;
            }
        }
        NBDDataFactory.get('nbd_get_resource', _dataObj, function(_data){
            _data = JSON.parse(_data);
            if( angular.isDefined(_data.flag) && _data.flag == '1' ){
                if( angular.isDefined(template_id) ){
                    $scope.insertUserDesigns( _data.data.design );
                }else{
                    _data.data.user_designs.forEach(function(design){
                        $scope.resource.myDesigns.push(design);
                    });
                    $scope.needReloadUserDesigns = false;
                    jQuery('.popup-nbd-user-design').nbShowPopup();
                }
            }
            $scope.toggleStageLoading();
        });
    };
    $scope.deleteUserDesign = function( template_id, index ){
        var con = confirm($scope.settings.nbdlangs.confirm_delete_design);
        if( con == true ){
            jQuery('.popup-nbd-user-design .overlay-main').addClass('active');
            var _dataObj = {
                type: 'delete_user_design',
                template_id: template_id
            };
            NBDDataFactory.get('nbd_get_resource', _dataObj, function(_data){
                _data = JSON.parse(_data);
                if( angular.isDefined(_data.flag) && _data.flag == '1' ){
                    $scope.resource.myDesigns.splice(index, 1);
                }
                jQuery('.popup-nbd-user-design .overlay-main').removeClass('active');
            });
        }
    };
    $scope.insertUserDesigns = function( data ){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'];
        jQuery('.popup-nbd-user-design .overlay-main').addClass('active');
        var fonts = data.used_font,
        layers = data.json.objects,
        _index = 0,
        tempLayers = [];
        function loadLayer(_index){
            if( _index == layers.length ){
                var selection = new fabric.ActiveSelection(tempLayers, {
                  canvas: _canvas
                });
                $timeout(function(){
                    _canvas.setActiveObject(selection);
                    selection.addWithUpdate();
                    _canvas.viewportCenterObjectH(selection);
                    _canvas.viewportCenterObjectV(selection);
                    if( stage.config.area_design_type == "2" ) $scope.setStackLayerAlwaysOnTop();
                    $scope.renderStage();
                    jQuery('.popup-nbd-user-design').removeClass('nb-show');
                    jQuery('.popup-nbd-user-design .overlay-main').removeClass('active');
                }, 50);
            }else{
                $scope.contextAddLayers = 'template';
                var object = layers[_index],
                    type = object.type;
                _index++;
                function addLayer( _obj ){
                    _canvas.add(_obj);
                    tempLayers.push(_obj);
                    loadLayer(_index);
                };
                var klass = fabric.util.getKlass(type);
                if( type == 'image' || type == 'custom-image' ){
                    fabric.Image.fromObject(object, function(_image){
                        addLayer(_image);
                    });
                }else{
                    klass.fromObject(object, function(object){
                        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf( object.type ) > -1  ){
                            var fontName = object.fontFamily,
                            content = object.text;
                            var font = new FontFaceObserver(fontName, {weight: object.fontWeight, style: object.fontStyle});
                            font.load(content).then(function () {
                                fabric.util.clearFabricFontCache(fontName);
                                addLayer(object);
                            }, function () {
                                console.log('Fail to load font: '+fontName);
                                addLayer(object);
                            });
                        }else{
                            addLayer(object);
                        }
                    });
                }
            }
        }
        if(fonts.length){
            _.each(fonts, function(font, index){
                if(!_.filter($scope.resource.font.data, ['alias', font.alias]).length){
                    $scope.resource.font.data.push(font);
                };
                if( index == fonts.length - 1 ){
                    $scope.insertTemplateFont(font.alias, function(){
                        loadLayer(_index);
                        if(!_.filter(stage.states.usedFonts, ['alias', font.alias]).length){
                            stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                        };
                    });
                }else{
                    $scope.insertTemplateFont(font.alias, function(){
                        if(!_.filter(stage.states.usedFonts, ['alias', font.alias]).length){
                            stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                        };
                    });
                }
            });
        }else{
            loadLayer(_index);
        }
    };
    $scope.deleteLayers = function(itemIndex){
        if( !$scope.canDeleteLayer() ) return;
        var _canvas = this.stages[$scope.currentStage]['canvas'];
        var item = angular.isDefined(itemIndex) ? _canvas.item(itemIndex) : _canvas.getActiveObjects();
        if(item){
            if( angular.isDefined(itemIndex) ){
                /*$scope.setHistory({
                    element: item,
                    parameters: JSON.stringify(item.toJSON()),
                    interaction: 'remove'
                });*/
                if( !!item.get('maskId') ){
                    var maskLayer = $scope.getMaskLayer( item.get('maskId') );
                    _canvas.remove(maskLayer); 
                }
                _canvas.remove(item); 
            }else{
                _canvas.getActiveObjects().forEach(function(o){
                    /*$scope.setHistory({
                        element: o,
                        parameters: JSON.stringify(o.toJSON()),
                        interaction: 'remove'
                    }); */
                    if( !!o.get('maskId') ){
                        maskLayer = $scope.getMaskLayer( o.get('maskId') );
                        _canvas.remove(maskLayer); 
                    }
                    _canvas.remove(o); 
                });
            }
            $scope.setHistory($scope.currentStage, true);
            _canvas.discardActiveObject().requestRenderAll();
        };
        $scope.updateLayersList();
        return;
    };
    $scope.resetLayer = function () {
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage['canvas'];
        var index = 'frame_' + $scope.currentStage;
        var initialItems = null;
        var item = _canvas.getActiveObject();
        if (angular.isDefined($scope.settings.product_data.design)) {
            initialItems = $scope.settings.product_data.design[index].objects;
        }else {
            return;
        }
        var initialItem = _.find(initialItems, {itemId: item.get('itemId')});
        if (angular.isDefined(initialItem)) {
            item.set(initialItem);
            item.setCoords();
            $scope.deactiveAllLayer();
            $scope.renderStage();
        }
        return;
    };
    $scope.activeLayer = function(itemIndex, layerIndex){
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage['canvas'];
        if( !$scope.isTemplateMode && angular.isDefined( _canvas.item(itemIndex).forceLock ) && _canvas.item(itemIndex).forceLock ) return;
        _canvas.setActiveObject(_canvas.item(itemIndex));
        if( angular.isDefined(layerIndex) ) _stage.layers[layerIndex].active = true;
        $scope.renderStage();
    };
    $scope.copyLayers = function(){
        if( !$scope.canAddMoreLayer() ) return;
        var _canvas = this.stages[$scope.currentStage]['canvas'];
        if( !_canvas.getActiveObject() ) return;
        var activeObject = _canvas.getActiveObject();
        activeObject.clone(function(cloned) {
            var _clipboard = cloned;
            function _clone(__clipboard, mask){
                $timeout(function(){
                    __clipboard.clone(function(clonedObj) {
                        _canvas.discardActiveObject();
                        if(activeObject._objects != undefined) {
                            activeObject._objects.forEach(function(ob,idex){
                                if(ob.strokeUniform == true) {
                                    clonedObj._objects.forEach(function(obx,idexod){
                                        obx.set({
                                            strokeUniform: true
                                        });
                                    });
                                }
                            });
                        }
                        if(activeObject.strokeUniform == true) {
                            clonedObj.set({
                                strokeUniform: true
                            });
                        }
                        clonedObj.set({
                            left: clonedObj.left + 10,
                            top: clonedObj.top + 10,
                            evented: true
                        });
                        if (clonedObj.type === 'activeSelection') {
                            clonedObj.canvas = _canvas;
                            clonedObj.forEachObject(function(obj) {
                                $scope.contextAddLayers = 'copy';
                                _canvas.add(obj);
                            });
                            clonedObj.setCoords();
                        } else {
                            $scope.contextAddLayers = 'copy';
                            _canvas.add(clonedObj);
                            if( angular.isDefined( mask ) ){
                                clonedObj.set({
                                    clipPath: mask, 
                                    maskId: mask.get('itemId'),
                                    centeredScaling: true
                                });
                                $scope.updateMaskLayer();
                            }
                        }
                        _canvas.setActiveObject(clonedObj);
                        _canvas.requestRenderAll();
                    });
                }, 10);
            }
            if( cloned.type != 'activeSelection' && !!activeObject.get('maskId') ){
                var maskLayer = $scope.getMaskLayer( activeObject.get('maskId') );
                if( maskLayer ){
                    maskLayer.clone(function(cloned) {
                        var _maskClipboard = cloned;
                        $timeout(function(){
                            _clone( _maskClipboard );
                            $timeout(function(){
                                var mask = _canvas.item( _canvas.getObjects().length - 1 );
                                mask.set({
                                    isMask: 1,
                                    absolutePositioned: true,
                                    selectable: false
                                });
                                _clone( _clipboard, mask );
                            }, 10);
                        }, 10);
                    });
                }else{
                    _clone( _clipboard );
                }
            }else{
                _clone( _clipboard );
            }
        });
    };
    $scope.alignLayer = function(command){
        var _canvas = this.stages[this.currentStage].canvas,
            group = _canvas.getActiveObject(),
            items = _canvas.getActiveObjects(),
            _bound = items[0].getBoundingRect(),
            position = {
                left: _bound.left,
                top: _bound.top,
                right: _bound.left + _bound.width,
                bottom: _bound.top + _bound.height
            };  
        var _leftPosition = [],
            _topPosition = [],
            totalWidth = 0,
            totalHeight = 0;

        items.forEach(function(item, index){
            var bound = item.getBoundingRect();
            if(bound.left < position.left) position.left = bound.left;
            if(bound.top < position.top) position.top = bound.top;
            if(bound.left + bound.width > position.right) position.right = bound.left + bound.width;
            if(bound.top + bound.height > position.bottom) position.bottom = bound.top + bound.height;
            _leftPosition.push({index: index, value: bound.left});
            _topPosition.push({index: index, value: bound.top});
            totalWidth += bound.width;
            totalHeight += bound.height;
        });
        switch(command) {
            case 'horizontal':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + (position.top + position.bottom) / 2 - bound.top - bound.height / 2});
                    item.setCoords();
                });
                break;
            case 'vertical':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') + (position.left + position.right) / 2 - bound.left - bound.width / 2});
                    item.setCoords();
                });
                break;
            case 'top':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + position.top - bound.top });
                    item.setCoords();
                });
                break;
            case 'bottom':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + position.bottom - bound.top - bound.height });
                    item.setCoords();
                });
                break;  
            case 'left':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') - bound.left + position.left});
                    item.setCoords();
                });
                break;
            case 'right':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') - bound.left + position.right - bound.width});
                    item.setCoords();
                });
                break;
            case 'dis-horizontal':
                var leftPosition = _.sortBy(_leftPosition, [function(o) { return o.value; }]);
                var space = (position.right - position.left - totalWidth) / (items.length - 1);
                leftPosition.forEach(function(_item, _index){
                    var index = _item.index;
                    if(_index > 0 && _index < items.length - 1){
                        var item = items[index],
                        previous_item = items[leftPosition[_index-1].index],
                        bound = item.getBoundingRect(),
                        previous_item_bound = previous_item.getBoundingRect();
                        item.set({'left': item.get('left') - bound.left +  previous_item_bound.left + previous_item_bound.width + space });
                        item.setCoords();
                    }
                });
                break;
            case 'dis-vertical':
                var topPosition = _.sortBy(_topPosition, [function(o) { return o.value; }]);
                var space = (position.bottom - position.top - totalHeight) / (items.length - 1);
                topPosition.forEach(function(_item, _index){
                    var index = _item.index;
                    if(_index > 0 && _index < items.length - 1){
                        var item = items[index],
                        previous_item = items[topPosition[_index-1].index],
                        bound = item.getBoundingRect(),
                        previous_item_bound = previous_item.getBoundingRect();
                        item.set({'top': item.get('top') - bound.top + previous_item_bound.top + previous_item_bound.height + space });
                        item.setCoords();
                    }
                });
                break;
        };    
        group.addWithUpdate();
        this.renderStage();
    };
    $scope.translateLayer = function(command){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage.canvas,
            item = _canvas.getActiveObject();
        if(!item) return;
            var  bound = item.getBoundingRect(),
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            left = item.get('left'),
            top = item.get('top'),
            originX = item.get('originX'),
            originY = item.get('originY');
        $scope.beforeObjectModify(item);
        stage.states.isShowToolBox = false;
        switch(command) {
            case 'horizontal':
                _canvas.viewportCenterObjectH(item);
                break;
            case 'vertical':
                _canvas.viewportCenterObjectV(item);
                break;
            case 'center':
                _canvas.viewportCenterObjectH(item);
                _canvas.viewportCenterObjectV(item);
                break;
            case 'top':
                var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale;
                item.set({top: _top});
                break;
            case 'top-left':
                var _top = top - bound.top / scale, _left = left - bound.left / scale;
                if( originX == 'center' ){
                    _left = bound.width / 2 /scale;
                }
                if( originY == 'center' ){
                    _top = bound.height / 2 /scale;
                }
                item.set({top: _top, left: _left});
                break;
            case 'top-center':
                _canvas.viewportCenterObjectH(item);
                var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale;
                item.set({top: _top});
                break; 
            case 'top-right':
                var _top = originY == 'center' ? bound.height / 2 /scale : top - bound.top / scale,
                _left = left + (_canvas.width - bound.width - bound.left)/scale;
                item.set({top: _top, left: _left});
                break;
            case 'bottom':
                var _top = top + (_canvas.height - bound.height - bound.top)/scale;
                item.set({top: _top});
                break;
            case 'bottom-left':
                var _left = originX == 'center' ? bound.width / 2 /scale :  left - bound.left / scale,
                _top = top + (_canvas.height - bound.height - bound.top)/scale;
                item.set({left: _left, top: _top});
                break; 
            case 'bottom-center':
                _canvas.viewportCenterObjectH(item);
                var _top = top + (_canvas.height - bound.height - bound.top)/scale;
                item.set({top: _top});
                break;
            case 'bottom-right':
                var _left = left + (_canvas.width - bound.width - bound.left)/scale,
                _top = top + (_canvas.height - bound.height - bound.top)/scale;
                item.set({left: _left, top: _top});
                break;
            case 'left':
                var _left = originX == 'center' ? bound.width / 2 /scale :  left - bound.left / scale;
                item.set({left: _left});
                break;
            case 'middle-left':
                _canvas.viewportCenterObjectV(item);
                var _left = originX == 'center' ? bound.width / 2 /scale : left - bound.left / scale;
                item.set({left: _left});
                break;
            case 'right':
                var _left = left + (_canvas.width - bound.width - bound.left)/scale;
                item.set({left: _left});
                break;
            case 'middle-right':
                _canvas.viewportCenterObjectV(item);
                var _left = left + (_canvas.width - bound.width - bound.left)/scale;
                item.set({left: _left});
                break;
        };
        item.setCoords();
        $scope.renderStage();
        $scope.afterObjectModify();
    };
    $scope.fitToStage = function( direction, item ){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage.canvas,
            item = angular.isDefined(item) ? item : _canvas.getActiveObject();
        if(!item) return;
        direction = angular.isDefined(direction) ? direction : 'both';
        var originX = item.get('originX'),
        originY = item.get('originY'),
        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
        switch(direction){
            case 'width':
                var _left = originX == 'center' ? _canvas.width / 2 /scale : 0;
                item.set({
                    left: _left,
                    scaleX: _canvas.width / item.width / scale,
                    scaleY: _canvas.width / item.width / scale
                });
                _canvas.viewportCenterObjectV(item);
                break;
            case 'height':
                var _top = originY == 'center' ? _canvas.height / 2 /scale : 0;
                item.set({
                    top: _top,
                    scaleX: _canvas.height / item.height / scale,
                    scaleY: _canvas.height / item.height / scale
                });
                _canvas.viewportCenterObjectH(item);
                break;
            default:
                var _top = originY == 'center' ? _canvas.height / 2 /scale : 0;
                var _left = originX == 'center' ? _canvas.width / 2 /scale : 0;
                item.set({
                    top: _top,
                    left: _left,
                    scaleX: _canvas.width / item.width / scale,
                    scaleY: _canvas.height / item.height / scale
                });
                _canvas.viewportCenterObjectH(item);
                _canvas.viewportCenterObjectV(item);
        }
        item.setCoords();
        $scope.updateCorners();
        $scope.renderStage(); 
        $scope.afterObjectModify();
    };
    $scope.getLayerById = function(itemId){
        var _canvas = this.stages[this.currentStage].canvas;
        var _index;
        _canvas.forEachObject(function(obj, index) {
            if(obj.get('itemId') == itemId) _index = index;
        });
        return _index;
    };  
    $scope.getMaskLayer = function(itemId){
        var _canvas = this.stages[this.currentStage].canvas;
        var layer;
        _canvas.forEachObject(function(obj, index) {
            if(obj.get('itemId') == itemId) layer = obj;
        });
        return layer;
    };
    $scope.getMaskedLayerByMaskId = function( maskId, stageId ){
        stageId = stageId ? stageId : $scope.currentStage;
        var _canvas = this.stages[stageId].canvas;
        var layer;
        _canvas.forEachObject(function(obj, index) {
            if(obj.get('maskId') == maskId) layer = obj;
        });
        return layer;
    };
    $scope.closePopupClearStage = function(){
        jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
    };
    $scope.closePopupClearAllStages = function(){
        jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
    };
    $scope.zoomStage = function(index, stage_id){
        stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
        var _stage = $scope.stages[stage_id],
           _canvas = _stage['canvas'];
        _stage.states.isShowToolBox = true;
        _stage.states.currentScaleIndex = index;
        _stage.states.corners = [];
        $scope.setStageDimension(stage_id);
        _canvas.setZoom(_stage.states.scaleRange[_stage.states.currentScaleIndex].ratio);
        jQuery('#stage-container-'+$scope.currentStage).stop().animate({
            scrollTop: 0,
            scrollLeft: 0
        }, 100);
        jQuery('#stage-container-'+$scope.currentStage).perfectScrollbar('update');
        if( appConfig.isVisual ) $scope.deactiveAllLayer();
        this.renderStage();
        if( $scope.settings.showRuler && appConfig.isModern ){
            _stage.hozRuler.update({config: _stage.config, zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio});
            _stage.verRuler.update({config: _stage.config, zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio});
        };

        $timeout(function(){
            $scope.processAreaDesignShape(stage_id);
        });
    };
    $scope.confirmClearStage = function(){
        if( !$scope.canDeleteLayer() ) return;
        jQuery('.nbd-popup.clear-stage-alert, .v-popup.v-popup-select').nbShowPopup();
    };
    $scope.clearStage = function(){
        if( !$scope.canDeleteLayer() ) return;
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'];
        _canvas.clear();
        jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
        if( stage.config.bgType == 'color' ){}
        if( stage.config.area_design_type == "2" ){
            $scope.contextAddLayers = 'template';
            var width = _canvas.width,
            height = _canvas.height,
            path = new fabric.Path("M0 0 H"+width+" V"+height+" H0z M "+width/2+" 0 A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" "+height+" A "+width/2+" "+height/2+", 0, 1, 0, "+width/2+" 0z");
            path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
            _canvas.add(path);
        }
        $scope.updateLayersList();
        _canvas.requestRenderAll();
        $scope.setHistory($scope.currentStage, true);
        $scope.stageDesignChanged();
    };
    $scope.selectAllLayers = function(){
        var _canvas = this.stages[this.currentStage]['canvas'];
        $scope.deactiveAllLayer();
        var objs = [];
        _canvas.forEachObject(function(obj, index) {
            if( obj.get('selectable') ) objs.push(obj);
        });
        var selection = new fabric.ActiveSelection(objs, {
            canvas: _canvas
        });
        selection.addWithUpdate();
        _canvas.setActiveObject(selection);
        $scope.renderStage();
    };
    $scope.stageToJson = function(stage_id){
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.renderStage(stage_id);
        var json = this.stages[stage_id]['canvas'].toJSON($scope.includeExport);
        return json;
    };
    $scope.loadStageFromJson = function(stage_id, json){
/*         var _canvas = this.stages[stage_id]['canvas'];
        _canvas.loadFromJSON(json, function() {
            $scope.renderStage(stage_id);
        }); */
        $scope._loadStageFromJson( stage_id, json, function(){
            $scope.clearClipboardDesign();
        });
    };
    $scope.copyStage = function( stage_id ){
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.tempStageDesign = {
            id: stage_id,
            design: $scope.stageToJson()
        };
    };
    $scope.pasteStage = function( dist_stage ){
        dist_stage = angular.isDefined( dist_stage ) ? dist_stage :  $scope.currentStage;
        if( $scope.tempStageDesign.id == dist_stage ) return;
        $scope.loadStageFromJson( dist_stage, $scope.tempStageDesign.design );
    };
    $scope.clearClipboardDesign = function(){
        $scope.tempStageDesign = null;
    };
    $scope.duplicateStage = function( stage_id ){
        if( $scope.stages.length == $scope.settings.maxNoOfStage ) return;
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.copyStage();
        $scope._addStage( stage_id );
        $timeout(function(){
            $scope.loadStageFromJson( stage_id * 1 + 1, $scope.tempStageDesign.design );
        }, 100);
    };
    $scope.maybeAddStage = function( stage_id ){
        if( !$scope.settings.dynamicStage ) return;
        $scope._addStage( stage_id - 1 );
    };
    $scope._addStage = function( stage_id ){
        if( $scope.stages.length == $scope.settings.maxNoOfStage ) return;
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        $scope.preventLoadDesign = true;
        if( angular.isUndefined($scope.settings.product_data.origin_product) ){
            $scope.settings.product_data.origin_product = [];
            angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
        }
        var new_stage = {}, new_product_stage = {};

        angular.copy($scope.settings.product_data.product[stage_id], new_product_stage);
        $scope.settings.product_data.product.splice(stage_id * 1 + 1, 0, new_product_stage);

        angular.copy($scope.stages[stage_id], new_stage);
        new_stage.design = '';
        new_stage.config.name += ' (copy)';
        $scope.stages.splice(stage_id * 1 + 1, 0, new_stage);
    };
    $scope.stageWillBeDelete = 0;
    $scope.confirmDeleteStage = function( stage_id ){
        stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
        $scope.stageWillBeDelete = stage_id;
        jQuery('.delete-stage-alert').nbShowPopup();
    };
    $scope.deleteStage = function(){
        jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
        $scope._deleteStage( $scope.stageWillBeDelete );
    };
    $scope.cancelDeleteStage = function( stage_id ){
        jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
    };
    $scope._deleteStage = function( stage_id, callback ){
        if( $scope.stages.length == $scope.settings.minNoOfStage ) return;
        stage_id = angular.isDefined( stage_id ) ? stage_id : $scope.currentStage;
        $scope.preventLoadDesign = true;
        appConfig.ready = false;
        if( angular.isUndefined($scope.settings.product_data.origin_product) ){
            $scope.settings.product_data.origin_product = [];
            angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
        }
        if( $scope.currentStage == stage_id && $scope.currentStage > 0 ){
            $scope.switchStage($scope.currentStage, 'prev', 'top-bottom', true);
        }
        if( $scope.currentStage == 0 ){
            $scope.switchStage($scope.currentStage, 'next', 'top-bottom', true);
        }
        if( $scope.currentStage >= stage_id && $scope.currentStage > 0 ){
            $scope.currentStage--;
        }
        $scope.settings.product_data.product.splice(stage_id, 1);
        $scope.stages.splice(stage_id, 1);
        $timeout(function(){
            appConfig.ready = true;
            $scope.updateApp();
            if( typeof callback == 'function' ){
                callback();
            }
        }, 100);
    };
    $scope.swapStage = function( dst_id, src_id, callback ){
        var dst_stage = {}, dst_product_stage = {}, src_stage = {}, src_product_stage = {};
        appConfig.ready = false;
        $scope.preventLoadDesign = true;

        angular.copy($scope.settings.product_data.product[dst_id], dst_product_stage);
        angular.copy($scope.settings.product_data.product[src_id], src_product_stage);
        angular.copy($scope.stages[dst_id], dst_stage);
        angular.copy($scope.stages[src_id], src_stage);
        $scope.settings.product_data.product[dst_id] = src_product_stage;
        $scope.settings.product_data.product[src_id] = dst_product_stage;
        $scope.stages[dst_id] = src_stage;
        $scope.stages[src_id] = dst_stage;

        var dst_design = $scope.stageToJson(dst_id),
        src_design = $scope.stageToJson(src_id);

        $timeout(function(){
            $scope.loadStageFromJson( dst_id, src_design );
            $scope.loadStageFromJson( src_id, dst_design );
            appConfig.ready = true;
            $scope.preventLoadDesign = false;

            if( typeof callback == 'function' ){
                callback();
            }
        }, 100);
    };
    $scope.$on('stage:move', function(event, from, to){
        $scope.moveStage( from, to );
    });
    $scope.moveStage = function( from, to, callback ){
        if( from == to || from == ( to - 1 ) ) return;
        var from_stage = {}, from_product_stage = {}, currentStage = $scope.currentStage, 
        _to = from > to ? to : ( to - 1 ),
        from_design = $scope.stageToJson( from );

        angular.copy($scope.settings.product_data.product[from], from_product_stage);
        angular.copy($scope.stages[from], from_stage);
        $scope.settings.product_data.product.splice(from, 1);
        $scope.stages.splice(from, 1);
        $scope.preventLoadDesign = true;
        appConfig.ready = false;

        $scope.settings.product_data.product.splice(_to, 0, from_product_stage);
        $scope.stages.splice(_to, 0, from_stage);
        jQuery('.popup-nbd-stage-grid-view .overlay-main').addClass('active');

        $timeout(function(){
            $scope._loadStageFromJson( _to, from_design, function(){
                $scope.preventLoadDesign = false;
                appConfig.ready = true;
                $scope.switchStageTo( currentStage );
                $scope.updateApp();
                jQuery('.popup-nbd-stage-grid-view .overlay-main').removeClass('active');
                if( typeof callback == 'function' ){
                    callback();
                }
            }, true);
        }, 300);
    };
    $scope.showGridView = function(){
        $scope.toggleStageLoading();
        $scope.saveDesign();
        _showGridView = function(){
            $scope.toggleStageLoading();
            jQuery('.nbd-popup.popup-nbd-stage-grid-view').nbShowPopup();
            $scope.settings.gridViewMode = true;
        }
        if( $scope.checkSaveStatus() ){
            _showGridView();
        }else{
            var interval = $interval(function(){
                if( $scope.checkSaveStatus() ){
                    $interval.cancel( interval );
                    _showGridView();
                }
            }, 100);
        }
    };
    $scope.duplicateDesign = function( stage_id ){
        stage_id = angular.isDefined( stage_id ) ? stage_id :  $scope.currentStage;
        var next_stage_id = parseInt( stage_id ) + 1;
        $scope.copyStage( stage_id );
        if( angular.isDefined( $scope.stages[next_stage_id] ) ){
            var _canvas = $scope.stages[next_stage_id].canvas;
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            _canvas.loadFromJSON($scope.tempStageDesign.design, function() {
                $scope.switchStage($scope.currentStage, 'next', 'top-bottom');
                $scope.renderStage(next_stage_id);
                $timeout(function(){
                    $scope.contextAddLayers = 'normal';
                    $scope.onloadTemplate = false;
                });
            });
        }
    };
    $scope.rotateLayer = function(command){
        var _canvas = this.stages[this.currentStage]['canvas'],
        item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        switch(command){
            case 'reflect-hoz':
                item.toggle("flipY");
                break;
            case 'reflect-ver':
                item.toggle("flipX");
                break;
            case '90cw':
                var angle = item.get('angle') + 90;
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.set({angle: angle});
                break;
            case '90ccw':
                var angle = item.get('angle') - 90;
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.set({angle: angle});
                break;
            case '180':
                var angle = item.get('angle') + 180;
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.set({angle: angle});
                break;
            default:
                var angle = parseInt(command);
                item.set({angle: angle});
        };   
        item.setCoords();
        this.renderStage();
        $scope.afterObjectModify();
    };
    $scope.scaleLayer = function(command){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        if (!obj) return;
        $scope.beforeObjectModify(obj);
        if( _stage.lockMovementY || _stage.lockMovementX ) return;
        var scaleX = obj.scaleX,
            scaleY = obj.scaleY,
            left = obj.left,
            top = obj.top,
            originX = obj.originX,
            originY = obj.originY,
            width = obj.width * scaleX,
            height = obj.height * scaleY,
            factor = command === "+" ? 1.1 : 0.9;
        var tempScaleX = scaleX * factor,
            tempScaleY = scaleY * factor,
            tempWidth = width * factor,
            tempHeight = height * factor,
            tempLeft = left + width / 2 - tempWidth / 2,
            tempTop = top + height / 2 - tempHeight / 2;
        if( originX == 'center' ){
            tempLeft = left;
        }
        if( originY == 'center' ){
            tempTop = top;
        } 
        obj.scaleX = tempScaleX;
        obj.scaleY = tempScaleY;
        obj.left = tempLeft;
        obj.top = tempTop;
        obj.setCoords();
        $scope.adjustMaskedLayers( obj );
        $scope.renderStage();
        $scope.afterObjectModify();
    };    
    $scope.moveLayer = function( command, alt ){
        var _canvas = this.stages[this.currentStage].canvas,
            items = _canvas.getActiveObjects(),
            selection = _canvas.getActiveObject(),
            step = alt ? 1 : 10;
        if( items.length == 0 ) return;
        angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
        items.forEach(function( item ){
            $scope.beforeObjectModify(item);
            switch(command) {
                case 'up':
                    if( !item.get("lockMovementY") ) item.set('top', item.get('top') - step);
                    break;
                case 'down':
                    if( !item.get("lockMovementY") ) item.set('top', item.get('top') + step);
                    break;    
                case 'left':
                    if( !item.get("lockMovementX") ) item.set('left', item.get('left') - step);
                    break;
                case 'right':
                    if( !item.get("lockMovementX") ) item.set('left', item.get('left') + step);
                    break;
            };
            item.setCoords();
        });
        if( selection.type === 'activeSelection' ){
            selection.addWithUpdate();
        };
        this.updateApp();
        this.renderStage();
        $scope.afterObjectModify();
    };
    $scope.sortLayer = function(srcIndex, dstIndex){
        var _canvas = this.stages[this.currentStage].canvas,
        item = _canvas.item(srcIndex);
        item.moveTo(dstIndex);
        $scope.setStackLayerAlwaysOnBottom();
        $scope.renderStage();
        $scope.updateLayersList();
        $scope.afterObjectModify();
        $scope.updateApp();
    };
    $scope.updateMaskLayer = function( selectedItem, stageId ){
        stageId = stageId ? stageId : $scope.currentStage;
        var _canvas = this.stages[stageId].canvas,
            maskId = [];
        _canvas.forEachObject(function(obj, index) {
            if(!!obj.get('isMask')){
                var id = obj.get('itemId'),
                check = true;
                if( angular.isDefined( selectedItem ) && selectedItem.get('itemId') == id ){
                    check = false;
                }
                check && maskId.push( id );
            }
        });
        function getMaskedLayer( maskId ){
            var layer;
            _canvas.forEachObject(function(obj, index) {
                if(!!obj.get('maskId')){
                    if( obj.get('maskId') == maskId ){
                        layer = obj;
                    }
                }
            });
            return layer;
        }
        _.each(maskId, function(id, index){
            var maskLayerIndex = $scope.getLayerById( id ),
            maskLayer = _canvas.item( maskLayerIndex );
            var maskedLayer = getMaskedLayer( id );
            if( maskedLayer ){
                var maskedLayerIndex = $scope.getLayerById( maskedLayer.get('itemId') );
                if( maskLayerIndex < maskedLayerIndex ){
                    maskLayer.moveTo( maskedLayerIndex - 1 );
                }else{
                    maskLayer.moveTo( maskedLayerIndex );
                }
                maskLayer.set({selectable: false});
            }else{
                
            }
        });
    };
    $scope.updateLayersList = function(){
        $scope.updateMaskLayer();
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage['canvas'];
        $scope.originPDFs[$scope.currentStage] = [];
        _stage.layers = [];
        _canvas.forEachObject(function(obj, index) {
            var layerInfo = {index: index, visible: obj.get('visible'), selectable: obj.get('selectable'), forceLock: obj.get('forceLock'), itemId: obj.get('itemId')};
            if( !obj.isAlwaysOnTop ){
                if( !obj.get('isMask') ){
                    switch(obj.type) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            layerInfo.type = 'text';
                            layerInfo.icon_class = 'text-fields';
                            layerInfo.text = obj.get('text');
                            layerInfo.editable = obj.get('editable');
                            if( angular.isDefined( obj.field_mapping ) ){
                                var field = _.filter($scope.settings.template_fields, { key: obj.field_mapping })[0];
                                if( angular.isDefined( field ) ){
                                    field.value = layerInfo.text;
                                }
                            }
                            if( obj.lostChar == 1 ) layerInfo.lostChar = true;
                            break;
                        case 'image':
                        case 'custom-image':
                            var maskId = obj.get('maskId');
                            if( !maskId ){
                                layerInfo.type = 'image';
                                layerInfo.src = obj.getSvgSrc();
                            }else{
                                layerInfo.type = 'image-layer';
                                layerInfo.src = obj.getSvgSrc();
                                layerInfo.maskId = maskId;
                            }
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                        case 'polyline':
                            var type = obj.type == 'rect' ? 'rectangle' : obj.type;
                            type = obj.type == 'polyline' ? 'line' : obj.type;
                            layerInfo.icon_class = 'layer-'+type;
                            layerInfo.type = type;
                            break;
                        case 'path-group':
                        case 'path':
                            layerInfo.icon_class = 'vector';
                            layerInfo.type = 'path';
                            break;
                        case 'group':
                            layerInfo.icon_class = 'layer-group';
                            layerInfo.type = 'group';
                            break;
                        default:
                            layerInfo.type = obj.type;
                            break;
                    }
                    layerInfo.layerName = typeof obj.layerName != 'undefined' ? obj.layerName : ( angular.isDefined( $scope.settings.nbdlangs[layerInfo.type] ) ? $scope.settings.nbdlangs[layerInfo.type] : '' );
                    _stage.layers.push(layerInfo);
                }
            }

            if( angular.isDefined( obj.origin_pdf ) ){
                $scope.originPDFs[$scope.currentStage].push({
                    index: index,
                    origin_pdf: obj.origin_pdf,
                    top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                    left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                    width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                    height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                });
            }
        });
        $timeout(function(){
            jQuery('#tab-layer .tab-scroll').perfectScrollbar('update');
        });
    }; 
    $scope.changeLayerName = function( layerIndex, layerName ){
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage['canvas'];
        if( _canvas.item( layerIndex ) ){
            _canvas.item( layerIndex ).set({layerName: layerName});
        }
    };
    $scope.setStackLayerAlwaysOnTop = function(maybeRender){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        _canvas.forEachObject(function(obj) {
            if( obj.isAlwaysOnTop ){
                obj.bringToFront();
            }
        });
        if(maybeRender) $scope.renderStage();
    };
    $scope.setStackLayerAlwaysOnBottom = function(maybeRender){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        _canvas.forEachObject(function(obj) {
            if( obj.isBgImg ){
                obj.sendToBack();
            }
        });
        if(maybeRender) $scope.renderStage();
    };
    $scope.setStackPosition = function(command, onLayer, _item){
        var item = _item ? _item : $scope.stages[$scope.currentStage]['canvas'].getActiveObject();
        $scope.beforeObjectModify(item);
        switch(command){
            case 'bring-front':
                item.bringToFront();
                $scope.setStackLayerAlwaysOnTop();
                break;
            case 'bring-forward':
                item.bringForward();
                break;
            case 'send-backward':
                item.sendBackwards();
                break;
            case 'send-back':
                item.sendToBack();
                break;
            default:
                var index = parseInt(command);
                item.moveTo(index);
                break;
        }
        $scope.setStackLayerAlwaysOnBottom();
        $scope.renderStage();
        $scope.afterObjectModify();
        if(!onLayer) $scope.updateLayersList();
    };
    $scope.changeBackground = function(color){
        $scope.stages[$scope.currentStage].config.bgColor = color;
    };
    $scope.stageBgColorPicker = {
        status: false,
        currentColor: '#fff'
    };
    $scope.changeBackgroundCanvas = function (color) {
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas;
        $scope.showDesignTab();
        _canvas.backgroundColor = color;
        $scope.addColor(color);
        _canvas.forEachObject(function(obj) {
            if( obj.isBgImg ){
                _canvas.remove(obj);
                $scope.updateLayersList();
            }
        });
        _canvas.renderAll();
        $scope.afterObjectModify();
    };
    $scope.removeBackgroundCanvas = function(){
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas;
        _canvas.backgroundColor = null;
        _canvas.forEachObject(function(obj) {
            if( obj.isBgImg ){
                _canvas.remove(obj);
            }
        });
        _canvas.renderAll();
        $scope.afterObjectModify();
    };
    $scope.backgroundImgLitmit = 0;
    $scope.getBackgroundImgList = function(){
        $scope.resource.background = angular.isDefined( $scope.settings.backgroundList ) ? $scope.settings.backgroundList : [];
        $scope.backgroundImgLitmit = 24;
    };
    $scope.loadMoreBackgroundImgList = function(){
        if( $scope.backgroundImgLitmit < $scope.resource.background.length ) $scope.backgroundImgLitmit += 24;
    };
    $scope.changeBackgroundImg = function( bgObj ){
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas,
            scale = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
        _canvas.backgroundColor = null;
        _canvas.forEachObject(function(obj) {
            if( obj.isBgImg ){
                _canvas.remove(obj);
            }
        });
        $scope.toggleStageLoading();
        var previewAvailable = NBDESIGNCONFIG.nbdesigner_enable_generate_photo_thumb == 'yes' && bgObj.previewAvailable;
        var url = previewAvailable ? bgObj.preview : bgObj.src;
        fabric.Image.fromURL(url, function(op) {
            var min_width = _canvas.width / scale,
            min_height = _canvas.height / scale,
            new_width = min_width,
            new_height = min_height;
            if( ( op.width / op.height ) > ( min_width / min_height ) ){
                new_height = min_height;
                new_width = new_height / op.height * op.width;
            }else{
                new_width = min_width;
                new_height = new_width / op.width * op.height;
            }
            op.set({
                fill: '#ff0000',
                scaleX: new_width / op.width,
                scaleY: new_height / op.height,
                selectable: false,
                isBgImg: 1
            });
            if( previewAvailable ){
                op.set({
                    origin_url: bgObj.src,
                    origin_width: bgObj.width,
                    origin_height: bgObj.height,
                    width: bgObj.width,
                    height: bgObj.height,
                    scaleX: new_width / bgObj.width,
                    scaleY: new_height / bgObj.height
                });
            }
            _canvas.add(op);
            $scope.toggleStageLoading();
        }, {crossOrigin: 'anonymous'});
    };
    $scope.setAsBackground = function(){
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage.canvas,
        item = _canvas.getActiveObject(),
        scale = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
        if( item ){
            if( !!item.isBgImg ) return;
            if(!!item.get('maskId')){
                return;
            }
            _canvas.backgroundColor = null;
            _canvas.forEachObject(function(obj) {
                if( obj.isBgImg ){
                    _canvas.remove(obj);
                }
            });
            var min_width = _canvas.width / scale,
            min_height = _canvas.height / scale,
            new_width = min_width,
            new_height = min_height;
            if( ( item.width / item.height ) > ( min_width / min_height ) ){
                new_height = min_height;
                new_width = new_height / item.height * item.width;
            }else{
                new_width = min_width;
                new_height = new_width / item.width * item.height;
            }
            item.set({
                scaleX: new_width / item.width,
                scaleY: new_height / item.height,
                selectable: false,
                isBgImg: 1
            });
            _canvas.viewportCenterObject(item);
            item.sendToBack();
            $scope.deactiveAllLayer();
            _canvas.renderAll();
            $scope.afterObjectModify();
        }
    };
    $scope.currentCombinationColor = 0;
    $scope.currentForegroundColor = 0;
    $scope.currentBackgroundColor = 0;
    $scope._changeBackgroundCanvas = function( $index ) {
        var color = $scope.settings.nbes_settings.background_colors.codes[$index];
        $scope.currentBackgroundColor = $index;
        $scope.changeBackgroundCanvas( color );
    };
    $scope.selectCombinationColor = function ( $index ) {
        var bgColor = $scope.settings.nbes_settings.combination_colors.bg_codes[$index],
            fgColor = $scope.settings.nbes_settings.combination_colors.fg_codes[$index];
        $scope.changeBackgroundCanvas( bgColor );
        $scope.changeFillAllLayers( fgColor, true );
        $scope.__colorPalette = [fgColor];
        $scope.stages[$scope.currentStage].states.text.fill = fgColor;
        $scope.currentCombinationColor = $index;
    };
    $scope.changeFillAllLayers = function(color, needRender){
        _.each($scope.stages, function(stage, index){
            var canvas = stage.canvas;
            canvas.forEachObject(function(obj) {
                switch( obj.type ) {
                    case 'i-text':
                    case 'text':
                    case 'textbox':
                    case 'curvedText':
                        obj.set({fill: color});
                        break;
                    case 'rect':
                    case 'triangle':
                    case 'line':
                    case 'polyline':
                    case 'polygon':
                    case 'circle':
                    case 'ellipse':
                    case 'path-group':
                    case 'path':
                    case 'group':
                        _.each(obj._objects, function(path, index){
                            if( path.get('fill') != '' ){
                                path.set({fill: color});
                            }
                            if( path.get('stroke') != null ){
                                path.set({stroke: color});
                            }
                        });
                        break;
                }
                if( obj.get('fill') != '' ){
                    obj.set({fill: color});
                }
                if( obj.get('stroke') != null ){
                    obj.set({stroke: color});
                }
            });
            if( needRender ) canvas.renderAll();
        });
    };
    $scope.forceForeground = function( item ){
        if( angular.isDefined( $scope.settings.nbes_enable_settings ) && angular.isDefined( $scope.settings.nbes_settings ) ){
            var foreFill = false, color = '';
            if( $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined( $scope.settings.nbes_settings.combination_colors ) && $scope.settings.nbes_settings.combination_colors.fg_codes.length > 0 ){
                foreFill = true;
                color = $scope.settings.nbes_settings.combination_colors.fg_codes[ $scope.currentCombinationColor ];
            } else if( $scope.settings.nbes_enable_settings.foreground == 1 && $scope.settings.nbes_settings.force_fg == 1 && angular.isDefined( $scope.settings.nbes_settings.foreground_colors ) 
                    && $scope.settings.nbes_settings.foreground_colors.codes.length > 0 ){
                foreFill = true;
                color = $scope.settings.nbes_settings.foreground_colors.codes[ $scope.currentForegroundColor ];
            }
            if( foreFill ){
                switch( item.type ) {
                    case 'i-text':
                    case 'text':
                    case 'textbox':
                    case 'curvedText':
                        item.set({fill: color});
                        break;
                    case 'rect':
                    case 'triangle':
                    case 'line':
                    case 'polygon':
                    case 'circle':
                    case 'ellipse':
                    case 'path-group':
                    case 'path':
                    case 'group':
                        _.each(item._objects, function(path, index){
                            if( path.get('fill') != '' ){
                                path.set({fill: color});
                            }
                            if( path.get('stroke') != null ){
                                path.set({stroke: color});
                            }
                        });
                        break;
                }
                if( item.get('fill') != '' ){
                    item.set({fill: color});
                }
                if( item.get('stroke') != null ){
                    item.set({stroke: color});
                }
            }
        }
    };
    $scope.changeFill = function(color){
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas;
        if( angular.equals({}, _canvas) ) return;
        var item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        if( !_stage.states.isPath ){
            _stage.states.text.fill = color;
/*****************change specific textcolor*****************/

        if (!!item.getSelectedText()) {
            if (item.getSelectedText().length === item.get("text").length) {
            item.setSelectionStyles({
                fill: color,
            });
            item.set({ fill: color });
            } else {
            item.setSelectionStyles({
                fill: color,
            });
            }
        } else {
            item.setSelectionStyles(
            {
                fill: color,
            },
            0,
            item.text.length
            );
            item.set({ fill: color });
        }
/*****************end change specific textcolor*****************/
            if( $scope.stages[$scope.currentStage].states.isShape ){
                _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
            }
        }else{
            item.set({dirty: true});
            _.each(_stage.states.svg.groupPath[_stage.states.svg.currentPath].index, function(path_index){
                if( path_index == -2 ){
                    item.set({fill: color});
                }else{
                    if( path_index > -1 ){
                        item._objects[path_index].set({fill: color});
                    }else{
                        item.set({stroke: color});
                    }
                }
            });
            _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
        }
        if( angular.isDefined( $scope.settings.nbes_enable_settings ) && $scope.settings.nbes_enable_settings.combination != 1 
                && $scope.settings.nbes_enable_settings.foreground == 1 && angular.isDefined( $scope.settings.nbes_settings ) && $scope.settings.nbes_settings.force_fg == 1
                && angular.isDefined( $scope.settings.nbes_settings.foreground_colors ) && $scope.settings.nbes_settings.foreground_colors.codes.length > 0 ){
            $scope.changeFillAllLayers( color, false );
            var index = $scope.settings.nbes_settings.foreground_colors.codes.indexOf( color );
            $scope.currentForegroundColor = index > -1 ? index : 0;
        }
        $scope.renderStage();
        $scope.afterObjectModify();
    };
    $scope.initEyeDropper = function($event, global){
        jQuery('.eyedropper-loading').addClass('active');
        $scope.eyedropper = null;

        var setEyeDropper = function(){
            if( !$scope.eyedropper ) return;
            jQuery('.nbd-eyedropper-wrap').off('mousemove').on('mousemove', function(evt){
                var infoLeft = evt.clientX - (((evt.clientX + 100) >= window.innerWidth) ? 90 : -5),
                infoTop = evt.clientY - (((evt.clientY - 15) <= 0) ? -20 : 25),
                data = $scope.eyedropper.getImageData(evt.clientX, evt.clientY + 21, 1, 1).data,
                color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                jQuery('.nbd-eyedropper-info-wrap').css({
                    left: infoLeft,
                    top: infoTop
                });
                jQuery('.nbd-eyedropper-color').css({background: color});
                jQuery('.nbd-eyedropper-color-code').text(color.toUpperCase());
            });
            jQuery('.nbd-eyedropper-wrap').off('mousedown').on('mousedown', function(evt){
                jQuery(this).removeClass('active');
                var data = $scope.eyedropper.getImageData(evt.clientX, evt.clientY + 21, 1, 1).data,
                color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                if( global ){
                    $scope.globalPicker.color = color;
                    $scope.addColor( $scope.globalPicker.color );
                    $scope.changeFill( $scope.globalPicker.color );
                }else{
                    $scope.currentColor = color;
                    $scope.addColor();
                    $scope.changeFill(color);
                }
                $scope.eyedropper = null;
            });
        }

        $timeout(function(){
            html2canvas(document.body).then(function(canvas) {
                jQuery('.eyedropper-loading').removeClass('active');
                $scope.eyedropper = canvas.getContext('2d');
                jQuery('.nbd-eyedropper-wrap').addClass('active');
                setEyeDropper();
            });
        });
    };
    $scope.initEyeDropper2 = function($event, global){
        var _stage = $scope.stages[$scope.currentStage],
        _canvas = _stage.canvas,
        ctx = _canvas.getContext('2d'),
        canvasEl = jQuery('#stage-container-' + $scope.currentStage + ' .lower-canvas'),
        canvasOffset = canvasEl.offset();

        jQuery('.nbd-eyedropper-inner-wrap').css({
            left: canvasOffset.left,
            top: canvasOffset.top,
            width: _canvas.width,
            height: _canvas.height
        });
        jQuery('.nbd-color-palette').removeClass('show');
        jQuery('.nbd-eyedropper-wrap').addClass('active');
        jQuery('.nbd-eyedropper-inner-wrap').off('mouseenter').on('mouseenter', function(){
            jQuery(this).addClass('active');
        });
        jQuery('.nbd-eyedropper-inner-wrap').off('mouseleave').on('mouseleave', function(){
            jQuery(this).removeClass('active');
        });
        jQuery('.nbd-eyedropper-inner-wrap').off('mousemove').on('mousemove', function(evt){
            var infoLeft = evt.clientX - (((evt.clientX + 100) >= window.innerWidth) ? 90 : -5),
            infoTop = evt.clientY - (((evt.clientY - 15) <= 0) ? -20 : 25),
            canvasLeft =  evt.clientX - canvasOffset.left,
            canvasTop = evt.clientY - canvasOffset.top + 21;
            if( canvasLeft > 0 && canvasTop > 0 && canvasLeft <= _canvas.width && canvasTop <= _canvas.height ){
                var data = ctx.getImageData(canvasLeft, canvasTop, 1, 1).data;
                if( data[3] == 0 ){
                    data[0] = data[1] = data[2] = 255;
                }
                var color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                jQuery('.nbd-eyedropper-info-wrap').removeClass('out-stage');
                jQuery('.nbd-eyedropper-info-wrap').css({
                    left: infoLeft,
                    top: infoTop
                });
                jQuery('.nbd-eyedropper-color').css({background: color});
                jQuery('.nbd-eyedropper-color-code').text(color.toUpperCase());
            }else{
                jQuery('.nbd-eyedropper-info-wrap').addClass('out-stage');
            }
        });
        jQuery('.nbd-eyedropper-inner-wrap').off('mousedown').on('mousedown', function(evt){
            jQuery(this).removeClass('active');
            jQuery('.nbd-eyedropper-wrap').removeClass('active');
            var canvasLeft = evt.clientX - canvasOffset.left,
            canvasTop = evt.clientY - canvasOffset.top + 21;
            if( canvasLeft > 0 && canvasTop > 0 && canvasLeft <= _canvas.width && canvasTop <= _canvas.height ){
                var data = ctx.getImageData(canvasLeft, canvasTop, 1, 1).data;
                if( data[3] == 0 ){
                    data[0] = data[1] = data[2] = 255;
                }
                var color = tinycolor({r: data[0], g: data[1], b: data[2]}).toHexString();
                if( global ){
                    $scope.globalPicker.color = color;
                    $scope.addColor( $scope.globalPicker.color );
                    $scope.changeFill( $scope.globalPicker.color );
                }else{
                    $scope.currentColor = color;
                    $scope.addColor();
                    $scope.changeFill(color);
                }
            }
        });
        jQuery('.nbd-eyedropper-wrap').off('mousedown').on('mousedown', function(evt){
            jQuery(this).removeClass('active');
        });
    };
    /* Text */
    $scope.addText = function(content, type, additionalObj){
        content = angular.isDefined(content) ? content : $scope.settings.nbdesigner_default_text;
        type = angular.isUndefined(type) ? 'bodytext' : type;
        var textType = 'IText',
        fontSize = 16,
        fontName = NBDESIGNCONFIG.default_font.alias;
        var state= $scope.stages[$scope.currentStage].states;
        switch(type){
            case 'heading':
                textType = 'Textbox';
                fontSize = 42;
                break;
            case 'subheading':
                textType = 'Textbox';
                fontSize = 36;
                break;
        };
        var textObj = {
            fontFamily: fontName,
            radius: 50,
            objectCaching: false,
            fontSize: fontSize,
            ptFontSize: ( fontSize  / state.ratioConvertFont ).toFixed(2)
        };
        if( additionalObj ){
            angular.extend(textObj, additionalObj);
        };
        function addText(){
            $scope.stages[$scope.currentStage]['canvas'].add(new FabricWindow[textType](content, textObj));
        };
        var font = new FontFaceObserver(fontName);
        font.load(content).then(function () {
            fabric.util.clearFabricFontCache(fontName);
            var container = document.createElement('span'),
            scale = state.scaleRange[state.currentScaleIndex].ratio;
            container.innerHTML = content;
            container.style.cssText = [
                'position:absolute',
                'width:auto',
                'font-size: ' + fontSize  + 'px',
                'font-family: ' + fontName,
                'left:-99999px'
            ].join(' !important;');
            document.body.appendChild(container);
            var textWidth = container.clientWidth + 2;
            document.body.removeChild(container);
            var canvasWidth = $scope.stages[$scope.currentStage]['canvas'].width;
            if( ( textWidth * scale ) > ( canvasWidth * 0.8 ) ){
                textObj.width = canvasWidth * 0.8 / scale;
                textObj.fontSize = canvasWidth * 0.8 / ( textWidth * scale ) * fontSize;
                textObj.ptFontSize = ( textObj.fontSize  / state.ratioConvertFont ).toFixed( 2 );
            }else{
                textObj.width = textWidth / scale;
            }
            $timeout(function(){
                addText();
            }, 100);
        }, function () {
            console.log('Fail to load font: '+fontName);
            addText();
        });
    };
    $scope.addCurvedText = function( content ){
        var state= $scope.stages[$scope.currentStage].states;
        function addText(){
            var rtl = false;
            if(NBDESIGNCONFIG.lang_rtl == 'rtl'){
                rtl = true;
                content = content.split('').reverse().join('');
            }
            $scope.stages[$scope.currentStage]['canvas'].add(new fabric.CurvedText(content, {radius: 100, rtl: rtl, top: 100, left: 100, fontFamily: fontName, fontSize: 20, ptFontSize: 20  / state.ratioConvertFont}));    
        };
        var fontName = NBDESIGNCONFIG.default_font.alias,
        font = new FontFaceObserver(fontName);
        font.load($scope.settings.subsets[NBDESIGNCONFIG.default_font.subset]['preview_text']).then(function () {
            fabric.util.clearFabricFontCache(fontName);
            addText();
        }, function () {
            console.log('Fail to load font: '+fontName);
            addText();
        });
    };
    $scope.setLayerAttribute = function(type, value, item_index, layer_index){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        if( !appConfig.ready ) return;
        var item = angular.isDefined(item_index) ? _canvas.item(item_index) : _canvas.getActiveObject();
        if(!item) return;
        if( type == 'selectable' && !$scope.isTemplateMode && angular.isDefined(item.forceLock) && item.forceLock ) return;
        $scope.beforeObjectModify(item);
        var itemType = item.get('type');
        if( (itemType == 'i-text' || itemType == 'textbox') && type == 'forceLock'){
            value == true ? item.set({editable: false}) : item.set({editable: true});
        };
        if( type == 'forceLock'){
            value == true ? item.set({selectable: false}) : item.set({selectable: true});
        };
        var ob = {}; ob[type] = value;
        if( type == 'angle' ){
            item.rotate( value );
        }else{
            item.set(ob);
        };
        switch(type){
            case 'visible':
            case 'selectable':
                $scope.deactiveAllLayer();
                break;
            case 'lockScalingX':
                var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                controlVisible.forEach(function(key){
                    item.setControlVisible(key, !value);
                });
                break;
            case 'lockScalingY':
                var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                controlVisible.forEach(function(key){
                    item.setControlVisible(key, !value);
                });
                break;
            case 'lockRotation':
                item.setControlVisible('mtr', !value);	
                break;
        }
        $scope.renderStage();
        if(angular.isDefined(item_index)){
            $scope.stages[$scope.currentStage].layers[layer_index][type] = value;
        }else{
            $scope.stages[$scope.currentStage].states[type] = value;
        }
        if( type != 'text' ){
            $scope.updateLayersList();
        }
        if( ['i-text', 'text', 'textbox', 'curvedText'].indexOf(itemType) > -1 ){
            $scope.normalizeText( item );
            if( $scope.settings.nbdesigner_enable_text_check_lang == 'yes' ) $scope.checkCharacter( item );
        }
        $scope.afterObjectModify();
        $scope.updateApp();
    };
/****************************************changed setTextAttribute*****************/
    $scope.setTextAttribute = function (type, value, extra_option) {
        var _stage = $scope.stages[$scope.currentStage],
        _states = _stage.states,
        _canvas = _stage["canvas"];

        if (!appConfig.ready) return;
        var item = _canvas.getActiveObject();
        var items = _canvas.getActiveObjects();
        if (!item || !items) return;
        var selectionStart = item.selectionStart,
        selectionEnd = item.selectionEnd;

        $scope.beforeObjectModify(item);
        function applyFontSizeStyles(selectionStart, selectionEnd,item,ob) {
        item.setSelectionStyles(
            {
            ptFontSize: value,
            fontSize: value * _states.ratioConvertFont,
            },
            selectionStart,
            selectionEnd
        );
        item.set(ob);
        
        }

        function applyStyles(selectionStart, selectionEnd,item,ob) {
        if (!!item.getSelectedText()) {
            item.setSelectionStyles(ob, selectionStart, selectionEnd);
            item.getSelectedText().length === item.get("text").length ?item.set(ob):"";
            
        } else {
            item.setSelectionStyles(ob, selectionStart, selectionEnd);
            item.set(ob);
        }
        }
        var ob = {};
        ob[type] = value;
        if (
        type !== "fontSize" &&
        type !== "is_uppercase" &&
        type !== "fontWeight" &&
        type !== "radius" &&
        type !== "spacing"
        ) {
        applyStyles(selectionStart,selectionEnd,item,ob);
        }
    
        if (type == "fontSize") {
        var minSize = arrayMin($scope.listFontSizeInPt),
            maxSize = arrayMax($scope.listFontSizeInPt);
        if ($scope.forceMinSize && minSize > value) value = minSize;
        if ($scope.forceMaxSize && maxSize < value) value = maxSize;
        if (!!item.getSelectedText()) {
            item.getSelectedText().length === item.get("text").length
            ? applyFontSizeStyles(selectionStart, selectionEnd,item,{ptFontSize:value})
            : applyFontSizeStyles(selectionStart, selectionEnd,item);
        } else {
            applyFontSizeStyles(0, item.text.length,item,{ptFontSize:value,fontSize: value * _states.ratioConvertFont});
        }
        $scope.updateTextPxFontSize(item);
        _states.text.ptFontSize = value;
        }

        switch (type) {
        case "fontStyle":
            if (!!item.getSelectedText()) {
            item.getSelectedText().length === item.get("text").length
                ? applyStyles(0, item.text.length,item,{fontStyle:value})
                : applyStyles(selectionStart, selectionEnd,item,{fontStyle:value});
            } else {
            applyStyles(0, item.text.length,item,ob);
            }

            break;

        case "fontWeight":
            if (!!item.getSelectedText()) {
            item.getSelectedText().length === item.get("text").length
                ? applyStyles(0, item.text.length,item,{fontWeight:value})
                : applyStyles(selectionStart, selectionEnd,item,{fontWeight:value});
            } else {
            applyStyles(0, item.text.length,item,ob);
            }
            break;

        case "is_uppercase":
            var currentText = item.get("text");
            var selectedText = currentText.substring(0, item.text.length);
            var isUppercase = selectedText === selectedText.toUpperCase();
            var newText = isUppercase
            ? selectedText.toLowerCase()
            : selectedText.toUpperCase();
            var modifiedText =
            currentText.substring(0, 0) +
            newText +
            currentText.substring(item.text.length);

            item.set({ text: modifiedText });

            break;
        case "fontFamily":
            if (!_.filter(_states.usedFonts, ["alias", value]).length) {
            _states.usedFonts.push($scope.getFontInfo(value));
            }
            _states.text.font = $scope.getFontInfo(value);
            if (!_states.text.font.file.b) {
            item.set({ fontWeight: "normal" });
            _states.text.fontWeight = "normal";
            }
            if (!_states.text.font.file.i) {
            item.set({ fontStyle: "normal" });
            _states.text.fontStyle = "normal";
            }
            if (
            !_states.text.font.file.bi &&
            item.get("fontWeight") == "bold" &&
            item.get("fontStyle") == "italic"
            ) {
            item.set({ fontWeight: "normal", fontStyle: "normal" });
            _states.text.fontWeight = "normal";
            _states.text.fontStyle = "normal";
            }
            break;
        }
        _states.text[type] = value;
        if (type == "rtl") {
        item.set({ text: item.text.split("").reverse().join("") });
        }
        if (type.indexOf("font") > -1) {
        var font = new FontFaceObserver(_states.text.fontFamily, {
            weight: _states.text.fontWeight,
            style: _states.text.fontStyle,
        });
        font.load(item.get("text")).then(
            function () {
            fabric.util.clearFabricFontCache(_states.text.fontFamily);
            $timeout(function () {
                item.initDimensions();
                item.setCoords();
                $scope.afterObjectModify();
                $scope.renderStage();
            });
            },
            function () {
            item.setCoords();
            $scope.renderStage();
            }
        );
        if ($scope.settings.nbdesigner_enable_text_check_lang == "yes") {
            $scope.checkCharacter(item);
        }
        } else {
        item.setCoords();
        $scope.afterObjectModify();
        $scope.renderStage();
        }
        $scope.normalizeText(item);
        $scope.updateLayersList();
    };
/*************************************end changed setTextAttribute*****************/
    $scope.setShadow = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        if( !appConfig.ready ) return;
        var item = _canvas.getActiveObject();
        if( !item ) return;
        $scope.beforeObjectModify(item);
        var colorArr = fabric.Color.sourceFromHex( $scope.stages[$scope.currentStage].states.shadow.color ),
        color = `rgba(${colorArr[0]},${colorArr[1]},${colorArr[2]},${$scope.stages[$scope.currentStage].states.shadow.opacity})`;
        item.set({
            shadow: {
                color: color,
                offsetX: $scope.stages[$scope.currentStage].states.shadow.offsetX,
                offsetY: $scope.stages[$scope.currentStage].states.shadow.offsetY,
                blur: $scope.stages[$scope.currentStage].states.shadow.blur
            }
        });
        $scope.renderStage();
        $scope.afterObjectModify();
        $scope.updateApp();
    };
    $scope.removeShadow = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        if( !appConfig.ready ) return;
        var item = _canvas.getActiveObject();
        if( !item ) return;
        $scope.beforeObjectModify(item);
        delete item.shadow;
        $scope.renderStage();
        $scope.afterObjectModify();
        $scope.updateApp();
    };
    /* Extenal Image */
    $scope.addImageFromClipboard = function( file, type ){
        $scope.toggleStageLoading();
        $scope.resource.upload.progressBar = 0;
        jQuery('.nbd-progress-bar').addClass('active');
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            object = _canvas.getActiveObject();
        if( !!object && !!object.get('maskId') && files.length == 1 ){
            var maskId = object.get('maskId');
        }
        NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function(data){
            var data = JSON.parse(data);
            if( data.flag == 1 ){
                if( angular.isDefined(data.ilr) ) $scope.resource.upload.ilr = true;
                if( $scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no' ){
                    $scope.toggleStageLoading();
                    alert(data.mes);
                    return;
                };
                $scope.storeUploadFile(data, data.name);
                if( maskId ){
                    $scope.addImage(data, false, true, false, false, maskId);
                }else{
                    $scope.addImage(data, false, true );
                }
                jQuery("#tab-photo .tab-scroll").stop().animate({
                    scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                }, 100);
                localStorage.setItem('uploaded', $scope.resource.upload.data);
                $scope.onEndRepeat('upload');
            }else{
                $scope.toggleStageLoading();
                alert(data.mes);
            }
            jQuery('.nbd-progress-bar').removeClass('active');
        }, function( progress ){
            $scope.resource.upload.progressBar = progress.toFixed(0);
        });
    };
    $scope.addImageFromUrl = function( dataImg, extenal, ilr, maskId ){
        var url = typeof dataImg == 'object' ? dataImg.url : dataImg;
        if( url == '' ) return;
        $scope.toggleStageLoading();
        $scope.showDesignTab();
        if(url.match(/\.(svg)$/) != null ){
            var art = {url: url, name: ''};
            $scope.addArt(art, false, true);
            return
        };
        if( $scope.resource.addImageContext == 'manual' ){
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                object = _canvas.getActiveObject();
            if( !!object && !!object.get('maskId') ){
                maskId = object.get('maskId');
            }
        }
        if( angular.isUndefined(extenal) || extenal ){
            NBDDataFactory.get('nbdesigner_copy_image_from_url', {url: url, gapi: $scope.resource.gapi}, function(data){
                data = JSON.parse(data);
                if(data['flag'] == 1){
                    if( angular.isDefined( maskId ) ){
                        $scope.addImage(data, false, true, false, false, maskId);
                    }else{
                        $scope.addImage(data, false, true);
                    }
                    $scope.storeUploadFile(data, '');
                } else{
                    alert('Try to download image and then upload to our server!');
                }
            });
        }else{
            if( ilr ) $scope.resource.upload.ilr = true;
            if( angular.isDefined( maskId ) ){
                $scope.addImage(dataImg, false, true, false, false, maskId);
            }else{
                $scope.addImage(dataImg, false, true);
            }
        }
        $scope.resource.addImageContext = '';
    };
    /* Image */
    $scope.getUniqMask = function(){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            count = 0,
            maskId = '';
        _canvas.forEachObject(function(obj, index) {
            if( !!obj.get('maskId') ){
                count++;
                if( maskId == '' ){
                    maskId = obj.get('maskId');
                }
            };
        });
        return count == 1 ? maskId : '';
    };
    $scope.getEmptyMask = function(){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            maskId = '';
        _canvas.forEachObject(function(obj, index) {
            if( !!obj.get('maskId') && obj.get('srcChanged') === false ){
                if( maskId == '' ){
                    maskId = obj.get('maskId');
                }
            };
        });
        return maskId;
    };
    $scope.addImage = function(data, showLoading, hideLoading, additionalTitle, additionalValue, maskId ){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
            url = typeof data == 'object' ? ( angular.isDefined( data.src ) ? data.src : data.url ) : data;
        if( showLoading ) $scope.toggleStageLoading();
        if( angular.isUndefined( maskId ) && !$scope.isTemplateMode && $scope.settings.nbdesigner_auto_fill_template_masks == 'yes' ){
            var _maskId = $scope.getEmptyMask();
            if( _maskId != '' ) maskId = _maskId;
        }
        if( angular.isUndefined( maskId ) && !$scope.isTemplateMode && $scope.settings.nbdesigner_limit_photo_by_masks == 'yes' ){
            if( hideLoading ) {
                $timeout(function(){
                    $scope.toggleStageLoading();
                });
            }
            return;
        }
        fabric.Image.fromURL(url, function(op) {
            if( angular.isDefined( maskId ) || $scope.stages[$scope.currentStage].states.elementUpload ){
                var object;
                if( angular.isDefined( maskId ) ){
                    object = $scope.getMaskedLayerByMaskId( maskId );
                } else {
                    object = _canvas.getActiveObject();
                }
                var element = object.getElement();
                $scope.beforeObjectModify(object);
                element.setAttribute("src", url);
                var scaleX = object.width * object.scaleX / op.width,
                scaleY = object.width * object.scaleX / op.width;
                if( angular.isDefined( maskId ) ) {
                    var mask = $scope.getMaskLayer( maskId ),
                    width = mask.get('width') * mask.get('scaleX'),
                    height = mask.get('height') * mask.get('scaleY'),
                    newWidth = width,
                    newHeight = height;
                    if( ( op.width / op.height ) > ( width / height ) ){
                        newWidth = op.width / op.height * newHeight;
                    }else{
                        newHeight = op.height / op.width * newWidth;
                    }
                    scaleX = newWidth / op.width;
                    scaleY = newHeight / op.height;

                    object.set({
                        isEmptyMask: false,
                        srcChanged: true
                    });
                }
                object.set({
                    dirty: true,
                    width: op.width,
                    height: op.height,
                    scaleX: scaleX,
                    scaleY: scaleY
                });

                if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
                    if( angular.isDefined( maskId ) ) {
                        scaleX = newWidth / data.width;
                        scaleY = newHeight / data.height;
                    }else{
                        var scaleX = object.width * object.scaleX / data.width,
                        scaleY = object.width * object.scaleX / data.width;
                    }
                    object.set({
                        origin_url: data.origin_url,
                        origin_width: data.width,
                        origin_height: data.height,
                        width: data.width,
                        height: data.height,
                        scaleX: scaleX,
                        scaleY: scaleY
                    });
                }else if( !!object.origin_url ){
                    delete object.origin_url; 
                }

                object.setCoords();
                if( angular.isDefined( maskId ) ) $scope.adjustMaskedLayers(object);
                $scope.renderStage();
                if( angular.isDefined( maskId ) ) {
                    $scope.adjustMaskedLayers(object);
                    if( $scope.checkActiveFilter && object.filters.length ){
                        object._originalElement = op._element;
                        object.applyFilters(false, function(){
                            setTimeout(() => $scope.renderStage(), 200);
                            setTimeout(() => $scope.renderStage(), 500);
                            setTimeout(() => $scope.renderStage(), 1000);
                        }, true);
                    }else{
                        $timeout(function(){
                            $scope.renderStage();
                        }, 500);
                        $timeout(function(){
                            $scope.renderStage();
                        }, 1000);
                        $timeout(function(){
                            $scope.renderStage();
                        }, 2000);
                        $timeout(function(){
                            $scope.renderStage();
                        }, 3000);
                    }
                };
                $scope.afterObjectModify();
            }else{
                var _ratio = NBDESIGNCONFIG.nbdesigner_enable_auto_fit_image == 'yes' ? 1 : 0.9;
                var max_width = _canvas.width / scale * _ratio,
                max_height = _canvas.height / scale * _ratio,
                new_width = max_width;
                if ( op.width < max_width ) new_width = op.width;
                var width_ratio = new_width / op.width,
                new_height = op.height * width_ratio;
                if ( new_height > max_height ) {
                    new_height = max_height;
                    var height_ratio = new_height / op.height;
                    new_width = op.width * height_ratio;
                };
                op.set({
                    fill: '#ff0000',
                    scaleX: new_width / op.width,
                    scaleY: new_height / op.height
                });

                if( typeof data == 'object' && angular.isDefined( data.origin_url ) ){
                    op.set({
                        origin_url: data.origin_url,
                        origin_width: data.width,
                        origin_height: data.height,
                        width: data.width,
                        height: data.height,
                        scaleX: new_width / data.width,
                        scaleY: new_height / data.height
                    });
                }

                if( typeof data == 'object' && angular.isDefined( data.origin_pdf ) ){
                    op.set({ 
                        origin_pdf: data.origin_pdf,
                        lockRotation: true,
                        hasRotatingPoint: false
                    });
                }

                if( additionalTitle ) op[additionalTitle] = additionalValue;
                _canvas.add(op);
            }
            if( hideLoading ) {
                $timeout(function(){
                    $scope.toggleStageLoading();
                });
            }
        }, {crossOrigin: 'anonymous'});
    };
    $scope.mask = 1;
    $scope.pathCommand = '';
    $scope.svgPath = '';
    $scope.getPathCommand = function(){
        var svgStr = $scope.svgPath.replace(/<!--[\s\S]*?-->/g, "").replace(/<\?xml[\s\S]*?\?>/g, "").replace(/<style[\s\S]*?style>/g, "").replace(/\n|\r/gm, " ").replace(/  /g, " ").replace(/^ /g, "").replace(/ $/g, "").replace(/(?:class|id|style|xmlns\:xlink|xml\:space|fill|enable-background)=['\"][^'\"]*['\"]/g  , ""  ).replace(/<\/?g>/g  , "").replace(/\s{2,}/g, ' ').replace(/(\/?>) </g, '$1<');
        var _regex = /d=["'](.*?)["']/gm;
        $scope.pathCommand = '';
        if( svgStr.match( /<path.*\/>/gm ) && svgStr.match( _regex ) ){
            matches = _regex.exec( svgStr );
            $scope.pathCommand = angular.isDefined( matches[1] ) ? matches[1] : '';
        }
    };
    $scope.createClippingMask = function(maskIndex, obj){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        obj = obj ? obj : _canvas.getActiveObject();
        if( obj ){
            var width = obj.get('width'),
            height = obj.get('height'),
            top = obj.get('top'),
            left = obj.get('left'),
            scaleX = obj.get('scaleX'),
            scaleY = obj.get('scaleY'),
            realWidth = scaleX * width,
            realHeight = scaleY * height,
            realLeft = left - realWidth / 2,
            realTop = top - realHeight / 2;
            var pathCommand = maskIndex > -1 ? $scope.masks[ maskIndex ] : $scope.pathCommand;
            if( pathCommand == '' ) return;
            var path = new fabric.Path( pathCommand );
            $scope.contextAddLayers = 'addMask';
            _canvas.add(path);
            var pathObj = _canvas.item(_canvas.getObjects().length - 1);
            var newWidth = realWidth, newHeight = realHeight, newLeft = realLeft, newTop = realTop;
            if( ( realWidth / realHeight ) > ( pathObj.width / pathObj.height ) ){
                newWidth = newHeight * pathObj.width / pathObj.height;
                newLeft += ( realWidth - newWidth )/2;
            }else{
                newHeight = newWidth * pathObj.height / pathObj.width;
                newTop += ( realHeight - newHeight )/2;
            }
            var d = new Date(),
            itemId = d.getTime() + Math.floor(Math.random() * 1000);
            pathObj.set({
                scaleX: newWidth / pathObj.width,
                scaleY: newHeight / pathObj.height,
                isMask: 1,
                left: newLeft,
                top: newTop,
                absolutePositioned: true,
                strokeWidth: 0,
                lockRotation: true,
                itemId: itemId,
                selectable: false,
                fill: '#ffffff',
                opacity: 0.001
            });
            pathObj.setCoords();
            $timeout(function(){
                obj.set({
                    clipPath: pathObj,
                    perPixelTargetFind: true,
                    centeredScaling: true,
                    maskId: itemId
                });
                $scope.stages[$scope.currentStage].states.isMasked = true;
                $scope.updateMaskLayer();
                $scope.updateLayersList();
                $scope.renderStage();
            });
        }
    };
    $scope.removeClippingMask = function(obj, needreRender, withoutRemoveMask){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'];
        obj = obj ? obj : _canvas.getActiveObject();
        if( !!obj.get('maskId') ){
            var maskLayerInsex = $scope.getLayerById( obj.get('maskId') ),
            maskLayer = _canvas.item( maskLayerInsex );
            !withoutRemoveMask && _canvas.remove( maskLayer );
        }
        $scope.stages[$scope.currentStage].states.isMasked = false;
        obj.maskId = null;
        obj.clipPath = null;
        obj.perPixelTargetFind = false;
        if( NBDESIGNCONFIG.nbdesigner_object_center_scaling == 'no' ){
            obj.centeredScaling = false;
        }
        needreRender = angular.isDefined(needreRender) ? needreRender : true;
        $scope.updateMaskLayer();
        needreRender && $scope.renderStage();
        $scope.updateLayersList();
    };
    $scope.editMask = function(){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        obj = _canvas.getActiveObject();
        if( obj ){
            var maskId = obj.get("maskId"),
            maskObjIndex = $scope.getLayerById( maskId ),
            maskLayer = _canvas.item( maskObjIndex );
            obj.moveTo( maskObjIndex );
            maskLayer.set({selectable: true, hasRotatingPoint: false});
            _canvas.setActiveObject(maskLayer);
            $scope.ctxMenuStyle.visibility = 'hidden';
            $scope.updateApp();
        }
    };
    $scope.detachImage = function(){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        obj = _canvas.getActiveObject();
        if( obj ){
            var maskId = obj.get("maskId"),
            maskObjIndex = $scope.getLayerById( maskId ),
            maskLayer = _canvas.item( maskObjIndex ),
            maskedLayerInsex = $scope.getLayerById( obj.get('itemId') ),
            defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
            fabric.Image.fromURL(defaultMaskImageUrl, function(op) {
                $scope.contextAddLayers = 'addMask';
                var top = maskLayer.get('top'),
                left = maskLayer.get('left'),
                scaleX = maskLayer.get('scaleX'),
                scaleY = maskLayer.get('scaleY'),
                width = maskLayer.get('width'),
                height = maskLayer.get('height'),
                realWidth = width * scaleX,
                realHeight = height * scaleY,
                newWidth = realWidth,
                newHeight = realHeight;
                if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                    newWidth = op.width / op.height * newHeight;
                }else{
                    newHeight = op.height / op.width * newWidth;
                }
                var d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);
                op.set({
                    clipPath: maskLayer,
                    perPixelTargetFind: true,
                    centeredScaling: true,
                    maskId: maskId,
                    scaleX: newWidth / op.width,
                    scaleY: newHeight / op.height,
                    top: top + realHeight / 2,
                    left: left + realWidth / 2,
                    itemId: itemId,
                    isEmptyMask: true,
                    srcChanged: false
                });
                $scope.deactiveAllLayer();
                $scope.removeClippingMask( obj, false, true );
                _canvas.add(op);
                op.moveTo( maskedLayerInsex );
                $timeout(function(){
                    obj.set({
                        top: obj.get('top') + 20,
                        left: obj.get('left') + 20
                    });
                    obj.moveTo( maskedLayerInsex + 1 );
                    _canvas.setActiveObject(obj);
                    $scope.updateMaskLayer();
                    $scope.renderStage();
                });
            }, {crossOrigin: 'anonymous'});
        }
    };
    $scope.exitMaskMode = function(){
        $scope.deactiveAllLayer();
        $scope.updateMaskLayer();
        $scope.renderStage();
    };
    $scope.masks = [
        "M 12 4.248 c -3.148 -5.402 -12 -3.825 -12 2.944 c 0 4.661 5.571 9.427 12 15.808 c 6.43 -6.381 12 -11.147 12 -15.808 c 0 -6.792 -8.875 -8.306 -12 -2.944 Z",
        "M 18 1 l -6 4 l -6 -4 l -6 5 v 7 l 12 10 l 12 -10 v -7 Z",
        "M 12 0 c -2.995 2.995 -7.486 4 -11 4 c 0 8.583 5.068 16.097 11 20 c 5.932 -3.903 11 -11.417 11 -20 c -3.514 0 -8.005 -1.005 -11 -4 Z",
        "M 1 4 c 0 8.578 5.071 16.1 11 20 c 5.929 -3.9 11 -11.422 11 -20 c -2.828 -2.329 -7.153 -4 -11 -4 c -3.838 0 -8.172 1.671 -11 4 Z",
        "M 12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01 Z",
        "M 12 0 l 2.139 2.629 l 3.068 -1.441 l 0.786 3.297 l 3.389 0.033 l -0.722 3.312 l 3.039 1.5 l -2.088 2.67 l 2.088 2.67 l -3.039 1.5 l 0.722 3.312 l -3.389 0.033 l -0.786 3.297 l -3.068 -1.441 l -2.139 2.629 l -2.139 -2.629 l -3.068 1.441 l -0.786 -3.297 l -3.389 -0.033 l 0.722 -3.312 l -3.039 -1.5 l 2.088 -2.67 l -2.088 -2.67 l 3.039 -1.5 l -0.722 -3.312 l 3.389 -0.033 l 0.786 -3.297 l 3.068 1.441 Z",
        "M 0.000 16.000 L 12.000 20.785 L 13.856 8.000 L 24.000 0.000 L 13.856 -8.000 L 12.000 -20.785 L 0.000 -16.000 L -12.000 -20.785 L -13.856 -8.000 L -24.000 0.000 L -13.856 8.000 L -12.000 20.785 Z",
        "M 12 0.587 l 3.668 7.568 l 8.332 1.151 l -6.064 5.828 l 1.48 8.279 l -7.416 -3.967 l -7.417 3.967 l 1.481 -8.279 l -6.064 -5.828 l 8.332 -1.151 Z",
        "M 24 16.971 l -7.029 7.029 h -9.942 l -7.029 -7.029 v -9.942 l 7.029 -7.029 h 9.942 l 7.029 7.029 Z",
        "M0 0 L24 0 L12 20.78Z",
        "M-12,0a12,12 0 1,0 24,0a12,12 0 1,0 -24,0Z",
        "M 9 0 c -5 0 -9 7 -9 14 c 0 5 3 10 9 10 c 6 0 9 -5 9 -10 c 0 -7 -4 -14 -9 -14 Z",
        "M10,10 h20 a2,2 0 0 0.1 2,2 v20 a2,2 0 0 0.1 -2,2 h-20 a2,2 0 0 0.1 -2,-2 v-20 a2,2 0 0 0.1 2,-2 Z",
        "M 0.054 23 c 0.971 -1.912 2.048 -4.538 1.993 -6.368 c -1.308 -1.562 -2.047 -3.575 -2.047 -5.625 c 0 -5.781 5.662 -10.007 12 -10.007 c 6.299 0 12 4.195 12 10.007 c 0 6.052 -6.732 11.705 -15.968 9.458 c -1.678 1.027 -5.377 2.065 -7.978 2.535 Z",
        "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z",
        "M0 0 L24 0 L24 24 L0 24Z",
        "M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z",
        "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z", 
        "M5.94 18.99H15c.65 0 1.26-.31 1.63-.84l3.95-5.57c.25-.35.25-.81 0-1.16l-3.96-5.58C16.26 5.31 15.65 5 15 5H5.94c-.81 0-1.28.93-.81 1.59L9 12l-3.87 5.41c-.47.66 0 1.58.81 1.58z",
        "M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z",
        "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z",
        "M13.2 7.07L10.25 11l2.25 3c.33.44.24 1.07-.2 1.4-.44.33-1.07.25-1.4-.2-1.05-1.4-2.31-3.07-3.1-4.14-.4-.53-1.2-.53-1.6 0l-4 5.33c-.49.67-.02 1.61.8 1.61h18c.82 0 1.29-.94.8-1.6l-7-9.33c-.4-.54-1.2-.54-1.6 0z",
        "M6.05,8.05c-2.73,2.73-2.73,7.15-0.02,9.88c1.47-3.4,4.09-6.24,7.36-7.93c-2.77,2.34-4.71,5.61-5.39,9.32 c2.6,1.23,5.8,0.78,7.95-1.37c2.99-2.99,3.83-11.14,4.01-13.38c0.02-0.31-0.23-0.56-0.53-0.53C17.19,4.22,9.04,5.06,6.05,8.05z",
        "M12.43 2.3c-2.38-.59-4.68-.27-6.63.64-.35.16-.41.64-.1.86C8.3 5.6 10 8.6 10 12c0 3.4-1.7 6.4-4.3 8.2-.32.22-.26.7.09.86 1.28.6 2.71.94 4.21.94 6.05 0 10.85-5.38 9.87-11.6-.61-3.92-3.59-7.16-7.44-8.1z",
        "M7 2v11h3v9l7-12h-4l3-8z"
    ];
    $scope.replaceMaskedImage = function(){
        $timeout(function(){
            jQuery('#nav-photos').triggerHandler('click');
            $timeout(function(){
                if( jQuery('#tab-photo .result-loaded').hasClass('loaded') ){
                    jQuery('[data-type="image-upload"]').click();
                    $timeout(function(){
                        jQuery('[data-type="image-upload"]').click();
                    }, 400);
                }else{
                    jQuery('[data-type="image-upload"]').click();
                }
            }, 400);
        });
    };
    $scope.cropObj = {status: false};
    $scope.initCrop = function(){
        $scope.cropObj.status = true;
        jQuery('.nbd-popup.popup-nbd-crop').nbShowPopup();
        $scope.cropObj.src = $scope.stages[$scope.currentStage].states.origin_src;
        $scope.cropObj.origin_url = $scope.stages[$scope.currentStage].states.origin_url;
        jQuery('.nbd-popup.popup-nbd-crop .overlay-popup').addClass('nbo-disable');
        jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
        var img = new Image();
        img.src = $scope.cropObj.src;
        img.onload = function() {
            $scope.cropObj.width = this.width;
            $scope.cropObj.height = this.height;
            if( $scope.stages[$scope.currentStage].states.origin_width ){
                $scope.cropObj.width = $scope.stages[$scope.currentStage].states.origin_width;
                $scope.cropObj.height = $scope.stages[$scope.currentStage].states.origin_height;
            }
            $timeout(function(){
                $scope.cropObj.canvas = $scope.cropObj.canvas ? $scope.cropObj.canvas : new FabricWindow.Canvas('crop-handle-wrap');
                var width = jQuery('#crop-source').width(),
                    height = jQuery('#crop-source').height();
                $scope.cropObj.canvas.setDimensions({'width' : width, 'height' : height});
                $scope.cropObj.canvas.clear();
                $scope.cropObj.canvas.on('mouse:down', function(e) {
                    $scope.cropObj.canvas.item(0);
                });
                $scope.cropObj.canvas.on('object:modified', function( options ){
                    var obj = options.target;
                    var boundingRect = obj.getBoundingRect(true);
                    if (boundingRect.left < 0) obj.left = 0;
                    if (boundingRect.top < 0) obj.top = 0;
                    obj.setCoords();boundingRect = obj.getBoundingRect(true);
                    var left = boundingRect.left > 0 ? boundingRect.left : 0,
                        top = boundingRect.top > 0 ? boundingRect.top : 0;
                    if (boundingRect.left + boundingRect.width > $scope.cropObj.canvas.getWidth() ){
                        obj.scaleX = obj.scaleX * ( ( $scope.cropObj.canvas.getWidth() - left ) / boundingRect.width );
                    }
                    if( boundingRect.top + boundingRect.height > $scope.cropObj.canvas.getHeight() ){
                        obj.scaleY = obj.scaleY * ( ( $scope.cropObj.canvas.getHeight() - top ) / boundingRect.height );
                    };
                    obj.setCoords();
                });
                var rect = new fabric.Rect({
                    left: 0,
                    top: 0,
                    fill: 'rgba(255,255,255,0.15)',
                    width: 200,
                    height: 200,
                    strokeWidth: 1,
                    stroke: '#ffffff',
                    strokeDashArray: [5, 5]
                });
                if( angular.isDefined($scope.stages[$scope.currentStage].states.crop_left) ){
                    rect.set({
                        left: $scope.stages[$scope.currentStage].states.crop_left,
                        top: $scope.stages[$scope.currentStage].states.crop_top,
                        width: $scope.stages[$scope.currentStage].states.crop_width,
                        height: $scope.stages[$scope.currentStage].states.crop_height,
                        scaleX: $scope.stages[$scope.currentStage].states.crop_scaleX,
                        scaleY: $scope.stages[$scope.currentStage].states.crop_scaleY
                    });
                };
                $scope.cropObj.canvas.add(rect);
                var item = $scope.cropObj.canvas.item(0);
                item.setControlVisible('mtr', false);
                $scope.cropObj.canvas.setActiveObject(item);
                if( angular.isUndefined($scope.stages[$scope.currentStage].states.crop_left) ){
                    $scope.cropObj.canvas.viewportCenterObject(item);
                }
            }, 100);
        };
    };
    $scope.cancelCrop = function(){
        jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
        jQuery('.nbd-popup.popup-nbd-crop .close-popup').triggerHandler('click');
    };
    $scope.cropImage = function(){
        function add_image( url ){
            fabric.Image.fromURL(url, function(op) {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'];
                var object = _canvas.getActiveObject(),
                element = object.getElement();
                $scope.beforeObjectModify(object);
                element.setAttribute("src", url);
                object.set({
                    origin_src: $scope.cropObj.src, 
                    crop_left: $scope.cropObj.bound.left,
                    crop_top: $scope.cropObj.bound.top,
                    crop_width: $scope.cropObj.bound.width,
                    crop_height: $scope.cropObj.bound.height,
                    crop_scaleX: $scope.cropObj.bound.scaleX,
                    crop_scaleY: $scope.cropObj.bound.scaleY,
                    cropped: 1
                });
                $scope.cropObj.bound = {};
                _canvas.getActiveObject().set({
                    dirty: true,
                    width: op.width,
                    height: op.height,
                    scaleX: object.width * object.scaleX / op.width,
                    scaleY: object.width * object.scaleX / op.width
                });
                object.setCoords();

                if( $scope.checkActiveFilter && object.filters.length ){
                    object._originalElement = op._element;
                    object.applyFilters(false, function(){
                        setTimeout(() => $scope.renderStage(), 200);
                    }, true);
                } else {
                    $scope.renderStage();
                    $timeout(function(){
                        $scope.renderStage();
                    }, 100);
                }

                $scope.getCurrentLayerInfo();
                $scope.afterObjectModify();
                jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
                jQuery('.nbd-popup.popup-nbd-crop .close-popup').triggerHandler('click');
            }, {crossOrigin: 'anonymous'});
        }
        var bound = $scope.cropObj.canvas.item(0).getBoundingRect(true),
            imgScale = $scope.cropObj.width / $scope.cropObj.canvas.width;
        $scope.cropObj.bound = {
            left: $scope.cropObj.canvas.item(0).get('left'),
            top: $scope.cropObj.canvas.item(0).get('top'),
            width: $scope.cropObj.canvas.item(0).get('width'),
            height: $scope.cropObj.canvas.item(0).get('height'),
            scaleX: $scope.cropObj.canvas.item(0).get('scaleX'),
            scaleY: $scope.cropObj.canvas.item(0).get('scaleY')
        };
        var fd = new FormData();
        fd.append('nonce', NBDESIGNCONFIG['nonce']);
        fd.append('action', 'nbd_crop_image');
        fd.append('url', $scope.cropObj.src);
        if( $scope.cropObj.origin_url ){
            fd.set('url', $scope.cropObj.origin_url);
        }
        fd.append('startX', bound.left * imgScale);
        fd.append('startY', bound.top * imgScale);
        fd.append('width', bound.width * imgScale);
        fd.append('height', bound.height * imgScale);
        jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').addClass('active');
        jQuery.ajax({
            url: NBDESIGNCONFIG['ajax_url'],
            method: "POST",
            processData: false,
            contentType: false,
            data: fd
        }).done(function(data){
            if( data.flag == 1 ){
                add_image(data.url);
            }else{
                jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
            }
        });
    };
    $scope.addMask = function( shapeIndex ){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
        max_width = _canvas.width / scale * .3,
        max_height = _canvas.height / scale * .3,
        new_width = max_width;
        var pathCommand = shapeIndex > -1 ? $scope.masks[ shapeIndex ] : $scope.pathCommand;
        if( pathCommand == '' ) return;

        var path = new fabric.Path( pathCommand );
        var width_ratio = new_width / path.width,
        new_height = path.height * width_ratio;
        if (new_height > max_height) {
            new_height = max_height;
            var height_ratio = new_height / path.height;
            new_width = path.width * height_ratio;
        }
        path.scaleToWidth(new_width);
        path.scaleToHeight(new_height);
        path.set({
            isTemMask: true,
            fill: '#dddddd'
        });
        _canvas.add(path);
    };
    $scope.addPhotoFrame = function( frame ){
        var url = '//dpeuzbvf3y4lr.cloudfront.net/frames/svg/s' + ( frame + 1 ) + '.svg',
        defaultImageUrl = NBDESIGNCONFIG.assets_url + 'images/frame-bg.jpg',
        stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
        max_width = _canvas.width / scale * .3,
        max_height = _canvas.height / scale * .3,
        new_width = max_width;

        $scope.toggleStageLoading();

        function onFail(){
            $scope.toggleStageLoading();
        }

        fabric.loadSVGFromURL(url, function(ob, op) {
            if( ob ){
                $scope.contextAddLayers = 'addMask';
                var d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);

                if (op.width < max_width) new_width = op.width;
                var width_ratio = new_width / op.width,
                new_height = op.height * width_ratio;
                if (new_height > max_height) {
                    new_height = max_height;
                    var height_ratio = new_height / op.height;
                    new_width = op.width * height_ratio;
                }
                var object = fabric.util.groupSVGElements(ob, op);
                object.scaleToWidth(new_width);
                object.scaleToHeight(new_height);

                object.set({
                    itemId: itemId,
                    isMask: 1,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    selectable: false,
                    fill: '#ffffff',
                    opacity: 0.001
                });

                _canvas.add(object);

                $timeout(function(){
                    $scope.contextAddLayers = 'addMask';
                    var maskLayer = _canvas.item(_canvas.getObjects().length - 1);
                    _canvas.viewportCenterObject(maskLayer);
                    fabric.Image.fromURL(defaultImageUrl, function(op) {
                        var top = maskLayer.get('top'),
                        left = maskLayer.get('left'),
                        scaleX = maskLayer.get('scaleX'),
                        scaleY = maskLayer.get('scaleY'),
                        width = maskLayer.get('width'),
                        height = maskLayer.get('height'),
                        realWidth = width * scaleX,
                        realHeight = height * scaleY,
                        newWidth = realWidth,
                        newHeight = realHeight;
                        if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                            newWidth = op.width / op.height * newHeight;
                        }else{
                            newHeight = op.height / op.width * newWidth;
                        }
                        op.set({
                            clipPath: maskLayer,
                            perPixelTargetFind: true,
                            centeredScaling: true,
                            maskId: itemId,
                            scaleX: newWidth / op.width,
                            scaleY: newHeight / op.height,
                            top: top + realHeight / 2,
                            left: left + realWidth / 2,
                            isEmptyMask: true,
                            srcChanged: false
                        });
                        _canvas.add(op);
                        $scope.toggleStageLoading();
                    });
                }, 100);
            }else{
                onFail();
            }
        });
    };
    $scope.addFrame = function(frame){
        var rows = frame.areas.match(/[^"]+(?=(" ")|"$)/g),
            numCols = rows[0].split(" ").length,
            numRows = rows.length,
            colWidths = [],
            rowHeights = [];
        if( frame.columns != '' ){
            colWidths = frame.columns.replace(/fr/g, '').split(" ").map(function(col){
                return 1 * col;
            });
        }else{
            for(var i=0; i< numCols; i++){
                colWidths.push(1);
            }; 
        }
        if( frame.rows != '' ){
            rowHeights = frame.rows.replace(/fr/g, '').split(" ").map(function(col){
                return 1 * col;
            });
        }else{
            rows.forEach(function(){
                rowHeights.push(1);
            }); 
        }
        var totalWidth = colWidths.reduce((accumulator, currentValue, currentIndex, array) => {
            return accumulator + currentValue;
        });
        var totalHeight = rowHeights.reduce((accumulator, currentValue, currentIndex, array) => {
            return accumulator + currentValue;
        });
        var panels = {};
        rows.forEach(function(row, idx){
            var rowArr = row.split(" ");
            rowArr.forEach(function(r, i){
                if( typeof panels[r] == 'undefined' ){
                    panels[r] = {
                        x: i,
                        y: idx,
                        colWidth: colWidths[i],
                        rowHeight: rowHeights[idx],
                        rows: [idx],
                        columns: [i]
                    };
                }else{
                    if( panels[r].rows.indexOf( idx ) == -1 ){
                        panels[r].rowHeight += rowHeights[idx];
                        panels[r].rows.push(idx);
                    }
                    if( panels[r].columns.indexOf( i ) == -1 ){
                        panels[r].colWidth += colWidths[i];
                        panels[r].columns.push(i);
                    }
                }
            });
        });
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        gap = 2,
        cellWidth = ( _canvas.width - gap * ( totalWidth - 1 ) ) / totalWidth,
        cellHeight = ( _canvas.height - gap * ( totalHeight - 1 ) ) / totalHeight;
        var url = NBDESIGNCONFIG.assets_url + 'images/frame-bg.jpg';
        angular.forEach(panels, function(panel, key) {
            $scope.contextAddLayers = 'addMask';
            var d = new Date(),
            itemId = d.getTime() + Math.floor(Math.random() * 1000);
            var colLeft = 0, rowTop = 0;
            for(var i = 0; i < colWidths.length; i++){
                if( i < panel.x ){
                    colLeft += colWidths[i];
                }
            }
            for(var i = 0; i < rowHeights.length; i++){
                if( i < panel.y ){
                    rowTop += rowHeights[i];
                }
            }
            var path = new fabric.Path( $scope.masks[15]);
            path.set({
                top: rowTop * ( cellHeight + gap ),
                left: colLeft * ( cellWidth + gap ),
                scaleX: ( panel.colWidth * cellWidth + ( panel.colWidth - 1 ) * gap ) / path.get('width'),
                scaleY: ( panel.rowHeight * cellHeight + ( panel.rowHeight - 1 ) * gap ) / path.get('height'),
                isMask: 1,
                itemId: itemId,
                absolutePositioned: true,
                strokeWidth: 0,
                lockRotation: true,
                selectable: false,
                fill: '#ffffff',
                opacity: 0.001
            });
            panel.itemId = itemId;
            _canvas.add(path);
        });
        angular.forEach(panels, function(panel, key) {
            fabric.Image.fromURL(url, function(op) {
                $scope.contextAddLayers = 'addMask';
                var mask = $scope.getMaskLayer( panel.itemId ),
                top = mask.get('top'),
                left = mask.get('left'),
                scaleX = mask.get('scaleX'),
                scaleY = mask.get('scaleY'),
                width = mask.get('width'),
                height = mask.get('height'),
                realWidth = width * scaleX,
                realHeight = height * scaleY,
                newWidth = realWidth,
                newHeight = realHeight;
                if( ( op.width / op.height ) > ( realWidth / realHeight ) ){
                    newWidth = op.width / op.height * newHeight;
                }else{
                    newHeight = op.height / op.width * newWidth;
                }
                var d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);
                op.set({
                    clipPath: mask,
                    perPixelTargetFind: true,
                    centeredScaling: true,
                    maskId: panel.itemId,
                    scaleX: newWidth / op.width,
                    scaleY: newHeight / op.height,
                    top: top + realHeight / 2,
                    left: left + realWidth / 2,
                    itemId: itemId,
                    isEmptyMask: true,
                    srcChanged: false
                });
                _canvas.add(op);
            }, {crossOrigin: 'anonymous'});
        });
    };
    $scope.addImageFilter = function( type ){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var object = _canvas.getActiveObject();
        if( object && ( object.type == 'image' || object.type == 'custom-image' ) ){
            var filter = new fabric.Image.filters.CustomFilter({
                jOptions: '{"type":"' + type + '"}'
            });

            var index;
            object.filters.forEach(function(filter, _index) { 
                var options = JSON.parse( filter.jOptions );
                if( options.type == type ) index = _index;
            });
            if( angular.isDefined( index ) ){
                /* 
                    //to modify filter
                    object.filters[index] = filter; 
                */
                object.filters.splice( index, 1 );
                $scope.stages[$scope.currentStage].states.filters[type] = false;
            }else{
                object.filters.push( filter );
                $scope.stages[$scope.currentStage].states.filters[type] = true;
            }

            object.applyFilters(false, function(){
                setTimeout(() => $scope.renderStage());
            });
        }
    };
    $scope.removeImageFilter = function( type ){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var object = _canvas.getActiveObject();
        if( object && ( object.type == 'image' || object.type == 'custom-image' ) ){
            var index;
            object.filters.forEach(function(filter, _index) { 
                var options = JSON.parse( filter.jOptions );
                if( options.type == type ) index = _index;
            });
            if( angular.isDefined( index ) ){
                object.filters.splice( index, 1 );
                object.applyFilters(false, function(){
                    setTimeout(() => $scope.renderStage());
                });
            }
            $scope.stages[$scope.currentStage].states.filters[type] = false;
        }
    };
    $scope.checkActiveFilter = function( type, filters ){
        var index;
        filters.forEach(function(filter, _index) {
            var options = JSON.parse( filter.jOptions );
            if( options.type == type ) index = _index;
        });
        if( angular.isDefined( index ) ){
            return true;
        }
        return false;
    };
    $scope.removeImageFilters = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var object = _canvas.getActiveObject();
        if( object && ( object.type == 'image' || object.type == 'custom-image' ) ){
            object.filters = [];
            object.applyFilters(false, function(){
                setTimeout(() => $scope.renderStage());
            });
            $scope.stages[$scope.currentStage].states.filters = [];
        }
    };
    /* SVG */
    $scope.addSvgFromString = function(svg, showLoading){
        if( angular.isUndefined(showLoading) ) $scope.toggleStageLoading();
        fabric.loadSVGFromString(svg, function(ob, op) {
            $scope._addSvg(ob, op, {name: ''}, true);
        });
    };
    $scope.addSvgFromMedia = function(art, $index){
        if( angular.isDefined($index) && $scope.settings.valid_license == '0' && $index > 19 ){
            alert($scope.settings.nbdlangs.pro_license_alert);
            return;
        }
        $scope.showDesignTab();
        $scope.toggleStageLoading();
        $http({
            method: 'GET',
            url: appConfig.mediaUrl + '/clipart?get_svg=' + art.url.replace("//dpeuzbvf3y4lr.cloudfront.net/", "")
        }).then(function successCallback(response){
            var svg = response.data.data;
            if( !svg ){
                $scope.toggleStageLoading();
                return;
            }
            $scope.addSvgFromString(svg, false);
        }, function errorCallback(response) {
            console.log('Fail to load: svg');
        });
    };
    $scope.addArt = function(art, showLoading, hideLoading){
        if( showLoading ) $scope.toggleStageLoading();
        if(art.url.match(/\.(jpeg|jpg|gif|png)$/) != null){
            $scope.addImage(art.url, false, hideLoading);
        }else{
            fabric.loadSVGFromURL(art.url, function(ob, op) {
                if(ob){
                    $scope._addSvg(ob, op, art, hideLoading);
                }else{
                    alert('Try again!');
                    $scope.toggleStageLoading();
                }
            });
        }
    };
    $scope._addSvg = function(ob, op, art, hideLoading){
        var stage = $scope.stages[$scope.currentStage],
        _canvas = stage['canvas'],
        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
        max_width = _canvas.width / scale * .9,
        max_height = _canvas.height / scale * .9,
        new_width = max_width;

        if (op.width < max_width) new_width = op.width;
        var width_ratio = new_width / op.width,
        new_height = op.height * width_ratio;
        if (new_height > max_height) {
            new_height = max_height;
            var height_ratio = new_height / op.height;
            new_width = op.width * height_ratio;
        }
        var object = fabric.util.groupSVGElements(ob, op);
        object.scaleToWidth(new_width);
        object.scaleToHeight(new_height);
        if( angular.isDefined( art.type ) && art.type == 'qrcode' ){
            object.set( { qrContent: art.qrContent, isQrcode: 1 } );
        } else if( angular.isDefined( art.type ) && art.type == 'barcode' ){
            object.set( { barCodeContent: art.barCodeContent, isBarcode: 1 } );
        }
        _canvas.add(object);
        if( hideLoading ) $scope.toggleStageLoading();
    };
    $scope.addQrCode = function(){
        /* var qr = qrcode(4, 'L', NBDESIGNCONFIG.nbdesigner_default_color); */
        var qr = qrcode(0, 'M', NBDESIGNCONFIG.nbdesigner_default_color);
        qr.addData( $scope.resource.qrText );
        qr.make();
        var _qrcode = qr.createSvgTag();
        fabric.loadSVGFromString(_qrcode, function(ob, op) {
            $scope._addSvg(ob, op, {name: '', type: 'qrcode', qrContent: $scope.resource.qrText}, false);
        });
        jQuery('#barcode').html('');
        jQuery('.main-qrcode').html('').append(_qrcode);
    };
    $scope.updateQrCode = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        if (!obj) return;
        var qr = qrcode(4, 'L', NBDESIGNCONFIG.nbdesigner_default_color),
        content = $scope.stages[$scope.currentStage].states.qrContent;
        qr.addData( content );
        qr.make();
        var _qrcode = qr.createSvgTag();
        fabric.loadSVGFromString(_qrcode, function(ob, op) {
            var object = fabric.util.groupSVGElements(ob, op);
            obj.set({
                dirty: true,
                qrContent: content,
                path: object.path
            });
            $scope.renderStage();
        });
    };
    $scope.addBarCode = function(){
        jQuery('.main-qrcode').html('');
        JsBarcode("#barcode", $scope.resource.qrText, {
            font: NBDESIGNCONFIG.default_font.alias,
            lineColor: NBDESIGNCONFIG.nbdesigner_default_color
        });
        $timeout(function(){
            fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function(ob, op) {
                $scope._addSvg(ob, op, {name: '', barCodeContent: $scope.resource.qrText, type: 'barcode'}, false);
                jQuery('#barcode').unwrap();
            });
        });
    };
    $scope.updateBarCode = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        if (!obj) return;
        var content = $scope.stages[$scope.currentStage].states.barCodeContent;
        jQuery('.main-qrcode').html('');
        JsBarcode("#barcode", content, {
            font: NBDESIGNCONFIG.default_font.alias,
            lineColor: NBDESIGNCONFIG.nbdesigner_default_color
        });
        $timeout(function(){
            fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function(ob, op) {
                var object = fabric.util.groupSVGElements(ob, op);
                object.set({
                    originX: 'center',
                    originY: 'center'
                });
                obj.set({
                    dirty: true,
                    width: object.width,
                    barCodeContent: content,
                    _objects: object._objects
                });
                obj.setCoords();
                $scope.renderStage();
                jQuery('#barcode').unwrap();
            });
        });
    };
    $scope.mapLayerWith = function( key ){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        if (!obj) return;
        if( angular.isDefined( obj.field_mapping ) && obj.field_mapping == key ){
            delete obj.field_mapping;
            delete $scope.stages[$scope.currentStage].states.field_mapping;
        }else{
            obj.set( { field_mapping: key } );
            $scope.stages[$scope.currentStage].states.field_mapping = key;
        }
        jQuery('.second-contexts').addClass('deactive');
    };
    $scope.generateVcard = function( callback ){
        var strVcard = '';
        function getFieldValue( fieldKey ){
            var value = '';
            _.each($scope.settings.vcard_fields, function(field, index){
                if( field.key == fieldKey ) value =  field.value;
            });
            return value;
        }
        strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
        strVcard += 'N:' + getFieldValue( 'last_name' ) + ';' + getFieldValue( 'first_name' ) + '\n' + 'FN:' + getFieldValue( 'first_name' ) + ' ' + getFieldValue( 'last_name' );
        strVcard += '\nADR;TYPE=home:;;'+ getFieldValue( 'address' ) + ';' + getFieldValue( 'city' ) + ';;' + getFieldValue( 'postcode' ) + ';' + getFieldValue( 'country' );
        strVcard += '\nTEL;TYPE=home:' + getFieldValue( 'phone' );
        strVcard += '\nTEL;TYPE=work:' + getFieldValue( 'mobile' );
        strVcard += '\nEMAIL;TYPE=internet,work:' + getFieldValue( 'email' );
        strVcard += '\nURL;TYPE=work:' + getFieldValue( 'website' );
        strVcard += '\nEND:VCARD';
        var qr = qrcode('0', 'M', NBDESIGNCONFIG.nbdesigner_default_color);
        qr.addData( strVcard );
        qr.make();
        var _qrcode = qr.createSvgTag();
        fabric.loadSVGFromString(_qrcode, function(ob, op) {
            var object = fabric.util.groupSVGElements(ob, op);
            if( typeof callback == 'function' ){
                callback( object );
            }else{
                var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                max_width = _canvas.width / scale * .9,
                max_height = _canvas.height / scale * .9,
                new_width = max_width;
                if (op.width < max_width) new_width = op.width;
                var width_ratio = new_width / op.width,
                new_height = op.height * width_ratio;
                if (new_height > max_height) {
                    new_height = max_height;
                    var height_ratio = new_height / op.height;
                    new_width = op.width * height_ratio;
                }
                object.scaleToWidth(new_width);
                object.scaleToHeight(new_height);
                object.v_card = 1;
                _canvas.add(object);
            }
        });
    };
    $scope.updateTemplate = function(){
        $scope.clearAllStage();
        $scope.insertTemplate(false, {id: $scope.currentLocalTempId});
    };
    $scope.tourGuide = {
        firstTime: true,
        currentStep: -1,
        steps: []
    };
    $scope.tourGuideShowing = false;
    $scope.startTourGuide = function(){
        if( $scope.settings.is_mobile ){
            return;
        }
        if( $scope.tourGuide.currentStep == -1 ){
            var steps = [];
            jQuery.each(jQuery('[data-tour]'), function(){
                var el = jQuery(this),
                dataTour = el.attr('data-tour'),
                priority = el.attr('data-tour-priority');
                steps.push({
                    priority: priority,
                    template: 'tour_guide.' + dataTour,
                    element: el
                });
            });
            $scope.tourGuide.steps = _.sortBy(steps, [function(s) { return s.priority; }]);
        };
        $scope.tourGuideShowing = true;
        localStorage.setItem('showTourGuide', 1);
        $scope.tourGuide.currentStep = -1;
        $timeout(function(){
            $scope.nextTour();
        },  300);
    };
    $scope.processTourComponents = function( close ){
        var targetEl = $scope.tourGuide.steps[$scope.tourGuide.currentStep].element;
        if( close ){
            jQuery('.tour-guide').removeClass('active');
            $scope.tourGuideShowing = false;
            $scope.showTemplateFieldsPopup();
            return;
        };
        var tourStepEl = jQuery('.nbd-tourStep'),
            bgTourTop = jQuery('.bgTour-top'),
            bgTourRight = jQuery('.bgTour-right'),
            bgTourBottom = jQuery('.bgTour-bottom'),
            bgTourLeft = jQuery('.bgTour-left'),
            height = targetEl.outerHeight(),
            width = targetEl.outerWidth();
        if($scope.tourGuide.firstTime){
            width = 75;
            $scope.tourGuide.firstTime = false;
        }
        var offset = targetEl.offset(),
            top = offset.top,
            left = offset.left,
            bottom = jQuery(window).outerHeight() - height - top,
            right = jQuery(window).outerWidth() - left - width;
        bgTourTop.css({
            height: top + 'px'
        });
        bgTourBottom.css({
            height: bottom + 'px'
        });
        bgTourRight.css({
            top: top + 'px',
            left: left + width + 'px',
            height: height + 'px'
        });
        bgTourLeft.css({
            top: top + 'px',
            width: left + 'px',
            height: height + 'px'
        });
        if (jQuery(window).width() > (left * 2)) {
            tourStepEl.attr('data-pos', 'left');
            tourStepEl.css({
                top: top + 'px',
                left: left + width + 7 + 'px'
            });
        }else{
            tourStepEl.attr('data-pos', 'right');
            tourStepEl.css({
                top: top + 'px',
                left: left - 7 + 'px'
            });
        }
        jQuery('.tour-guide').addClass('active');
    };
    $scope.nextTour = function(){
        if( $scope.tourGuide.currentStep < ($scope.tourGuide.steps.length - 1) ){
            $scope.tourGuide.currentStep++;
            $scope.processTourComponents();
        }
    };
    $scope.prevTour = function(){
        if( $scope.tourGuide.currentStep > 0 ){
            $scope.tourGuide.currentStep--;
            $scope.processTourComponents();
        }
    };
    $scope.updateMapUrl = function(){
        if( $scope.resource.maps.address != '' ){
            var address = $scope.resource.maps.address.replace(/\s/g,'+'),
            width = parseInt( $scope.resource.maps.width ),
            height = parseInt( $scope.resource.maps.height );
            width = width > 640 ? 640 : width;
            height = height > 640 ? 640 : height;

            $scope.resource.maps.loading = true;
            $scope.resource.maps.url  = 'https://maps.googleapis.com/maps/api/staticmap?center=';
            $scope.resource.maps.url += address +'&zoom='+ $scope.resource.maps.zoom +'&scale=2&size='+ width +'x'+ height;
            $scope.resource.maps.url += '&maptype='+ $scope.resource.maps.maptype +'&format=jpg&markers=size:'+ $scope.resource.maps.markers.size;
            $scope.resource.maps.url += '|color:0x'+ $scope.resource.maps.markers.color.replace('#','') +'|label:'+ $scope.resource.maps.markers.label +'|'+ address +'&key='+ $scope.settings.nbdesigner_static_map_api_key +'&.jpg';
        
            var img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = function(){
                $scope.resource.maps.loading = false;
                jQuery("#tab-element .tab-scroll").animate({ scrollTop: jQuery("#tab-element .tab-scroll").height() }, 300);
            }
            img.src = $scope.resource.maps.url;
            img.onerror = function(){
                $scope.resource.maps.url = '';
                $scope.resource.maps.loading = false;
            }
        }
    };

    /* NBDesigner Advanced */
    $scope.uploadBackgroundImage = function(files,indexFile){
        indexFile = angular.isDefined(indexFile) ? indexFile : 0;
        var file = files[indexFile],
            max_size = parseInt($scope.settings.nbdesigner_maxsize_upload),     
            min_size = parseInt($scope.settings.nbdesigner_minsize_upload);
        if( ( file.type.indexOf("image") === -1 && file.type.indexOf("pdf") === -1 ) || ( file.type.indexOf("pdf") != -1 && !$scope.settings.is_available_imagick ) ){
            alert( $scope.settings.is_available_imagick ? $scope.settings.nbdlangs.supported_extensions2 : $scope.settings.nbdlangs.supported_extensions );
            return;
        }
        if ( file.size > max_size * 1024 * 1024 ) {
            alert( $scope.settings.nbdlangs.max_file_size + max_size + " MB" );
            return;
        }else if( file.size < min_size * 1024 * 1024 ){
            alert( $scope.settings.nbdlangs.min_file_size + min_size + " MB" );
            return;
        };
        NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function(data){
        var data = JSON.parse(data);
        if( data.flag == 1 ){
            if( angular.isDefined(data.ilr) ) $scope.resource.upload.ilr = true;
            if( $scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no' ){
                $scope.toggleStageLoading();
                alert(data.mes);
                return;
            };
            $scope.addBackgrounds(data.src,true,true);
        }else{
            $scope.toggleStageLoading();
            alert(data.mes);
        }
    }, function( progress ){
        $scope.resource.upload.progressBar = progress.toFixed(0);
    });
    }
    $scope.getBackgroundLayer = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        var bgItemObj = false;
        _canvas.forEachObject(function(obj) {
            if (obj.type === "rect" && obj.isBg != undefined ) {
                bgItemObj =  obj;
            }
        });
        return bgItemObj;
    };
    $scope.colorBackground = '#fff';
    $scope.addBackground = function( color ){
        var _stage = this.stages[this.currentStage];
        if (angular.isUndefined(_stage)){
            return;
        }
        var _canvas = _stage.canvas,
            obj = _canvas.getActiveObject();
        _canvas.setBackgroundImage(null);
        _canvas.setBackgroundColor(color, _canvas.renderAll.bind(_canvas));
    };
    $scope.changeBackgroundColor = function( color ){
        $scope.addBackground(color);
    };
    $scope.addImageBackground = function(url, showLoading, hideLoading){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage['canvas'],
            scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
        if( showLoading ) $scope.toggleStageLoading();
        fabric.Image.fromURL(url, function(op) {
                var _ratio = 1;
                var max_width = _canvas.width / scale * _ratio,
                    max_height = _canvas.height / scale * _ratio,
                    new_width = max_width;
                if (op.width < max_width) new_width = op.width;
                var width_ratio = new_width / op.width,
                new_height = op.height * width_ratio;
                if (new_height < max_height) {
                    new_height = max_height;
                    var height_ratio = new_height / op.height;
                    new_width = op.width * height_ratio;
                };    
                op.set({
                    scaleX: new_width / op.width,
                    scaleY: new_height / op.height,
                    originX: 'left', originY: 'top'
                })
                _canvas.setBackgroundImage(op,_canvas.renderAll.bind(_canvas));
                $scope.fitToStage(undefined,op);
            if( hideLoading ) $scope.toggleStageLoading();           
        });
    };
    
    $scope.removeBgRera = function() {
        jQuery('.current_background').attr("src",'');
        var _stage = this.stages[this.currentStage];
        var _canvas = _stage.canvas;
        _canvas.setBackgroundImage(null);
        _canvas.renderAll();
    }
    
    $scope.addBackgrounds = function(background, showLoading, hideLoading){
        var url = typeof background == 'object' ? background.url : background;
        if(url.match(/\.(jpeg|jpg|gif|png)$/) != null){
            $scope.addImageBackground(url);
        }else{
            fabric.loadSVGFromURL(url, function(ob, op) {
                if(ob){ 
                    $scope._addSvg(ob, op, art, hideLoading);
                }else{
                    alert('Try again!');
                    $scope.toggleStageLoading();
                }
            });
        }
    }; 

    $scope.threeDimensionPreview = {
        existedFrame: false,
        modelLoaded: false,
        size: 'minimize',
    };
    $scope.resize3DPreview = function(type){
        if( type == 'minimize' ){
            jQuery('#preview-3d-wrapper').removeAttr('style');
        }else{
            jQuery('#preview-3d-wrapper').css({
                width: window.innerWidth + 'px',
                height: window.innerHeight - 40 + 'px',
                left: 0,
                top: '40px'
            });
        }
        $scope.threeDimensionPreview.size = type;
    };
    $scope.show3DPreview = function(){
        var dragHandleEl = jQuery('#preview-3d-drag-handle'),
        resizeHandleEl = jQuery('#preview-3d-resize-handle'),
        wrapperEl = jQuery('#preview-3d-wrapper'),
        startX, startY, currentWidth, currentHeight, startLeft, startTop, startWidth, startHeight, currentLeft, currentTop,
        windowWidth = window.innerWidth,
        windowHeight = window.innerHeight;

        function startDrag(e){
            var left = startLeft + e.clientX - startX,
            top = startTop + e.clientY - startY;
            left = left < 0 ? 0 : left;
            if( ( left + currentWidth ) > windowWidth ){
                left = windowWidth - currentWidth;
            }
            top = top < 40 ? 40 : top;
            if( ( top + currentHeight ) > windowHeight ){
                top = windowHeight - currentHeight;
            }
            wrapperEl.css({
                top: top + 'px',
                left: left + 'px'
            });
        }
        function stopDrag(e){
            jQuery(document).off('mousemove', startDrag);
            jQuery(document).off('mouseup', stopDrag);
        }
        function initDraggable(){
            dragHandleEl.on('mousedown', function(e){
                startX = e.clientX;
                startY = e.clientY;
                startLeft = wrapperEl.offset().left;
                startTop = wrapperEl.offset().top;
                currentWidth = wrapperEl.width();
                currentHeight = wrapperEl.height();
                jQuery(document).on('mousemove', startDrag);
                jQuery(document).on('mouseup', stopDrag);
            });
        }

        function startResize(e){
            var width = startWidth + e.clientX - startX,
            height = startHeight + e.clientY - startY;
            width = width < 400 ? 400 : width;
            if( ( width + currentLeft ) > windowWidth ){
                width = windowWidth - currentLeft;
            }
            height = height < 300 ? 300 : height;
            if( ( height + currentTop ) > windowHeight ){
                height = windowHeight - currentTop;
            }
            wrapperEl.css({
                width: width + 'px',
                height: height + 'px'
            });
        }
        function stopResize(e){
            jQuery(document).off('mousemove', startResize);
            jQuery(document).off('mouseup', stopResize);
            jQuery('.preview-3d-resize-overlay').removeClass('active');
        }
        function initResizeable(){
            resizeHandleEl.on('mousedown', function(e){
                startX = e.clientX;
                startY = e.clientY;
                currentLeft = wrapperEl.offset().left;
                currentTop = wrapperEl.offset().top;
                startWidth = wrapperEl.width();
                startHeight = wrapperEl.height();
                jQuery('.preview-3d-resize-overlay').addClass('active');
                jQuery(document).on('mousemove', startResize);
                jQuery(document).on('mouseup', stopResize);
            });
        }
        function _show3DPreview(){
            if( !$scope.threeDimensionPreview.existedFrame ){
                var iframe_src = NBDESIGNCONFIG.home_url + '?nbd-route=nbd-3d-preview&product_id=' + NBDESIGNCONFIG.product_id;
                jQuery('.preview-3d-wrap-inner').prepend('<iframe id="preview-3d-wrap"  width="100%" height="100%" scrolling="no" frameborder="0" noresize="noresize" allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" src="'+iframe_src+'"></iframe>');
                $scope.threeDimensionPreview.existedFrame = true;
                initDraggable();
                initResizeable();
            }
            jQuery('.preview-3d-wrap').addClass('active');
            if( $scope.threeDimensionPreview.modelLoaded ){
                $scope.update3DPreviewTexture();
            }
        }
        $scope.saveDesign();
        if( $scope.checkSaveStatus() ){
            _show3DPreview();
        }else{
            var interval = $interval(function(){
                if( $scope.checkSaveStatus() ){
                    $interval.cancel( interval );
                    _show3DPreview();
                }
            }, 100);
        }
    };
    $scope.close3DPreview = function(){
        jQuery('.preview-3d-wrap').removeClass('active');
    };
    $scope.update3DPreviewTexture = function(){
        var frame = document.getElementById('preview-3d-wrap');
        frame.contentWindow.postMessage(['update_design', $scope.stages[0].design]);
    };
    $scope.stickerCutline = {
        pathCmd: '',
        svg: '',
        patternSvg: '',
        active: false
    };
    $scope.generateStickerCutline = function( onSaveDesign ){
        if( !onSaveDesign ) $scope.toggleStageLoading();
        $scope.stickerCutline.active = false;
        var _stage = $scope.stages[0],
        _canvas = _stage.canvas,
        width = Math.floor( _canvas.width ),
        height = Math.floor( _canvas.height ),
        bleedTB = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio * _stage.config.bleed_tb,
        bleedLR = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio * _stage.config.bleed_lr,
        margin = Math.ceil( Math.max( bleedTB, bleedLR ) );
        margin = margin > 1 ? margin : 1;
        var options = {
            color: 'none',
            outline: '#FF0000',
            margin: margin
        };
        _canvas.discardActiveObject().calcOffset().renderAll();

        function _showStickerPreview(){
            $timeout(function(){
                var ctx = _canvas.getContext( '2d' );
                imgdataObj = ctx.getImageData(margin, margin, width - 2 * margin, height - 2 * margin);
            
                Potrace.clear();
                Potrace.setParameter( options );
                Potrace.loadData( imgdataObj, width, height );
                Potrace.process(function(){
                    var svg = Potrace.getSVG(1, "curve", true);
                    $scope.stickerCutline.pathCmd = svg.pathcmd;
                    buildCutlineSvg();
                    if( !onSaveDesign ) $scope.toggleStageLoading();
                });
            }, 100);
        }

        function buildCutlineSvg(){
            $scope.stickerCutline.svg  = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg">';
            $scope.stickerCutline.svg +=    '<path d="';
            $scope.stickerCutline.svg +=        $scope.stickerCutline.pathCmd;
            $scope.stickerCutline.svg +=    '" stroke="' + options.outline + '" stroke-width="' + ( onSaveDesign ? 0.1 : 1 ) + '" fill="' + options.color + '" />';
            $scope.stickerCutline.svg += '</svg>';

            jQuery('.sticker-contour-wrap').html('').append( $scope.stickerCutline.svg );

            if( angular.isDefined( $scope.settings.product_data.product[0].pattern ) ){
                var pattern = $scope.settings.product_data.product[0].pattern;

                $scope.stickerCutline.patternSvg  = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg">';
                $scope.stickerCutline.patternSvg +=    '<defs>';
                if( pattern.type == 'image' ){
                    var patternWidth = 100, patternHeight = 100;
                    $scope.stickerCutline.patternSvg +=     '<pattern id="sticker_material_pattern" x="0" y="0" width="' + patternWidth / width + '" height="' + patternHeight / width + '" ><image x="0px" y="0px" width="' + patternWidth + '" height="' + patternHeight + '" xlink:href="' + pattern.src + '"></image></pattern>';
                }
                $scope.stickerCutline.patternSvg +=    '</defs>';
                $scope.stickerCutline.patternSvg +=    '<path d="';
                $scope.stickerCutline.patternSvg +=        $scope.stickerCutline.pathCmd;
                if( pattern.type == 'color' ){
                    $scope.stickerCutline.patternSvg +=    '" stroke-width="0" fill="' + options.color + '" />';
                }else{
                    $scope.stickerCutline.patternSvg +=    '" stroke-width="0" fill="url(#sticker_material_pattern)" />';
                }
                $scope.stickerCutline.patternSvg += '</svg>';

                jQuery('.sticker-contour-pattern-wrap').html('').append( $scope.stickerCutline.patternSvg );
            }

            $scope.stickerCutline.active = true;
        }

        $timeout(function(){
            _showStickerPreview();
        }, 100);
    };
    jQuery(document).ready(function () {
        $scope.init();
        if( NBDESIGNCONFIG['ui_mode'] != 3){
            jQuery(document).triggerHandler( 'nbd_modern_app_init' );
        }
    });
}]);
function buildSvgFilter( jOptions, _in ){
    var options = JSON.parse( jOptions ),
    filter = '';
    _in = angular.isDefined( _in ) ? _in : 'SourceGraphic';
    switch( options.type ){
        case 'blur':
            var value = angular.isDefined( options.value ) ? options.value : 5;
            filter += '<feGaussianBlur stdDeviation="' + value + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'desaturate':
            filter += '<feColorMatrix type="saturate" in="' + _in + '" values="0" result="' + options.type + '"/>';
            break;
        case 'contrast':
            var slope = angular.isDefined( options.slope ) ? options.slope : 5;
            var intercept = -(0.3 * slope) + 0.3;
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter +=       '<feFuncG type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter +=       '<feFuncB type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter += '</feComponentTransfer>';
            break;
        case 'sepiatone':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values=".343 .669 .119 0 0 .249 .626 .130 0 0 .172 .334 .111 0 0 .000 .000 .000 1 0" result="' + options.type + '"/>';
            break;
        case 'hue':
            var rotate = angular.isDefined( options.value ) ? options.value : 180;
            filter += '<feColorMatrix type="hueRotate" values="' + rotate + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'luminance':
            filter += '<feColorMatrix type="luminanceToAlpha" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'colorize':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values="1.0 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1.0 0" result="' + options.type + '"/>';
            break;
        case 'posterize':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter +=       '<feFuncG type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter +=       '<feFuncB type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter += '</feComponentTransfer>';
            break;
        case 'darken':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="0.2" />';
            filter +=       '<feFuncG type="linear" slope="0.2" />';
            filter +=       '<feFuncB type="linear" slope="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'lighten':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="linear" slope="1.5" intercept="0.2" />';
            filter +=       '<feFuncG type="linear" slope="1.5" intercept="0.2" />';
            filter +=       '<feFuncB type="linear" slope="1.5" intercept="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'invert':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="table" tableValues="1 0" />';
            filter +=       '<feFuncG type="table" tableValues="1 0" />';
            filter +=       '<feFuncB type="table" tableValues="1 0" />';
            filter += '</feComponentTransfer>';
            break;
        case 'gamma1':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter +=       '<feFuncR type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter +=       '<feFuncG type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter +=       '<feFuncB type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter += '</feComponentTransfer>';
            break;
    }
    return filter;
};
nbdApp.factory('FabricWindow', ['$window', function($window) {
    /* Fabric configuration */
    fabric.disableStyleCopyPaste = false;
    fabric.Object.NUM_FRACTION_DIGITS = 10;
    $window.fabric.Object.prototype.set({ 
        transparentCorners: false,
        borderColor: 'rgba(79, 84, 103,0.7)',
        cornerStyle: 'circle',
        cornerColor: 'rgba(255,255,255,1)',
        borderDashArray:[2,2],
        cornerStrokeColor: 'rgba(63, 70, 82,1)',
        fill : NBDESIGNCONFIG.nbdesigner_default_color, 
        hoverCursor: 'pointer',
        borderOpacityWhenMoving: 0
    });
    if( NBDESIGNCONFIG.nbdesigner_object_center_scaling == 'yes' ){
        $window.fabric.Object.prototype.set({centeredScaling: true });
    };
    if( checkMobileDevice() ) $window.fabric.Object.prototype.set({cornerSize: 17});
    $window.fabric.IText.prototype.set({
        cursorWidth: 1,
        cursorColor: '#000',
        selectionColor: "rgba(1, 196, 204, 0.3)",
        cursorDuration: 500,
        strokeWidth: 0
    });
    if( NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no' ){
        $window.fabric.IText.prototype.set({
            _controlsVisibility: {
                tl: true,
                tr: true,
                br: true,
                bl: true,
                ml: false,
                mt: false,
                mr: false,
                mb: false,
                mtr: NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false
            }
        });
    }
    $window.fabric.Canvas.prototype.set({
        preserveObjectStacking : true,
        controlsAboveOverlay: true,
        selectionColor: 'rgba(1, 196, 204, 0.3)',
        selectionBorderColor: '#01c4cc',
        selectionLineWidth: 0.5,
        centeredKey: "shiftKey",
        uniScaleKey: "altKey"
    });  
    $window.fabric.Textbox.prototype.set({
        _controlsVisibility: {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: false,
            mr: true,
            mb: false,
            mtr: NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false
        },
        paintFirst: NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ? "stroke" : "fill",
        /* strokeLineJoin: 'round' */
    });
    $window.fabric.Image.prototype.set({
        originX: 'center',
        originY: 'center'
    });
    $window.fabric.CurvedText.prototype.set({
        originX: 'center',
        originY: 'top'
    }); 
    fabric.enableGLFiltering = false;
    fabric.PathGroup = { };
    fabric.PathGroup.fromObject = function (object, callback) {
        var originalPaths = object.paths;
        delete object.paths;
        if (typeof originalPaths === 'string') {
            fabric.loadSVGFromURL(originalPaths, function (elements) {
                var pathUrl = originalPaths;
                var group = fabric.util.groupSVGElements(elements, object, pathUrl);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        } else {
            fabric.util.enlivenObjects(originalPaths, function (enlivenedObjects) {
                enlivenedObjects.forEach(function (obj) {
                    obj._removeTransformMatrix();
                });
                var group = new fabric.Group(enlivenedObjects, object);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        }
    };
    fabric.Image.prototype._toSVG = function() {
        var svgString = [], imageMarkup = [], strokeSvg,
            x = -this.width / 2, y = -this.height / 2, clipPath = '', imageFilter = '';
        if (this.hasCrop()) {
            var clipPathId = fabric.Object.__uid++;
            svgString.push(
            '<clipPath id="imageCrop_' + clipPathId + '">\n',
            '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
            '</clipPath>\n'
            );
            clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
        }
        if( this.filters.length ){
            var width = this._element.width || this._element.naturalWidth,
            height = this._element.height || this._element.height;
            if( !!this.origin_url && !angular.isDefined( this.cropped ) ){
                width = this.origin_width;
                height = this.origin_height;
            }
            var filters = this.filters,
            d = new Date(),
            randomId = d.getTime() + Math.floor(Math.random() * 1000),
            filterId = 'filter_' + randomId,
            filterCode = '<filter id="' + filterId + '" x="' + ( x - this.cropX ) + '" y="' + ( y - this.cropY ) + '" width="' + width + '" height="' + height + '" filterUnits="userSpaceOnUse">';
            filters.forEach(function(filter, index) {
                var _in;
                if( index > 0 ){
                    var options = JSON.parse( filters[index - 1].jOptions );
                    _in  = options.type;
                }
                filterCode += buildSvgFilter( filter.jOptions, _in );
            });
            filterCode += '</filter>';
            imageMarkup.push( filterCode );
            imageFilter = ' filter="url(#' + filterId + ')"';
        }
        if( !!this.origin_url && !angular.isDefined( this.cropped ) ){
            imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.origin_url,
            '" x="', x - this.cropX, '" y="', y - this.cropY,
            '" width="', this.origin_width,
            '" height="', this.origin_height,
            '"', clipPath, imageFilter,
            '></image>\n');
        }else{
            imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(false),
            '" x="', x - this.cropX, '" y="', y - this.cropY,
            '" width="', this._element.width || this._element.naturalWidth,
            '" height="', this._element.height || this._element.height,
            '"', clipPath, imageFilter,
            '></image>\n');
        }
        if (this.stroke || this.strokeDashArray) {
            var origFill = this.fill;
            this.fill = null;
            strokeSvg = [
            '\t<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
            '"/>\n'
            ];
            this.fill = origFill;
        }
        if (this.paintFirst !== 'fill') {
            svgString = svgString.concat(strokeSvg, imageMarkup);
        }
        else {
            svgString = svgString.concat(imageMarkup, strokeSvg);
        }
        return svgString;
    };

    fabric.Image.prototype.applyFilters =  function(filters, callback, reset) {
        filters = filters || this.filters || [];
        filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
        this.set('dirty', true);
  
        this.removeTexture(this.cacheKey + '_filtered');
  
        if (filters.length === 0) {
          this._element = this._originalElement;
          this._filteredEl = null;
          this._filterScalingX = 1;
          this._filterScalingY = 1;
          if( typeof callback == 'function' ) callback();
          return this;
        }

        if( reset ){
            this._element = this._originalElement;
            this._filteredEl = null;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
          var canvasEl = fabric.util.createCanvasElement();
          canvasEl.width = sourceWidth;
          canvasEl.height = sourceHeight;
          this._element = canvasEl;
          this._filteredEl = canvasEl;
        }
        else {
          this._element = this._filteredEl;
          this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
          this._lastScaleX = 1;
          this._lastScaleY = 1;
        }
        if (!fabric.filterBackend) {
          fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
          filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey, callback);
        if (this._originalElement.width !== this._element.width ||
          this._originalElement.height !== this._element.height) {
          this._filterScalingX = this._element.width / this._originalElement.width;
          this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
    };
    fabric.Canvas2dFilterBackend.prototype.applyFilters = async function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas, cacheKey, callback){
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
          sourceWidth: sourceWidth,
          sourceHeight: sourceHeight,
          imageData: imageData,
          originalEl: sourceElement,
          originalImageData: originalImageData,
          canvasEl: targetCanvas,
          ctx: ctx,
          filterBackend: this,
        };
        for (const filter of filters) {
            await filter.applyTo2d(pipelineState);
            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
                targetCanvas.width = pipelineState.imageData.width;
                targetCanvas.height = pipelineState.imageData.height;
            }
            ctx.putImageData(pipelineState.imageData, 0, 0);
        }
        if( typeof callback == 'function' ) callback();
        return pipelineState;
    };
    var canvas2dBackend = new fabric.Canvas2dFilterBackend();
    fabric.filterBackend = canvas2dBackend;
    var filters = fabric.Image.filters,
    createClass = fabric.util.createClass;
    filters.CustomFilter = createClass(filters.BaseFilter, {
        type: 'CustomFilter',
        initialize: function(options) {
            this.callSuper('initialize', options);
        },
        jOptions: '',
        mainParameter: 'jOptions',
        applyTo2d: function(options) {
            var imageData = options.imageData,
                width = imageData.width, 
                height = imageData.height,
                originUrl = options.canvasEl.toDataURL(),
                jOptions = this.jOptions;
            var d = new Date(),
            randomId = d.getTime() + Math.floor(Math.random() * 1000);
            return new Promise( function( resolve, reject ) {
                function buildSvg(){
                    var id = 'filter_' + randomId,
                    svg      = '';

                    svg     += '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
                    svg     +=      '<defs>';
                    svg     +=          '<filter id="' + id + '" x="0" y="0" width="100%" height="100%">';
                    svg     +=              buildSvgFilter( jOptions );
                    svg     +=          '</filter>';
                    svg     +=      '</defs>';
                    svg     +=      '<image xlink:href="' + originUrl + '" x="0" y="0" width="100%" height="100%" filter="url(#' + id + ')"></image>';
                    svg     += '</svg>';

                    return svg;
                }

                var filterdSvg = buildSvg(),
                img = new Image();
                url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent( filterdSvg );
                
                img.onload = function() {
                    var kanvas = document.createElement("canvas");
                    kanvas.width = width;
                    kanvas.height = height,
                    context = kanvas.getContext('2d');
                    context.drawImage(img, 0, 0, width, height, 0, 0, width, height);

                    options.imageData = context.getImageData(0, 0, width, height);
                    return resolve({status: jOptions});
                }
                img.src = url;
            });
        }
    });
    fabric.Image.filters.CustomFilter.fromObject = fabric.Image.filters.BaseFilter.fromObject;

    if ( NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes' ) {
        fabric.Text.prototype._createTextCharSpan = function (_char, styleDecl, left, top) {
            var toFixed = fabric.util.toFixed,
                multipleSpacesRegex = /  +/g;
            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
                styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
                fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
                dy = styleDecl.deltaY, dySpan = '',
                NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
            if (dy) {
                dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
            }

            var fontName = this.fontFamily,
                fontWeight = this.fontWeight,
                fontStyle = this.fontStyle;

            if (fontWeight == 'bold') {
                if (fontStyle == 'italic') {
                    fontName += '__bi';
                } else {
                    fontName += '__b';
                }
            } else {
                if (fontStyle == 'italic') {
                    fontName += '__i';
                }
            }
            if( $window.outlineFonts[fontName] ){
                var path = $window.outlineFonts[fontName].getPath(fabric.util.string.escapeXml(_char), toFixed(left, NUM_FRACTION_DIGITS), toFixed(top, NUM_FRACTION_DIGITS), this.fontSize)
                    pathMarkup = path.toSVG(NUM_FRACTION_DIGITS);

                return pathMarkup;
            }else{
                return [
                    '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
                    toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
                    fillStyles, '>',
                    fabric.util.string.escapeXml(_char),
                    '</tspan>'
                ].join('');
            }
        };
        fabric.Text.prototype._wrapSVGTextAndBg = function (textAndBg) {
            var noShadow = true;
            if( _.isEmpty( $window.outlineFonts ) ){
                var textDecoration = this.getSvgTextDecoration(this);
                return [
                  textAndBg.textBgRects.join(''),
                  '\t\t<text xml:space="preserve" ',
                  (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
                  (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
                  (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
                  (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
                  (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
                  'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                  textAndBg.textSpans.join(''),
                  '</text>\n'
                ];
            }else{
                return [
                    textAndBg.textBgRects.join(''),
                    '\t\t<g ',
                    'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                    textAndBg.textSpans.join(''),
                    '</g>\n'
                ];
            }
        };
    }

    return $window.fabric;
}]);
nbdApp.directive('nbdCanvas', ['FabricWindow', '$timeout', '$rootScope', function(FabricWindow, $timeout, $rootScope){
    return {
        restrict: "AE",
        scope: {
            stage: '=stage',
            index: '@',
            last: '@'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                scope.stage.canvas = new FabricWindow.Canvas('nbd-stage-'+scope.index);
                scope.$emit('canvas:created', scope.index, scope.last);
                element.parent().children().on("contextmenu", function(e){
                    e.preventDefault();
                    scope.$emit('nbd:contextmenu', e);
                });
            });  
        }
    }
}]);
nbdApp.directive('keypress', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keydown", function(e){
                scope.$emit('nbd:keypress', e);
            }, false);
        }
    }
}]);
nbdApp.directive('nbdScroll', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            container: '@',
            type: '@',
            offset: '@',
            currentType: '@',
            action: '&nbdScroll'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                var el = scope.type != 'font' ? jQuery(scope.container + ' .tab-scroll') : jQuery(scope.container),
                    offset = parseInt(scope.offset),
                    elInfo = jQuery(scope.container + ' .info-support');
                el.on('ps-scroll-y', function(){
                    if( scope.type == 'globalTemplate' && angular.isDefined( scope.currentType ) && scope.currentType != 'global' ) return;
                    if(el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0) ){
                        scope.action({container: scope.container, type: scope.type});
                    };
                    if( elInfo.length ){
                        el.prop("scrollTop") > 1500 && elInfo.addClass('slideInDown animated show') || elInfo.removeClass('slideInDown animated show');
                    }
                });
            });
        }
    }
}]);
nbdApp.directive('nbdScrollTemplateTab', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            action: '&nbdScrollTemplateTab'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                var offset = 30;
                var el = jQuery('#tab-product-template .tab-scroll');
                el.on('ps-scroll-y', function(){
                    if(el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0) ){
                        scope.action();
                    };
                });
            });
        }
    }
}]);
nbdApp.directive('nbdLayer', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            action: '&nbdLayer'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                jQuery(element).sortable({
                    placeholder: "sortable-placeholder",
                    containment: '#tab-layer',
                    stop: function(event, ui) {
                        var srcIndex = jQuery(this).attr('data-prev-index'),
                            oldIndex = jQuery(this).attr('data-previndex'),
                            newIndex = ui.item.index(),
                            dstIndex = 0;
                        if( oldIndex > newIndex ){
                            dstIndex = jQuery(ui.item).next().attr('data-index')
                        }else {
                            dstIndex = jQuery(ui.item).prev().attr('data-index')
                        };
                        jQuery(this).removeAttr('data-previndex');
                        jQuery(this).removeAttr('data-prev-index');
                        scope.action({srcIndex: srcIndex, dstIndex: dstIndex});
                    },
                    start: function(e, ui) {
                        jQuery(this).attr('data-prev-index', jQuery(ui.item).attr('data-index'));
                        jQuery(this).attr('data-previndex', ui.item.index());
                    },
                });
            });
        }
    };
}]);
nbdApp.directive('endRepeatColorPicker', ['$timeout', function($timeout){
    return {
        restrict: "A",
        link: function( scope, element, attrs ) {
            $timeout(function() {
                jQuery(element).nbdColorPalette();
            });
        }
    }    
}]);
nbdApp.directive('repeatEnd', [ function(){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {  
            if(scope.$last) {
                scope.$eval(attrs.repeatEnd);
            }
        }
    }
}]);
nbdApp.directive('keyup', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keyup", function(e){
                scope.$emit('nbd:keyup', e);
            }, false);
        }
    }
}]);
nbdApp.filter('keyboardShortcut', function($window) {
    return function(str) {
        if (!str)
            return;
        var keys = str.split('-');
        var isOSX = /Mac OS X/.test($window.navigator.userAgent);
        var seperator = (!isOSX || keys.length > 2) ? '+' : '';
        var abbreviations = {
            M: isOSX ? '' : 'Ctrl',
            A: isOSX ? 'Option' : 'Alt',
            S: 'Shift'
        };
        return keys.map(function (key, index) {
            var last = index == keys.length - 1;
            return last ? key : abbreviations[key];
        }).join(seperator);
    };
});
nbdApp.filter("filterFont", function() {
    return function(fonts, filterFont) {
        var arrFont = [];
        angular.forEach(fonts, function(font, key) {
            var check = [];
            check['limit'] = arrFont.length > ( filterFont.perPage * filterFont.currentPage  - 1 ) ? false : true;
            if( !!filterFont.search ){
                check['name'] = font.name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false;
                if( angular.isDefined( font.display_name ) && font.display_name != '' ){
                    check['name'] = check['name'] || (font.display_name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false);
                }
            }else{
                check['name'] = true;
            };
            if( check['limit'] && check['name'] )arrFont.push(font);
        });
        arrFont = _.sortBy(arrFont, [function(o) { return o.name; }]);
        return arrFont
    }
});
nbdApp.filter("filterArt", function() {
    return function(arts, filterArt) {
        var arrArt = [];
        arts = _.sortBy(arts, [function(o) { return o.name; }]);
        angular.forEach(arts, function(art, key) {
            var check = [];
            check['limit'] = arrArt.length > ( filterArt.perPage * filterArt.currentPage  - 1 ) ? false : true;
            if( !!filterArt.search ){
               check['name'] = art.name.toLowerCase().indexOf(filterArt.search.toLowerCase()) >= 0 ? true : false;
            }else{
                check['name'] = true;
            };
            if( !!filterArt.currentCat.id || filterArt.currentCat.id === 0 ){
                check['cat'] = ( _.includes(art.cat, filterArt.currentCat.id) || _.includes(art.cat, "" + filterArt.currentCat.id) ) ? true : false;
            }else{
                check['cat'] = true;
            }
            if( check['limit'] && check['name'] && check['cat'] ) arrArt.push(art);
        });
        return arrArt
    }
});

/*NBDesigner Advanced*/
nbdApp.directive("nbdUploadBg", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadBackgroundImage: '&nbdUploadBg'
        },
        link: function(scope, element) {  
            $timeout(function() {
                var dropArea = jQuery(element),
                Input = dropArea.find('input[type="file"]');
                _.each(['dragenter', 'dragover'], function(eventName, key) {
                    dropArea.on(eventName, highlight)
                });
                _.each(['dragleave', 'drop'], function(eventName, key) {
                    dropArea.on(eventName, unhighlight)
                });
                function highlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.addClass('highlight');
                };
                function unhighlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.removeClass('highlight');
                };
                dropArea.on('drop', handleDrop);
                function handleDrop(e) {
                    if( jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked') ) {
                        alert(NBDESIGNCONFIG.nbdlangs.alert_upload_term);
                        return;
                    }else{
                        if(e.originalEvent.dataTransfer){
                            if(e.originalEvent.dataTransfer.files.length) {
                                e.preventDefault();
                                e.stopPropagation();
                                handleFiles(e.originalEvent.dataTransfer.files);
                            }
                        }
                    }
                };
                Input.on('change', function(){
                    handleFiles(this.files);
                });
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadBackgroundImage({files: files});
                }
            });
        }
    }
}]);
nbdApp.filter("filterBackground", function() {
    return function(backgrounds, filterBackground) {
        var arrBackground = [];
        backgrounds = _.sortBy(backgrounds, [function(o) { return o.name; }]);
        angular.forEach(backgrounds, function(background, key) {
            var check = [];
            check['limit'] = arrBackground.length > ( filterBackground.perPage * filterBackground.currentPage  - 1 ) ? false : true;
            if( !!filterBackground.search ){
               check['name'] = art.name.toLowerCase().indexOf(filterBackground.search.toLowerCase()) >= 0 ? true : false;
            }else{
                check['name'] = true;
            };
            if( !!filterBackground.currentCat.id ){
                check['cat'] = _.includes(background.cat, filterBackground.currentCat.id) ? true : false;
            }else{
                check['cat'] = true;
            }
            if( check['limit'] && check['name'] && check['cat'] ) arrBackground.push(art);
        });
        return arrBackground
    }
});


nbdApp.filter('reverse', function() {
    return function(items) {
        return items ? items.slice().reverse() : items;
    };
});
nbdApp.directive("imageOnLoad", [ function() {
    return {
        restrict: "A",
        scope: {
            src: '=imageOnLoad'
        }, 
        link: function(scope, element) {
            var img = new Image();
            img.onload = function(){
                element.removeClass('image-onload');
            };
            img.src = scope.src;
            element.addClass('image-onload');
        }
    };
}]);
nbdApp.directive("fontOnLoad", [ function() {
    return {
        restrict: "A",
        scope: {
            font: '=',
            preview: '=',
            loadFontFailAction: '&'
        },
        link: function(scope, element) {
            var fontName = scope.font.alias,
                fontType = scope.font.type;
            if( fontName == '' ) return;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if( !jQuery('#' + font_id).length ){
                if(fontType == 'google'){
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +':400,400i,700,700i" rel="stylesheet" type="text/css">');
                }else{
                    var css = "<style type='text/css' id='" + font_id + "' >";
                    _.each(scope.font.file, function (file, index) {
                        var font_url = file;
                        if(! (file.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + file;
                        css += "@font-face {font-family: '" + fontName + "';";
                        css += "src: ";
                        css += "url('" + font_url + "') format('truetype');";
                        switch(index){
                            case "r":
                                css += "font-weight: normal;font-style: normal;"
                                break;
                            case "b":
                                css += "font-weight: bold;font-style: normal;"
                                break;
                            case "i":
                                css += "font-weight: normal;font-style: italic;"
                                break;
                            case "bi":
                                css += "font-weight: bold;font-style: italic;"
                                break;
                        };
                        css += "}";
                    });
                    css += "</style>";
                    jQuery("head").append(css);
                }
            };
            var font = new FontFaceObserver(fontName);
            font.load(scope.preview, 3E4).then(function () {
                element.removeClass('font-loading');
            }, function () {
                scope.loadFontFailAction({font: scope.font});
            }); 
            element.addClass('font-loading');
        }
    }
}]);
nbdApp.directive("nbdUploadFile", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdUploadFile'
        },
        link: function(scope, element) {
            $timeout(function() {
                jQuery( element ).on('change', function(){
                    handleFiles(this.files);
                });
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    };
}]);
nbdApp.directive("nbdDndFile", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDndFile'
        },
        link: function(scope, element) {  
            $timeout(function() {
                var dropArea = jQuery(element),
                Input = dropArea.find('input[type="file"]');
                _.each(['dragenter', 'dragover'], function(eventName, key) {
                    dropArea.on(eventName, highlight)
                });
                _.each(['dragleave', 'drop'], function(eventName, key) {
                    dropArea.on(eventName, unhighlight)
                });
                function highlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.addClass('highlight');
                };
                function unhighlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.removeClass('highlight');
                };
                dropArea.on('drop', handleDrop);
                function handleDrop(e) {
                    if( jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked') ) {
                        alert(NBDESIGNCONFIG.nbdlangs.alert_upload_term);
                        return;
                    }else{
                        if(e.originalEvent.dataTransfer){
                            if(e.originalEvent.dataTransfer.files.length) {
                                e.preventDefault();
                                e.stopPropagation();
                                handleFiles(e.originalEvent.dataTransfer.files);
                            }
                        }
                    }
                };
                dropArea.on('click', function(e){
                    Input.click();
                });
                Input.on('click', function(e){
                    e.stopPropagation();
                    if( jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked') ) {
                        alert(NBDESIGNCONFIG.nbdlangs.alert_upload_term);
                        e.preventDefault();
                        return;
                    }
                });
                Input.on('change', function(){
                    handleFiles(this.files);
                });
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    }
}]);
nbdApp.directive("nbdDropZone", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDropZone'
        },
        link: function(scope, element) {
            $timeout(function() {
                var dropArea = jQuery('#nbd-stages');
                dropArea.on('drop', handleDrop);
                function handleDrop(e) {
                    if(e.originalEvent.dataTransfer){
                        if(e.originalEvent.dataTransfer.files.length) {
                            e.preventDefault();
                            e.stopPropagation();
                            handleFiles(e.originalEvent.dataTransfer.files);
                        }
                    }
                };
                function handleFiles(files) {
                    if(files.length > 0) scope.uploadFile({files: files});
                } 
            });
        }
    };
}]);
nbdApp.directive("nbdDrag", [ function() {
    return {
        restrict: "AE",
        scope: {
            url: '=nbdDrag',
            img: '=nbdImg',
            extenal: '@extenal',
            type: '@type'
        },
        link: function( scope, element, attrs ) {
            element.attr("draggable", "true");
            element.on('dragstart', function(event) {
                event.originalEvent.dataTransfer.setData("src",scope.url);
                event.originalEvent.dataTransfer.setData("extenal",scope.extenal);
                event.originalEvent.dataTransfer.setData("type",scope.type);
                if( angular.isDefined( scope.img ) && angular.isDefined( scope.img.origin_url ) ){
                    event.originalEvent.dataTransfer.setData("origin_url", scope.img.origin_url);
                    event.originalEvent.dataTransfer.setData("origin_width", scope.img.width);
                    event.originalEvent.dataTransfer.setData("origin_height", scope.img.height);
                }
            });
        }
    }
}]);
nbdApp.directive("boundingCorner", ['$timeout', function($timeout) {
    return {
        restrict: "C",
        scope: {
            stage: '@',
            type: '@'
        },
        link: function(scope, element) {
            $timeout(function() {
                if(scope.type != ''){
                    jQuery(element).on('mousedown', function(e){
                        var targetCanvas = document.querySelector ("#stage-container-" + scope.stage + " .upper-canvas");
                        if( targetCanvas ){
                            var evt = document.createEvent("MouseEvents");
                            evt.initMouseEvent("mousedown", true, true, window, 0, e.originalEvent.pageX, e.originalEvent.pageY, e.originalEvent.clientX, e.originalEvent.clientY, false, false, false, false, 0, null);
                            targetCanvas.dispatchEvent(evt);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                    });
                }
            });
        }
    }
}]);
nbdApp.directive('rulerGuideline', ['$timeout',  function($timeout){
    return {
       restrict: "AE",
        scope: {
            direction: '@rulerGuideline',
            preventClick: '=preventClick',
            offset: '=offset',
            ratio: '@ratio',
            cwidth: '@cwidth'
        },
        link: function( scope, element, attrs ){
            $timeout(function(){
                var el = jQuery(element);
                var stageEl = el.parents('.stage');
                el.on('mousedown', function(event) {
                    stageEl.find('.guide-backdrop').removeClass('nbd-prevent-event');
                    stageEl.on('mousemove.nbd-move-guideline', function(event){
                        var ratio = parseFloat(scope.ratio);
                        var cwidth = parseFloat(scope.cwidth);
                        var stagePos = stageEl.offset(),
                        top = event.pageY - stagePos.top + stageEl.scrollTop(),
                        left = event.pageX - stagePos.left + stageEl.scrollLeft();
                        top = top <= 40 ? top : (40 + (top - 40) / ratio);
                        var stageElWidth = stageEl.width();
                        var additionalPadding = (cwidth * ratio - stageElWidth) / 2;
                        if( additionalPadding < 0  ){
                            left = left > 50 ? (stageElWidth / 2 - (stageElWidth / 2 + 50 - left)/ratio + 50) : left;
                        }else{
                            left = stageElWidth / 2 - (stageElWidth / 2 + 50 + additionalPadding - left)/ratio + 50;
                        };
                        scope.offset = scope.direction == 'hor' ? top : left;
                    });
                    event.preventDefault();
                }).on('mouseup', function(event){
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                stageEl.on('mouseup', function(){
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                el.trigger('mousedown');
            });
        }
    };
}]);
nbdApp.directive("nbdColorPicker", ['$timeout', function($timeout) {
    return {
        restrict: "C",
        scope: {
            cattr: '@',
            color: '@',
            type: '@'
        },
        link: function(scope, element) {
            jQuery(element).on('click', function(){
                $timeout(function() {
                    jQuery('#nbd-global-color-palette').addClass('show');
                });
                scope.$emit('nbd:picker', scope.cattr, scope.color, scope.type);
            });
        }
    };
}]);
nbdApp.directive("nbdClearStage", function() {
    return {
        restrict: "A",
        link: function(scope, element) {
            jQuery(element).on('click', function(){
                if( NBDESIGNCONFIG.nbdesigner_prevent_delete_template_layer == 'yes' && !( NBDESIGNCONFIG.task == 'create' || ( NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template' ) ) ) return;
                jQuery('.nbd-popup.clear-stage-alert, .v-popup.v-popup-select').nbShowPopup();
            });
        }
    };
});
nbdApp.directive("stageCell", ['$timeout', function($timeout) {
    return {
        restrict: "E",
        transclude: true,
        template: '<ng-transclude></ng-transclude>'
    };
}]);
nbdApp.directive("stageCellInner", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).on('dragstart', function(e){
                    from = jQuery(this).attr('data-position');
                    e.originalEvent.dataTransfer.setData('data_position', from);
                    e.originalEvent.dataTransfer.setData('data_active', 1);
                });
                jQuery(element).on('dragover', function(e){
                    e.preventDefault();

                    var position = jQuery(this).attr('data-position'),
                    next = position * 1 + 1;
                    if( e.originalEvent.pageX > ( jQuery(element).offset().left + jQuery(element).width() / 2 ) ){
                        jQuery( '.stage-space[data-position="' + next + '"]' ).addClass('active');
                        jQuery( '.stage-space[data-position="' + position + '"]' ).removeClass('active');
                        jQuery(element).attr('data-drop-position', next);
                    }else{
                        jQuery( '.stage-space[data-position="' + position + '"]' ).addClass('active');
                        jQuery( '.stage-space[data-position="' + next + '"]' ).removeClass('active');
                        jQuery(element).attr('data-drop-position', position);
                    }
                });
                jQuery(element).on('dragleave', function(e){
                    var position = jQuery(this).attr('data-position'),
                    next = position * 1 + 1;
                    jQuery( '.stage-space[data-position="' + position + '"], .stage-space[data-position="' + next + '"]' ).removeClass('active');
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
                jQuery(element).on('drop', function(e){
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                    active = e.originalEvent.dataTransfer.getData('data_active'),
                    position = jQuery(this).attr('data-position');
                    if( position != from ){
                        var to = jQuery(this).attr('data-drop-position');
                        if( active == '1' ){
                            scope.$emit('stage:move', from * 1, to * 1);
                        }
                    }
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
            });
        }
    }
}]);
nbdApp.directive("stageSpace", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).on('dragenter', function(e){
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragover', function(e){
                    e.preventDefault();
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragleave', function(e){
                    jQuery(this).removeClass('active');
                });
                jQuery(element).on('drop', function(e){
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                    active = e.originalEvent.dataTransfer.getData('data_active');
                    var to = jQuery(this).attr('data-position');
                    if( active == '1' ){
                        scope.$emit('stage:move', from * 1, to * 1);
                    }
                });
            });
        }
    }
}]);
nbdApp.directive("nbdBackground", ['$timeout', function($timeout) {
    return {
        restrict: "C",
        scope: {
            src: '@src'
        },
        link: function(scope, element) {
            $timeout(function() {
                var img = new Image();
                img.onload = function(){
                    jQuery(element).css({'background-image': 'url(' +  scope.src +')'});
                    jQuery(element).removeClass('loading');
                };
                img.src = scope.src;
            });
        }
    };
}]);
nbdApp.directive("nbdCapture", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        scope: {
            nbdCapture: '&'
        },
        link: function(scope, element) {
            $timeout(function() {
                jQuery(element).unbind( "paste" );
                jQuery(element).bind('paste', function(e){
                    var clipboard = e.originalEvent.clipboardData;
                    if( clipboard ){
                        if ( clipboard.items ) {
                            var items = clipboard.items;
                            for ( var i = 0; i < items.length; ++i ) {
                                if ( items[i].kind === 'file' && items[i].type.indexOf('image/') !== -1 ) {
                                    scope.nbdCapture( {
                                        file: items[i].getAsFile(),
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }
        
                        if ( clipboard.files ) {
                            var items = clipboard.files;
                            for ( var i = 0; i < items.length; ++i ) {
                                if ( items[i].type.indexOf('image/') !== -1 ) {
                                    scope.nbdCapture( {
                                        file: items[i],
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }
                    }
                });
            });
        }
    };
}]);
if(NBDESIGNCONFIG.nbdesigner_show_all_template_sides == 'yes'){
    nbdApp.directive("nbdTemplateHover", ['$timeout', function($timeout) {
        return {
            restrict: "A",
            scope: {
                idTmpl: '@nbdTemplateHover'
            },
            link: function(scope, element) {
                if (!checkMobileDevice()) {
                    $timeout(function() {
                        jQuery(element).tooltipster({
                            content: jQuery('#tooltip_content_' + scope.idTmpl),
                            interactive: true,
                            side: "right",
                            theme: 'tooltipster-template',
                            functionReady: function(){
                                jQuery('#tooltip_content_' + scope.idTmpl).perfectScrollbar('update');
                            }
                        });
                    }, 500);
                }; 
            }
        };    
    }]);
};
nbdApp.directive("contextSubMenu", ['$timeout', '$window', function($timeout, $window){
    return {
        restrict: "C",
        link: function(scope, element) {
            jQuery( element ).on( 'mouseenter', function(){
                jQuery('.second-contexts').removeClass('deactive');
                $timeout(function(){
                    var workBenchWidth  = $window.innerWidth,
                    workBenchHeight     = $window.innerHeight,
                    position            = jQuery( element ).offset(),
                    subMenu             = jQuery( element ).find( '.second-contexts' ),
                    parentWidth         = jQuery( element ).parent('.contexts').width(),
                    subMenuWidth        = subMenu.width(),
                    subMenuHeight       = subMenu.height();
                    if( workBenchWidth < ( position.left + subMenuWidth + parentWidth + 15 ) ) {
                        subMenu.removeClass( 'left' ).addClass( 'right' );
                    }else{
                        subMenu.removeClass( 'right' ).addClass( 'left' );
                    }
                    if( workBenchHeight < ( position.top + subMenuHeight + 15 )){
                        subMenu.css('bottom', '-40px');
                    }else{
                        subMenu.css('bottom', 'unset');
                    }
                }, 100);
            } );
        }
    };
}]);
nbdApp.directive("nbdPopupTrigger", ['$timeout', function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function() {
                jQuery(element).on('click', function () {
                    var target = jQuery(this).attr('data-popup');
                    jQuery('.' + target).nbShowPopup();
                });
            });
        }
    };
}]);
nbdApp.directive("nbdPerfectScroll", function($timeout) {
    return {
        restrict: "A",
        link: function(scope, element) {
            $timeout(function(){
                jQuery(element).perfectScrollbar();
            })
        }
    };    
});
nbdApp.directive('convertToNumber', function() {
    return {
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function(val) {
                return val != null ? parseInt(val, 10) : null;
            });
            ngModel.$formatters.push(function(val) {
                return val != null ? '' + val : null;
            });
        }
    };
});
nbdApp.directive('photoFrame', function() {
    return {
        restrict: "EA",
        scope: {
            frame: "="
        },
        template: '<div class=\"frame-wrap-inner\" ng-style=\"getFrameStyle()\">'+
                   '<div class=\"frame-panel\" ng-repeat=\"panel in framePanel\" ng-style=\"{\'grid-area\': panel + \'/\' + panel + \'/\' + panel + \'/\' + panel}\"></div>' + 
                   '</div>',
        controller: function( $scope ){
            $scope.framePanel = [];
            function init(){
                var rows = $scope.frame.areas.match(/[^"]+(?=(" ")|"$)/g),
                    panels = [];
                rows.forEach(function(row){
                    panels = panels.concat( row.split(" ") );
                });
                $scope.framePanel = _.uniq(panels);
            }
            init();
            $scope.getFrameStyle = function(){
                var objStyle = {};
                if( $scope.frame.areas != '' ){
                    objStyle['grid-template-areas'] = $scope.frame.areas;
                }
                if( $scope.frame.rows != '' ){
                    objStyle['grid-template-rows'] = $scope.frame.rows;
                }
                if( $scope.frame.columns != '' ){
                    objStyle['grid-template-columns'] = $scope.frame.columns;
                }
                return objStyle;
            };
        }
    }
});
nbdApp.factory('NBDDataFactory', function($http){
    return {
        get : function(action, data, callback, progressCallback) {
            var formData = new FormData();
            formData.append("action", action);
            var nonce = action == 'nbd_get_resource' ? NBDESIGNCONFIG['nonce_get'] : NBDESIGNCONFIG['nonce'];
            formData.append("nonce", nonce);
            var isUploadFile = false;
            angular.forEach(data, function (value, key) {
                var keepDefault = ['file', 'design', 'config', 'product', 'upload', 'used_font', 'option', 'preview', 'template_thumb'];
                if( typeof value != 'object' || _.includes(keepDefault, key) || key.indexOf("frame") > -1 ){
                    formData.append(key, value);
                }else{
                    var keyName;
                    for (var k in value) {
                        if (value.hasOwnProperty(k)) {
                            keyName = [key, '[', k, ']'].join('');
                            formData.append(keyName, value[k]);
                        }
                    }
                }
                if( key == 'file' ) isUploadFile = true;
            });
            var config = {
                transformRequest: angular.identity,
                transformResponse: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            };
            if( isUploadFile ){
                config.uploadEventHandlers = {
                    progress: function (e) {
                        if (e.lengthComputable) {
                            var progressBar = (e.loaded / e.total) * 100;
                            progressCallback(progressBar);
                        }
                    }
                };
            }
            var url = NBDESIGNCONFIG['ajax_url'];
            if( data.type == 'typography' || data.type == 'get_typo' ) url = appConfig.mediaUrl + '/typo';
            if( data.source == 'media' ) url = appConfig.mediaUrl + '/template';
            $http.post(url, formData, config).then(
                function(response) {
                    callback(response.data);
                },
                function(response) {
                    console.log(response);
                }
            );
        }
    }
});
nbdApp.filter('html_trusted', ['$sce', function($sce){
    return function(text) {
        var div = document.createElement('div');
        text += '';
        div.innerHTML = text;
        return $sce.trustAsHtml(div.textContent);
    };
}]);
nbdApp.filter('range', [ function(){
    return function (input, total) {
        total = parseInt(total);
        for (var i = 0; i < total; i++) {
            input.push(i);
        }
        return input;
    };
}]);
if( NBDESIGNCONFIG['nbdesigner_enable_facebook_photo'] == 'yes' && NBDESIGNCONFIG['fbID'] != ''){
    window.fbAsyncInit = function() {
        FB.init({
            appId                   : NBDESIGNCONFIG['fbID'],
            status                  : true, 
            cookie                  : true,
            xfbml                   : true,
            autoLogAppEvents        : true,
            version                 : 'v5.0'
        });
    };
    (function(d, s, id){
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) {return;}
          js = d.createElement(s); js.id = id;
          js.src = "https://connect.facebook.net/en_US/sdk.js";
          fjs.parentNode.insertBefore(js, fjs);
     }(document, 'script', 'facebook-jssdk'));
    var nbdOnFBLogin = function(){
        FB.getLoginStatus(function(response) {
            if (response.status === "connected") {
                var uid = response.authResponse.userID;
                var accessToken = response.authResponse.accessToken;
                var scope = angular.element(document.getElementById("designer-controller")).scope();
                scope.getPersonalPhoto('facebook', [uid, accessToken]);
                scope.updateApp();
            }
        });
    };
};
function requestFullScreen(element) {
    var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
    if (requestMethod) { 
        requestMethod.call(element);
    } else if (typeof window.ActiveXObject !== "undefined") {
        var wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{Esc}");
        }
    }
};
function exitFullscreen(){
    var a = document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen || document.exitFullscreen;
    a && a.call(document);
};
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
};
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
};
window.addEventListener("message", receiveMessage, false);
function receiveMessage(event){
    if( event.origin == window.location.origin ){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if( event.data == 'change_nbo_options' ){
            scope.changePrintingOptions();
        };
        if( event.data == 'change_nbd_qty' && NBDESIGNCONFIG['ui_mode'] == 1 ){
            scope.resource.config.qty = nbd_window.NBDESIGNERPRODUCT.qty;
            scope.updateQtys();
        };
        if( event.data == 'start_load_3d_model' ){
            jQuery('.preview-3d-wrap-inner .preview-3d-wrap-loading').removeClass('hiddden');
        };
        if( event.data == 'loaded_3d_model' ){
            jQuery('.preview-3d-wrap-inner .preview-3d-wrap-loading').addClass('hiddden');
            scope.threeDimensionPreview.modelLoaded = true;
            scope.update3DPreviewTexture();
        }
    };
};
function nbdPostMessage(){
    nbd_window.postMessage("received", window.location.origin);
};
/* Change variation */
nbd_window.jQuery('input[name="variation_id"]').on('change', function(){
    if( NBDESIGNCONFIG['ui_mode'] == 1 || (NBDESIGNCONFIG['ui_mode'] == 3 && angular.isUndefined(window.nbOption)) ){
        if(appConfig.ready){
            var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
            if(NBDESIGNCONFIG['variation_id'] == variation_id) return;  
            var scope = angular.element(document.getElementById("designer-controller")).scope();
            if(variation_id != ''){
                nbd_window.NBDESIGNERPRODUCT.nbdesigner_unready();
                if(NBDESIGNCONFIG['nbdesigner_hide_button_cart_in_detail_page'] == 'yes'){
                    nbd_window.jQuery('button[type="submit"].single_add_to_cart_button').hide();
                }
            }
            NBDESIGNCONFIG['variation_id'] = variation_id;
            if(variation_id != ''){
                scope.changeVariation();
            }
        }
    }
});
jQuery(document).on( 'change_nbo_options_without_od_option', function(){
    if(appConfig.ready){
        if( NBDESIGNCONFIG['ui_mode'] == 3 || NBDESIGNCONFIG['ui_mode'] == 2 ){
            if( nbd_window.jQuery('input[name="variation_id"]').length ){
                setTimeout(function(){
                    var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
                    if(NBDESIGNCONFIG['variation_id'] == variation_id) return;  
                    NBDESIGNCONFIG['variation_id'] = variation_id;
                    if(variation_id > 0){
                        var scope = angular.element(document.getElementById("designer-controller")).scope();
                        scope.changeVariation();
                    }
                });
            }
        }
    }
});
jQuery(document).on( 'change_nbo_options_with_od_option', function(){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if( NBDESIGNCONFIG['ui_mode'] == 3 || (NBDESIGNCONFIG['ui_mode'] == 2 && scope.settings.nbdesigner_display_product_option == '2' ) ){
            if( nbd_window.jQuery('input[name="variation_id"]').length ){
                setTimeout(function(){
                    var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
                    NBDESIGNCONFIG['variation_id'] = variation_id;
                    scope.printingOptionsAvailable = ( variation_id > 0 ) ? true : false;
                });
            } else {
                scope.printingOptionsAvailable = true;
            }
            scope.changePrintingOptions();
        }
    }
});
jQuery(document).on( 'change_nbo_options', function(){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if( jQuery('input[name="variation_id"]').length ){
            setTimeout(function(){
                scope.printingOptionsAvailable = jQuery('input[name="variation_id"]').val() > 0 ? true : false;
                NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
            });
        }else{
            scope.printingOptionsAvailable = true;
        }
        scope.updateApp();
    }
});
jQuery(document).on( 'invalid_nbo_options', function(){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.printingOptionsAvailable = false;
        scope.updateApp();
    }
});
jQuery(document).on( 'change_nbo_extra_od_options', function(){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.changeExtraOdOptions();
        scope.updateApp();
    }
});
jQuery(document).on( 'nbc_enable_share_design', function(e, data){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.resource.shareDesign = true;
        scope.updateApp();
    }
});
jQuery(document).on( 'nbc_disable_share_design', function(e, data){
    if(appConfig.ready){
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.resource.shareDesign = true;
        scope.updateApp();
    }
});
if( NBDESIGNCONFIG['ui_mode'] == 1 ) {
    nbd_window.jQuery(nbd_window.document).on( 'change_nbo_extra_od_options', function(){
        if(appConfig.ready){
            var scope = angular.element(document.getElementById("designer-controller")).scope();
            scope.changeExtraOdOptions();
            scope.updateApp();
        }
    });
    nbd_window.jQuery(nbd_window.document).triggerHandler( 'trigger_live_chat_from_iframe' );
};
if( NBDESIGNCONFIG['ui_mode'] == 3 ){
    function bootstrapNbdApp(){
        var nbdAppEl = document.getElementById('nbd-vista-app');
        angular.element(function() {
            angular.bootstrap(nbdAppEl, ['nbdApp']);
        });
    };
    if( window.nbOption ){
        jQuery(document).on( 'initialed_nbo_options', function(){
            bootstrapNbdApp();
        });
    }else{
        jQuery(document).ready(function(){
            bootstrapNbdApp();
        });
    }
};